\paragraph*{Notifications}\hypertarget{notifications}{}\label{notifications}

\begin{align*}
  [ ~ 
  \textsf{Barriers
          } ~ & \textsf{} \\
  \KEY{Funcon} ~ & \NAMEREF{barrier-create} \\
  \KEY{Funcon} ~ & \NAMEREF{barrier-sync} \\
  \KEY{Funcon} ~ & \NAMEREF{barrier-sync-else-wait} \\
  \textsf{Conditions
          } ~ & \textsf{} \\
  \KEY{Funcon} ~ & \NAMEREF{condition-create} \\
  \KEY{Funcon} ~ & \NAMEREF{condition-wait} \\
  \KEY{Funcon} ~ & \NAMEREF{condition-wait-with-lock} \\
  \KEY{Funcon} ~ & \NAMEREF{condition-notify-all} \\
  \KEY{Funcon} ~ & \NAMEREF{condition-notify-first} \\
  \textsf{Rendezvous
          } ~ & \textsf{} \\
  \KEY{Funcon} ~ & \NAMEREF{rendezvous-create} \\
  \KEY{Funcon} ~ & \NAMEREF{rendezvous-sync} \\
  \KEY{Funcon} ~ & \NAMEREF{rendezvous-sync-else-wait}
  ~ ]
\end{align*}
Threads may synchronise by waiting for notifications. In contrast to locks,
notifications are ephemeral, and do not get held and released.

\subparagraph*{Barriers}\hypertarget{barriers}{}\label{barriers}

A \href{https://en.wikipedia.org/wiki/Barrier_(computer_science)}{barrier} notifies all requesting threads when a specified number of requests
for it have been made. Subsequent requests give immediate notification.

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{barrier-create}(\VAR{N} : \NAME{pos-ints}) :  \TO \NAME{syncs} \\
  & \quad \leadsto \NAME{give}
                     ( \NAME{sync-create}
                         ( \NAME{sync-feature-create} ~
                             \NAME{sync-waiting-list}, \\&\quad \quad \quad \quad \quad 
                           \NAME{sync-feature-create} ~
                             \NAME{sync-count} ), \\&\quad \quad \quad \quad 
                       \NAME{sequential}
                         ( \NAME{assign}
                             ( \NAME{sync-feature}
                                 ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                   \NAME{sync-count} ), \\&\quad \quad \quad \quad \quad \quad 
                               \VAR{N} ), \\&\quad \quad \quad \quad \quad 
                           \NAME{given} ) )
\end{align*}
When the barrier is already open, requests to pass it are granted immediately.
When the barrier is closed, and only one more thread needs to arrive, granting
a request for it opens the barrier and resumes all the threads wiating for it;
otherwise the request fails.

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{barrier-sync}(\VAR{SY} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{give}
                       ( \NAME{sync-feature}
                           ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{sync-count} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{else}
                           ( \NAME{check-true} ~
                               \NAME{is-equal}
                                 ( \NAME{assigned} ~
                                     \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad \quad 
                                   0 ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{sequential}
                               ( \NAME{check-true} ~
                                   \NAME{is-equal}
                                     ( \NAME{assigned} ~
                                         \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad \quad \quad 
                                       1 ), \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{assign}
                                   ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad \quad 
                                     0 ), \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{thread-resume} ~
                                   \NAME{list-elements} ~
                                     \NAME{assigned} ~
                                       \NAME{sync-feature}
                                         ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad 
                                           \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{assign}
                                   ( \NAME{sync-feature}
                                       ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad \quad \quad 
                                         \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad \quad \quad \quad \quad 
                                     [  ~  ] ) ) ) )
\end{align*}
When the request fails, the current thread is added to the waiting list, and
suspended until the request can be granted:

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{barrier-sync-else-wait}(\VAR{SY} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{else}
                       ( \NAMEREF{barrier-sync}
                           ( \VAR{SY} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{sequential}
                           ( \NAME{sync-waiting-list-add}
                               ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{current-thread} ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{assign}
                               ( \NAME{sync-feature}
                                   ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad \quad 
                                     \NAME{sync-count} ), \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{checked} ~
                                   \NAME{nat-pred} ~
                                     \NAME{assigned} ~
                                       \NAME{sync-feature}
                                         ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad 
                                           \NAME{sync-count} ) ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{thread-suspend} ~
                               \NAME{current-thread} ) )
\end{align*}
\subparagraph*{Conditions}\hypertarget{conditions}{}\label{conditions}

A \href{http://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf}{condition} is used to represent whether some property holds or not.
Threads may request to be notified when another thread makes the property hold.

A condition may notify either one or all of its requesting threads. When it has
to notify one thread but more than one request for notification has been made,
the choice of thread may be determined by the scheduler. When it has to notify
more than one thread, the property associated with the condition may have been
invalidated by the time the executions of some of them are resumed, and threads
may need to iterate requests for notifications.

In practice, a condition is generally associated with an exclusive lock. When
a thread awaiting the condition is notified, it requests the exclusive lock and
tests whether the required property holds; if it does not, the thread releases
the exclusive lock, and atomically reverts to requesting the notification.

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{condition-create} :  \TO \NAME{syncs} \\
  & \quad \leadsto \NAME{sync-create}
                     ( \NAME{sync-feature-create} ~
                         \NAME{sync-waiting-list} )
\end{align*}
A condition request always adds the current thread to the waiting list, and
suspends it until the request can be granted. (In practice, it takes also an
associated exclusive lock as a further argument, assumed to be held by the
current thread, and releases it at the same time as suspending the thread.)

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{condition-wait}(\VAR{SY} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{sequential}
                       ( \NAME{sync-waiting-list-add}
                           ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{current-thread} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{thread-suspend} ~
                           \NAME{current-thread} )
\end{align*}
In practice, a condition request usually takes also an associated exclusive lock
as a further argument, assumed to be held by the current thread, releases it
together with suspending the thread, and waits for the lock when resumed:

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{condition-wait-with-lock}(\VAR{SY} : \NAME{syncs}, \VAR{L} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{sequential}
                     ( \NAME{thread-atomic} ~
                         \NAME{sequential}
                           ( \NAME{exclusive-lock-release}
                               ( \VAR{L} ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{sync-waiting-list-add}
                               ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{current-thread} ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{thread-suspend} ~
                               \NAME{current-thread} ), \\&\quad \quad \quad \quad 
                       \NAME{exclusive-lock-sync-else-wait}
                         ( \VAR{L} ) )
\end{align*}
Threads that are waiting for the condition are notified simply by resuming them.
To notify them all:

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{condition-notify-all}(\VAR{SY} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{sequential}
                       ( \NAME{thread-resume} ~
                           \NAME{list-elements} ~
                             \NAME{assigned} ~
                               \NAME{sync-feature}
                                 ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad \quad \quad 
                                   \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{assign}
                           ( \NAME{sync-feature}
                               ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad \quad \quad 
                             [  ~  ] ) )
\end{align*}
To notify just one of the waiting threads:

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{condition-notify-first}(\VAR{SY} : \NAME{syncs}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{give}
                       ( \NAME{sync-waiting-list-head-remove}
                           ( \VAR{SY} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{thread-resume} ~
                           \NAME{given} )
\end{align*}
\subparagraph*{Rendezvous}\hypertarget{rendezvous}{}\label{rendezvous}

A rendezvous notifies all requesting threads as soon as a specified number $\SHADE{\VAR{N}}$
of them have made \emph{matching} requests for it. The rendezvous can store any number
of non-matching requests. If a request that completes a rendezvous matches
different sets of $\SHADE{\VAR{N-1}}$ pending requests, the {}`lexicographically{}' earliest set
of requests is selected; for a binary rendezvous, this is the first matching
request in the stored list.

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{rendezvous-create}(\VAR{N} : \NAME{pos-ints}) :  \TO \NAME{syncs} \\
  & \quad \leadsto \NAME{give}
                     ( \NAME{sync-create}
                         ( \NAME{sync-feature-create} ~
                             \NAME{sync-waiting-list}, \\&\quad \quad \quad \quad \quad 
                           \NAME{sync-feature-create} ~
                             \NAME{sync-count} ), \\&\quad \quad \quad \quad 
                       \NAME{sequential}
                         ( \NAME{assign}
                             ( \NAME{sync-feature}
                                 ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                   \NAME{sync-count} ), \\&\quad \quad \quad \quad \quad \quad 
                               \VAR{N} ), \\&\quad \quad \quad \quad \quad 
                           \NAME{given} ) )
\end{align*}
Each rendezvous request includes a pattern, and the corresponding notifications
give environments obtained by matching the patterns against the same unified
value. When the pattern in each request is simply a value, a rendezvous notifies
all the requesting threads as soon as the specified number of requests with the
same value have been made. When the pattern in one request is a value, a pattern
in another request may bind an identifier to that value, giving one-way data flow.

A rendezvous request may also include a set of additional threads which are all
required to participate in the rendezvous. When a pair of matching binary
rendezvous requests each specify the other thread as the only required
participant, the rendezvous is restricted to that pair of threads. When one of
the sets is empty, the rendezvous may involve any other thread.

\begin{quote}
In this simplified version, rendezvous are always binary, patterns in
requests are ground values, and sets of required threads are omitted.
\end{quote}

When a rendezvous is available, granting a request for it removes the first
matching element from the waiting list, and resumes its thread; otherwise the
request fails.

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{rendezvous-sync}(\VAR{SY} : \NAME{syncs}, \VAR{V} : \NAME{ground-values}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{give}
                     ( \NAME{assigned} ~
                         \NAME{sync-feature}
                           ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad 
                       \NAME{sequential}
                         ( \NAME{check-true} ~
                             \NAMEREF{is-rendezvous-match}
                               ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \VAR{V} ), \\&\quad \quad \quad \quad \quad 
                           \NAME{assign}
                             ( \NAME{sync-feature}
                                 ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                   \NAME{sync-waiting-list} ), \\&\quad \quad \quad \quad \quad \quad 
                               \NAMEREF{rendezvous-first-match-drop}
                                 ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                   \VAR{V} ) ), \\&\quad \quad \quad \quad \quad 
                           \NAME{thread-resume} ~
                             \NAMEREF{rendezvous-first-match-thread}
                               ( \NAME{given}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \VAR{V} ) ) )
\end{align*}
When the request fails, a tuple of the value and the current thread is added
to the waiting list, and the thread suspended until the request can be granted:

\begin{align*}
  \KEY{Funcon} ~ 
  & \NAMEDECL{rendezvous-sync-else-wait}(\VAR{SY} : \NAME{syncs}, \VAR{V} : \NAME{ground-values}) :  \TO \NAME{null-type} \\
  & \quad \leadsto \NAME{thread-atomic} ~
                     \NAME{else}
                       ( \NAMEREF{rendezvous-sync}
                           ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad 
                             \VAR{V} ), \\&\quad \quad \quad \quad \quad 
                         \NAME{sequential}
                           ( \NAME{sync-waiting-list-add}
                               ( \VAR{SY}, \\&\quad \quad \quad \quad \quad \quad \quad 
                                 \NAME{tuple}
                                   ( \VAR{V}, \\&\quad \quad \quad \quad \quad \quad \quad \quad 
                                     \NAME{current-thread} ) ), \\&\quad \quad \quad \quad \quad \quad 
                             \NAME{thread-suspend} ~
                               \NAME{current-thread} ) )
\end{align*}
The remaining rendezvous funcons are all auxiliary:

\begin{align*}
  \KEY{Auxiliary Type} ~  
  & \NAMEDECL{rendezvous-waits}  
  \leadsto \NAME{tuples}
             ( \NAME{ground-values},      
               \NAME{thread-ids} )
\end{align*}
The funcon $\SHADE{\NAMEREF{is-rendezvous-match}
           ( \VAR{L},   
             \VAR{V} )}$ returns whether the list $\SHADE{\VAR{L}}$ contains
$\SHADE{\NAME{tuple}
           ( \VAR{V},   
             \VAR{TI} )}$ for some $\SHADE{\VAR{TI}}$:

\begin{align*}
  \KEY{Auxiliary Funcon} ~ 
  & \NAMEDECL{is-rendezvous-match}(\_ : \NAME{lists}
                                ( \NAMEREF{rendezvous-waits} ), \_ : \NAME{ground-values}) :  \TO \NAME{booleans}
\end{align*}
\begin{align*}
  \KEY{Rule} ~ 
    & \NAMEREF{is-rendezvous-match}
        ( [ \NAME{tuple}
              ( \VAR{V}',    
                \VAR{TI} ),   
            \VAR{P}\STAR ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{if-true-else}
          ( \NAME{is-equal}
              ( \VAR{V}',    
                \VAR{V} ),   
            \NAME{true},   
            \NAMEREF{is-rendezvous-match}
              ( [ \VAR{P}\STAR ],    
                \VAR{V} ) )
\\
  \KEY{Rule} ~ 
    & \NAMEREF{is-rendezvous-match}
        ( [  ~  ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{false}
\end{align*}
The funcon $\SHADE{\NAMEREF{rendezvous-first-match-thread}
           ( \VAR{L},   
             \VAR{V} )}$ returns the thread-id of the
first element of $\SHADE{\VAR{L}}$ with value $\SHADE{\VAR{V}}$:

\begin{align*}
  \KEY{Auxiliary Funcon} ~ 
  & \NAMEDECL{rendezvous-first-match-thread}(\_ : \NAME{lists}
                                ( \NAMEREF{rendezvous-waits} ), \_ : \NAME{values}) :  \TO \NAME{thread-ids}
\end{align*}
\begin{align*}
  \KEY{Rule} ~ 
    & \NAMEREF{rendezvous-first-match-thread}
        ( [ \NAME{tuple}
              ( \VAR{V}',    
                \VAR{TI} ),   
            \VAR{P}\STAR ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{if-true-else}
          ( \NAME{is-equal}
              ( \VAR{V}',    
                \VAR{V} ),   
            \VAR{TI},   
            \NAMEREF{rendezvous-first-match-thread}
              ( [ \VAR{P}\STAR ],    
                \VAR{V} ) )
\\
  \KEY{Rule} ~ 
    & \NAMEREF{rendezvous-first-match-thread}
        ( [  ~  ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{fail}
\end{align*}
The funcon $\SHADE{\NAMEREF{rendezvous-first-match-drop}
           ( \VAR{L},   
             \VAR{V} )}$ returns the list $\SHADE{\VAR{L}}$ omitting the
first element with value $\SHADE{\VAR{V}}$:

\begin{align*}
  \KEY{Auxiliary Funcon} ~ 
  & \NAMEDECL{rendezvous-first-match-drop}(\_ : \NAME{lists}
                                ( \NAMEREF{rendezvous-waits} ), \_ : \NAME{values}) :  \TO \NAME{lists}
                                                                         ( \NAMEREF{rendezvous-waits} )
\end{align*}
\begin{align*}
  \KEY{Rule} ~ 
    & \NAMEREF{rendezvous-first-match-drop}
        ( [ \NAME{tuple}
              ( \VAR{V}',    
                \VAR{TI} ),   
            \VAR{P}\STAR ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{if-true-else}
          ( \NAME{is-equal}
              ( \VAR{V}',    
                \VAR{V} ),   
            [ \VAR{P}\STAR ],   
            \NAME{cons}
              ( \NAME{tuple}
                  ( \VAR{V}',     
                    \VAR{TI} ),    
                \NAMEREF{rendezvous-first-match-drop}
                  ( [ \VAR{P}\STAR ],     
                    \VAR{V} ) ) )
\\
  \KEY{Rule} ~ 
    & \NAMEREF{rendezvous-first-match-drop}
        ( [  ~  ],   
          \VAR{V} : \NAME{values} ) \leadsto
        \NAME{fail}
\end{align*}
A series of rendezvous between the same two threads is called an extended
rendezvous.  After the completion of each rendezvous in the series, one of the
threads may immediately request the next, allowing the other thread to execute
some code before synchronising. A simple rendezvous is restricted to
synchronisation, and does not involve ordinary computation steps.

