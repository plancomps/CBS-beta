{"0": {
    "doc": "Browsing",
    "title": "Browsing",
    "content": "# Browsing CBS-beta specifications {% include navigation.md %} [Sources]: Sources [Plain]: Plain [Pretty]: Pretty ## Navigation > __All references to names of funcons (etc.) in CBS specifications are > hyperlinks leading to their declarations.__ These hyperlinks avoid the need to drill down through the hierarchy of folders and files. Specifications in CBS are independent of the file system: all names declared in [Funcons-beta] are globally visible, and names declared in a particular language specification are local to that language, regardless of where the specification files are located. The global [Funcons-Index] page lists the names of all current funcons, grouped by file. The local Funcons-Index page for a particular language lists only the names of the funcons actually used in its specification. The [Funcon Reuse] page shows which of the languages in [Languages-beta] reference each funcon. Hovering on a reference to a funcon displays the declared arity of symbol: `values` stands for a *single* argument, and `values*` for any number of arguments. ## Web pages > {:.note} > > You can toggle the color scheme between light and dark using the button > > (&#x263c; &#x263d;) at the top of the navigation menu. Browsing CBS specifications on this website is supported by direct links to related pages. Such links are shown in the navigation panel, and at the top or bottom of each page. > The navigation panel appears as a sidebar when the window width is sufficient. > In narrower windows (or after zooming in) the sidebar disappears, but its contents can be displayed > by clicking a button at the top right. Sibling pages : - The navigation panel shows links to all the sibling pages. - The top right and bottom left of the page show links to the preceding and next sibling page as arrows. Parent pages : - The navigation panel shows links to all direct and indirect parental pages and their siblings. - The breadcrumb list at the top of the page shows links to the direct and indirect parent pages. - The top right and bottom left of the page show links to the direct parent page as arrows. Top pages : - The top of the page shows a link to the top-level parental page in the current format. Child pages : - The bottom of the page shows links to any child pages. Other formats : - The top of each generated page shows links to same page in alternative formats. Other pages : - The disclosure symbols in the navigation panel reveal links to all pages in all formats. Auxiliary pages : The navigation panel always shows links to the following pages: - [CBS-beta] - [Browsing] - [Publications] - [Changes] - [Downloads] Support pages : - The top right of each page shows a link to the CBS-beta repository on GitHub. - The bottom of each page shows links to the PLanCompS project website, and links for reporting issues and suggesting improvements. [Browsing]: Browsing [Publications]: Publications [Changes]: Changes [Downloads]: Downloads [Funcons-beta]: Funcons-beta [Unstable-Funcons-beta]: Languages-beta [Funcons-Index]: Funcons-beta/Funcons-Index [Unstable-Funcons-Index]: Languages-beta/Unstable-Funcons-Index [Funcon Reuse]: Languages-beta/Reuse [Languages-beta]: Languages-beta [Unstable-Languages-beta]: Unstable-Languages-beta [CBS-beta]: /CBS-beta [PLanCompS Project]: http://plancomps.github.io [CBS-beta issues...]: https://github.com/plancomps/plancomps.github.io/issues [Suggest an improvement...]: mailto:plancomps@gmail.com ",
    "url": "/CBS-beta/docs/Browsing.html",
    "relUrl": "/docs/Browsing.html"
  },"1": {
    "doc": "Changes",
    "title": "Changes",
    "content": "Beta-release changes ==================== This page lists significant additions and changes to the funcon definitions and language specifications included in the CBS beta-release, and to how they are presented on this website. {:.note} > If you notice a problem with browsing the experimental [math webpages](Pretty), > please [report it as an issue on GitHub](https://github.com/plancomps/CBS-beta/issues). > If relevant, include the browser type and version, and a screenshot illustrating the problem. 2021-07-07: [CBS-beta](/CBS-beta/) (experimental math branch) * Added redirection from `CBS-beta/Unstable-Languages-beta/LangDev-2019#SyntaxName:SYNTAX-NAME` to `CBS-beta/math/FUnstable-Languages-beta/LangDev-2019/PATH-TO-SYNTAX-DECLARATION/#SyntaxName:SYNTAX-NAME`, (and similarly for `SemanticsName`) to support permanent URLs for declarations in language specifications. (The corresponding redirections for other parts of the CBS-beta collection have not yet been added.) 2021-07-05: [CBS-beta](/CBS-beta/) (experimental math branch) * Added redirection from `CBS-beta/Funcons-beta#Name:FUNCON-NAME` to `CBS-beta/math/Funcons-beta/PATH-TO-FUNCON-DECLARATION/#Name:FUNCON-NAME`, to support permanent URLs for funcon declarations 2021-04-22: [CBS-beta](/CBS-beta/) (experimental math branch) * Fixed various broken links 2021-04-19: [CBS-beta](/CBS-beta/) (experimental math branch) * Updated to use initial version of [CBS-LaTeX](https://plancomps.github.io/cbs-latex/) macro packages for formatting [Pretty](Pretty) web pages and PDFs 2021-04-15: [CBS-beta](/CBS-beta/) (experimental math branch) * Auto-switching to dark mode replaced by manual toggle buttons (&#x263c; &#x263d;) at top of navigation menu * [Minimised FOUC](https://www.primative.net/blog/how-to-get-rid-of-the-flash-of-unstyled-content/) when opening larger math pages (mainly affecting Firefox) * Internal links relativised 2021-04-06: [CBS-beta](/CBS-beta/) (experimental math branch) * Symlinks replaced by inclusions, for building on GitHub Pages * Improved automatic switching to dark mode 2021-04-02: [CBS-beta](/CBS-beta/) (experimental math branch) * Formatting enhancements: - Developed generation of LaTeX from CBS sources - Developed a CBS-LaTeX macro package for general use - Added a [Pretty](Pretty) version of each [Plain](Plain) web page - Added LaTeX sources and PDFs corresponding to the [Pretty](Pretty) web pages - Using [KaTeX](https://katex.org) for rendering LaTeX on web pages * Added automatic switching to dark mode 2021-03-10: [Funcons-beta](Funcons-beta), [Unstable-Funcons-beta](Unstable-Funcons-beta) * Adjusted navigation order * Added links to sibling (← →) and parent (↑) pages 2021-03-10: [CBS-beta](/CBS-beta/) * GitHub Pages theme updated to [pdmosses/just-the-docs@combination-rec-nav](https://github.com/pdmosses/just-the-docs/tree/combination-rec-nav) 2020-11-02: [MiniJava-Syntax](Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/) * Layout corrected 2020-10-31: [Languages-beta](Languages-beta), [Unstable-Languages-beta](Unstable-Languages-beta) * Regenerated CBS web page sources, adding `ancestor` fields 2020-10-31: [Funcons-beta](Funcons-beta), [Unstable-Funcons-beta](Unstable-Funcons-beta) * Regenerated CBS web page sources, adding `ancestor` fields 2020-10-31: [Unstable-Funcons-beta](Unstable-Funcons-beta) * Added symlink to `/Funcons-beta` * Updated folder names and web page titles to be consistent with [Funcons-beta](Funcons-beta) 2020-10-31: [Threads](Unstable-Funcons-beta/Computations/Threads) * Merged explanations 2020-10-30: [Funcons-beta](Funcons-beta), [Languages-beta](Languages-beta) * Regenerated CBS web page sources, eliminating `grand_parent` and `nav_order` fields 2020-10-30: [Storing](Funcons-beta/Computations/Normal/Storing/) * Added parentheses for premise disambiguation (twice) 2020-10-29: [Funcons-beta](Funcons-beta), [Languages-beta](Languages-beta) * Added symlinks from language `*-cbs` project folders to `/Funcons-beta` * Added `.gitignore` files to support sub-projects of `CBS-beta` 2020-10-29: [Downloads](Downloads) * Guidelines for browsing CBS-beta offline updated 2020-10-26: [Funcons-beta](Funcons-beta) * Major revision of the overview (no changes to the formal specifications) 2020-10-26: [Computations](Funcons-beta/Computations), [Values](Funcons-beta/Values) * Expanded explanations 2020-10-26: [Entities](Funcons-beta/Entities) * New section 2020-10-26: [CBS-beta](/CBS-beta/) * GitHub Pages theme updated to fork branch [pdmosses/just-the-docs@rec-nav-2](https://github.com/pdmosses/just-the-docs/tree/rec-nav-2) 2020-07-26: [Publications](Publications) * Added a missing 2019 paper 2020-07-26: [CBS-beta](/CBS-beta/) * GitHub Pages theme using fork branch [pdmosses/just-the-docs@rec-nav](https://github.com/pdmosses/just-the-docs/tree/rec-nav) 2020-07-26: [Downloads](Downloads) * Guidelines for browsing CBS-beta offline updated 2020-04-14: [Funcons-beta](Funcons-beta), [Unstable-Funcons-beta](Unstable-Funcons-beta) * Navigation hierarchy improved 2020-04-11: [Languages-beta](Languages-beta), [Unstable-Languages-beta](Unstable-Languages-beta) * Superfluous `/CBS-beta` before end-of-line comments in generated web pages removed 2020-03-23: [CBS-beta](/CBS-beta/), [Downloads](Downloads) * [PLanCompS](https://plancomps.github.io) GitHub repository converted to an organisation * CBS-beta now a GitHub project (instead of a folder in the PLanCompS project) * Downloading guidelines updated 2020-03-17: [MiniJava-Syntax](Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/) * Layout corrected 2019-08-18: [CBS-beta](/CBS-beta/) * Global search for funcon names with hyphens now supported. 2019-08-16: [CBS-beta](/CBS-beta/) * [Just the Docs](https://pmarsceill.github.io/just-the-docs/) updated to 0.2.6. * Global search (e.g., for funcon names) now supported. 2019-08-03: [Funcon-Reuse](Languages-beta/Reuse) * Layout changed, table of contents added. 2019-07-15: [Funcons-beta](Funcons-beta), [Languages-beta](Languages-beta), [Unstable-Funcons-beta](Unstable-Funcons-beta), [Unstable-Languages-beta](Unstable-Languages-beta) * Nested sidebar navigation links and further breadcrumbs added to many pages. 2019-07-10: [Languages-beta](Languages-beta), [Unstable-Languages-beta](Unstable-Languages-beta) * Missing links to local funcons reuse indexes added in overview pages. 2019-07-08: [Unstable-Funcons-beta](Unstable-Funcons-beta) * __Tentative funcons for multithreading and synchronisation added.__ 2019-07-08: [Unstable-Languages-beta](Unstable-Languages-beta) * Three small example languages added, illustrating language extension with threads. 2019-07-08: [Funcons-beta](Funcons-beta), [Languages-beta](Languages-beta), [Browsing guide](Browsing) * __HTML pages generated from CBS specifications replaced by Markdown pages.__ The presentation of CBS specifications now shows multi-line comments as running text, with CBS notation displayed as code. This change encourages a more 'literate' style of specification, to include extensive comments that motivate and explain the formal specifications.[^literate] Literate CBS is illustrated in [Unstable-Funcons-beta](Unstable-Funcons-beta). Extensive comments have yet to be added to the CBS specifications of funcons and languages in the rest of the website. [^literate]: The well-formedness of CBS specifications is unaffected by the order in which they are presented, so here, literate specification does not require the introduction of a web of macros. 2019-07-08: [CBS-beta](/CBS-beta/) * Website structure: documentation moved to a new `docs` folder. 2019-06-30: [Computations](Funcons-beta/Computations), [Values](Funcons-beta/Values) * Overview clarified. 2019-06-11: [Downloads](Downloads) * Removed the manually-created zip of the site. 2019-06-10: [CBS-beta](/CBS-beta/) * __The beta-release review period has been further extended.__ Funcons for threads have now been developed, and are soon to be added. However, the tool support for using CBS still needs significant improvements, and the current specifications will remain open for revision until the IDE for CBS has been released. 2019-06-10: [CBS-beta](/CBS-beta/) * __The Jekyll theme used on this website has been updated to [Just-the-Docs](https://pmarsceill.github.io/just-the-docs/).__ The navigation in the sidebar is now generated from the Markdown files. The content of the web pages has not been changed. 2018-07-14: [Publications](Publications) * added. 2018-11-01: [CBS-beta](/CBS-beta/) * The beta-release review period has been extended to ~~(early)~~ 2019. This is partly because funcons for threads and processes have not yet been added to [Funcons-beta](Funcons-beta), partly because of pending improvements to the tool support for use of CBS. 2018-09-14: [`right-to-left`](Funcons-beta/Computations/Normal/Flowing/#Name_right-to-left) * funcon added. 2018-09-07: [Funcons-beta](Funcons-beta), [Languages-beta](Languages-beta) * CBS web pages regenerated: hyperlinks corrected (for variable references in rules), confusing tooltips removed. 2018-09-07: [Characters](Funcons-beta/Values/Primitive/Characters/) * `char` (alias for `unicode-character`) renamed to `unicode-char`. * `ascii-character` (alias `ascii-char`) added to [Funcons-Index](Funcons-beta/Funcons-Index/) and [funcon reuse overview](Languages-beta/Reuse). ~~2018-08-26: [Browsing](Browsing)~~ * ~~folding now applies to sequences of rules, not individual rules.~~ * ~~blank lines following a rule are now preserved when it is folded.~~ 2018-08-22: [`current-value`](Funcons-beta/Computations/Normal/Storing/#Name_current-value) * `current-value` was an alias for [`structural-assigned`](Funcons-beta/Computations/Normal/Storing/#Name_structural-assigned), which returns the value of a simple or structured variable by replacing all simple sub-variables in it by their assigned values; `current-value(V)` is still equivalent to `structural-assigned(V)` when `V` is itself a _simple_ variable, but when `V` is a _structured_ variable, it now simply returns `V`. The only use of `current-value(V)` in `Languages-beta` was in the definition of [`ocaml-light-to-string`](Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/#Name_ocaml-light-to-string), which has now been changed to use `assigned`. 2018-08-17: [Downloads](Downloads) * added a page about downloading for offline browsing. 2018-08-14: [`first-n`](Funcons-beta/Values/Composite/Sequences/#Name_first-n) * rule corrected. 2018-07-17: [MiniJava](Languages-beta/MiniJava) * syntax disambiguation completed. * semantics tested with 65 unit tests. 2018-07-16: [Browsing guide](Browsing) * restructured. 2018-07-15: [Browsing guide](Browsing) * further clarifications. 2018-07-14: [Publications](Publications) * added. 2018-07-14: [Browsing guide](Browsing) * minor clarifications. 2018-07-12: [Languages-beta](Languages-beta) * [added an overview of funcon reuse](Languages-beta/Reuse). 2018-07-09: [OCaml Light](Languages-beta/OCaml-Light) * [added `expr ::= 'assert' expr`](Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/). * [added disambiguation rules for `'{' expr 'with' ... '}'`](Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-A-Disambiguation/). * [corrected the rule defining `implemented-vector`](Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/). ",
    "url": "/CBS-beta/docs/Changes.html",
    "relUrl": "/docs/Changes.html"
  },"2": {
    "doc": "Contributors",
    "title": "Contributors",
    "content": "CBS Contributors ================ If you would like to contribute to PLanCompS (e.g., by using CBS to define a new or existing language, or by suggesting new or improved funcons) please email . Current contributors -------------------- - [L. Thomas van Binsbergen] - [Peter D. Mosses] - [Neil Sculthorpe] Past contributors ------------------ See the [PLanCompS People] page for a list of PLanCompS participants during the research project funding period \\(2011-16\\), who contributed to the development of CBS, funcons, case studies, and the preliminary tool support. [L. Thomas van Binsbergen]: https://ltvanbinsbergen.nl [Peter D. Mosses]: https://pdmosses.github.io [Neil Sculthorpe]: http://neilsculthorpe.com [PLanCompS People]: http://plancomps.org/people ",
    "url": "/CBS-beta/docs/Contributors.html",
    "relUrl": "/docs/Contributors.html"
  },"3": {
    "doc": "Downloads",
    "title": "Downloads",
    "content": "Downloads ========= Clone or download a zip of the current [CBS-beta project site on Github]. Browsing CBS-beta offline ------------------------- 1. Requirements: [Ruby]\\: 2.6.5 (Ruby 2.7.0 works, but emits tedious warnings about deprecated code) [Jekyll]\\: 3.8.7 or 4.x ([jekyll-remote-theme] supports use of Jekyll 4 on GitHub Pages) 2. Run the following command in a terminal from the root directory of the project: ```bash bundle install bundle exec jekyll serve --no-watch --port 4000 --host localhost ``` - The `no-watch` option suppresses spurious error reports from `listen` about `directory is already being watched`, but also disables automatic building when page sources change. - The `port` and `host` options default to the values shown above. [Log](Log) 3. Open a web browser at `http://localhost:4000/CBS-beta/` (the final `/` is required) Stop the local server with Control-C when no longer needed. Color schemes ------------- {:.note} > When browsing these web pages on GitHub, the color scheme can be toggled > between a light and a dark scheme, independently of the system/browser preference. To make the color scheme for local browsing dependent on the system/browser preference, set `toggle_auto_mode: true` in `_config.yml` and restart `jekyll serve`. The colors used for CBS highlighting in the `light` and `dark` schemes can be adjusted by editing the SCSS files in `_sass/custom`. [Ruby]: https://www.ruby-lang.org/ [Jekyll]: https://help.github.com/en/articles/setting-up-your-github-pages-site-locally-with-jekyll ",
    "url": "/CBS-beta/docs/Downloads.html",
    "relUrl": "/docs/Downloads.html"
  },"4": {
    "doc": "Log",
    "title": "Log",
    "content": "# Log ## Bundle installation ``` CBS-beta: bundle update Fetching https://github.com/pdmosses/just-the-docs.git Fetching gem metadata from https://rubygems.org/.......... Fetching gem metadata from https://rubygems.org/. Resolving dependencies... Using rake 13.0.3 Using public_suffix 4.0.6 Using bundler 2.2.4 Using colorator 1.1.0 Using concurrent-ruby 1.1.8 Using eventmachine 1.2.7 Using http_parser.rb 0.6.0 Using ffi 1.15.0 Using forwardable-extended 2.6.0 Using rb-fsevent 0.10.4 Using rexml 3.2.5 Using liquid 4.0.3 Using mercenary 0.4.0 Using rouge 3.26.0 Using safe_yaml 1.0.5 Using unicode-display_width 1.7.0 Using rubyzip 2.3.0 Using addressable 2.7.0 Using em-websocket 0.5.2 Using i18n 1.8.10 Using sassc 2.4.0 Using rb-inotify 0.10.1 Using kramdown 2.3.1 Using pathutil 0.16.2 Using terminal-table 2.0.0 Using jekyll-sass-converter 2.1.0 Using listen 3.5.1 Using kramdown-parser-gfm 1.1.0 Using jekyll-watch 2.2.1 Using jekyll 4.2.0 Using jekyll-include-cache 0.2.1 Using jekyll-remote-theme 0.4.3 Using jekyll-seo-tag 2.7.1 Using just-the-docs 0.3.3 from https://github.com/pdmosses/just-the-docs.git (at combination-rec-nav@8054ea5) Bundle updated! ``` ## Jekyll server ``` CBS-beta: bundle exec jekyll serve --config _config.yml,_config_dev.yml --no-watch Configuration file: /Users/pdm/Projects/GitHub/CBS-beta/_config.yml Configuration file: /Users/pdm/Projects/GitHub/CBS-beta/_config_dev.yml Source: /Users/pdm/Projects/GitHub/CBS-beta Destination: /Users/pdm/Projects/GitHub/CBS-beta/_site Incremental build: disabled. Enable with --incremental Generating... Remote Theme: Using theme pdmosses/just-the-docs done in 47.563 seconds. Auto-regeneration: disabled. Use --watch to enable. Server address: http://127.0.0.1:4000/CBS-beta/ Server running... press ctrl-c to stop. ``` ",
    "url": "/CBS-beta/docs/Log.html",
    "relUrl": "/docs/Log.html"
  },"5": {
    "doc": "Notation",
    "title": "Notation",
    "content": "# CBS-beta Notation {: .no_toc } ## Contents {: .no_toc .text-delta } - TOC {:toc} ## Languages __See the [CBS of IMP] for illustration of the following points.__ - Each file of the definition of a language `L` starts with the line *`Language \"L\"`*. Splitting a language definition across multiple files (within the same project) does not affect its well-formedness. - Language definitions can be split into numbered sections. A section number is written `#n`, where `n` can be a series of numbers or (single) letters, separated by dots. Section numbers are hyperlinks in a table of contents, which is written `[...]`, and in multi-line comments `/*...*/`. - Multi-line comments are written `/*...*/`, and may include funcon terms (delimited by back-ticks `` ` ``). End-of-line comments are written `//...`. > __Multi-line comments are displayed as running text in generated web pages, > without the enclosing `/*...*/`.__ ### Syntax *`Syntax`* introduces one or more grammar productions for the abstract (context-free) syntax of the language, together with meta-variables ranging over the associated sorts of ASTs. - Nonterminals start with lowercase letters, and may include letters, digits, and dashes `-`. - The start symbol of the grammar is named `start`. - Meta-variables start with uppercase letters, e.g., *`Pgm`*. - The left and right sides of productions are separated by `::=`. - Terminal symbols are enclosed in single quotes `'...'`. - Alternatives are separated by `|`. All alternatives for the same nonterminal have to be specified together. - Regular expressions are written using postfix `?` for optional parts, `*` for iteration, `+` for non-empty iteration, and grouping parentheses `(...)`. - Layout (including comments) is implicitly allowed everywhere in *`Syntax`*, but it can be excluded between two symbols by inserting an underscore `_`, e.g., [`num ::= '-'?_decimal`]. *`Lexis`* introduces one or more grammar productions for the lexical (regular or context-free) syntax of the language, together with meta-variables ranging over the specified *strings* of characters. - The range of characters from `'c1'` to `'c2'` is specified by `'c1'-'c2'`. For example, [`decimal`] is defined as `('0'-'9')+`. - Layout (including comments) is implicitly *excluded* everywhere in *`Lexis`*. - *`Lexis`* productions are otherwise specified as for *`Syntax`*. Parsers generated from grammars for abstract syntax are usually ambiguous. Associativity, relative priority, and lexical disambiguation are currently specified separately, using notation from SDF, embedded in multi-line comments `/*...*/`. ### Semantics *`Semantics`* introduces a declaration of a translation function from ASTs (with strings as leaves) to funcon terms. - A translation function takes a single AST (or string) as argument, enclosed in double brackets `[[...]]`. - The sort of the argument is specified by `_:...`. - The type of the resulting funcon term is specified after `:`. It is usually a computation type `=>t` for some value type `t`; it can also be a computation sequence type of the form `(=>t)*`. *`Rule`* introduces an equation defining the translation function on trees matching a specified pattern. - The pattern in a rule usually corresponds to a single alternative of the argument sort. - Meta-variables of the same sort in a rule are distinguished by subscripted digits, optionally followed by primes. - The notation `\\\"...\\\"` produces a funcon string value from a lexical symbol `...`. (In contrast, `\"...\"` is always a literal string, not containing references to meta-variables.) - Desugaring rules for ASTs are written `[[...]] : s = [[...]]`, where the patterns on both sides match the nonterminal symbol `s`. Note that desugaring rules do *not* refer to particular translation functions. All funcons (etc.) defined in [Funcons-beta] can be used in all language definitions. Funcons defined in a language definition file must have fresh names, and cannot be reused in other language definitions \\(except by copy-paste). ------------------ ## Funcons *Funcon names* start with lowercase letters, and may include letters, digits, and dashes `-`. *Variables* in funcon terms start with uppercase letters, and may be suffixed by digits and/or primes. Variables that stand for sequences of indefinite length are suffixed by `*`, `+`, or `?`. Variables whose values are not required may be replaced by underscores `_`. A funcon term formed from a funcon `f` and argument sequence `s` is written in prefix form: `f s`. When `f` has no arguments, it is written without parentheses: `f`; when it has 2 or more arguments `t1`, ..., `tn`, they are written in ordinary parentheses: `f(t1,...,tn)`. Parentheses are optional when there is a single argument term, so both `f t` and `f(t)` are allowed. - **N.B. Parentheses are also optional around composite argument terms: `f g t` is *always* grouped as `f(g(t))`!** Funcons are *not* higher-order, so implicit grouping of `f g t` as `(f g)(t)` would here be *completely useless*, as it would *never* give a well-formed term. Grouping in funcon terms treats funcon names as prefix operations, such as the '`-`' in '`-sin(x)`'. (Readers accustomed to higher-order programming in Haskell may find it helpful to imagine `f g t` written as `f$g t`.) Some funcons can take argument sequences of varying lengths; funcons may also compute sequences of values. An example of a funcon that does both is `left-to-right`, which is used to ensure that arguments are evaluated in the specified order (the default is to allow interleaving). Composition with `left-to-right` provides sequential variants of all multi-argument funcons, e.g.: - `integer-add left-to-right(t1,t2)` (which abbreviates `integer-add(left-to-right(t1,t2))`) The following special forms of funcon terms are allowed: - Natural numbers in decimal notation - Characters `'c'` (with the usual `\\`-escapes) - Strings `\"c1...cn\"` (with the usual `\\`-escapes) - Lists `[t1,...,tn]`, empty list `[ ]` - Sets `{t1,...,tn}`, empty set `{ }` - Maps `{k1|->t1,...,kn|->tn}`, empty map `map( )` - Type union `t1|...|tn` - Type intersection `t1&...&tn` - Type complement `~t` - Sequence types `t*`, `t+`, `t?`, `t^n` The funcon definitions in [Funcons-beta] are language-independent. CBS specifications do not refer to the hierarchy of folders and files used for [Funcons-beta]. Files in [Funcons-beta] are generally divided into *unnumbered* subsections. The number of `#` characters in a subsection heading indicates its level, with the top level sections [Computations] and [Values] having a single `#`. ### Type definitions In CBS, types are values. They can be given as arguments to funcons, and computed by funcons. *`Type`* introduces a declaration of a fresh funcon name for a type, and lists any arguments. The type of values it computes is `types`. - A type definition `Type t... ~> t1` combines a type declaration with a rewrite of the type to `t1`. - A type definition `Type t... t`. For example, the signature of [`fail`] is written `:=>empty-type`. - The signature of a funcon taking one or more arguments and computing values of type `t` is written `(v1:ct1,...,vn:ctn):=>t`, where each `vi` is a variable, and each `cti` is either a type of values `ti` or a computation type `=>ti`. (Computation types `=>ti` resemble the types of call-by-name parameters in Scala.) For example, the signature of [`if-true-else`] is `(_:booleans, _:=>T, _:=>T) : =>T`, where `T` is a type variable. - Arguments specified by `vi:ti` are implicitly pre-evaluated (possibly interleaved) whereas evaluation of arguments specified by `vi:=>ti` is determined by explicit rules. - One of the argument types in a signature may be an indefinite sequence type, formed using a suffixed `*`, `+`, or `?`, allowing use of the funcon with varying numbers of arguments. (A sequence argument is usually at the end, but could be anywhere, since the other arguments in an application determine where to match it.) - The lack of a defined result of a partial funcon is represented by the empty sequence `( )`. The result type in the signature of a partial funcon is of the form `t?` for some value type `t`. - The signature of a *value constructor* is written `(v1:ct1,...,vn:ctn):t`, using a value result type `t` instead of a computation result type `=>t`. *`Alias`* introduces an equation `n1 = n2` that declares a fresh name `n1` and defines it to be equivalent to another name `n2`. `n1` is usually an abbreviation for a longer `n2`; its declaration as an alias prevents it from being defined elsewhere to have a different interpretation. *`Built-in`* introduces a declaration of a fresh funcon name and its signature, but does not provide a definition for it. Built-ins can be regarded as parameters of a collection of funcon definitions. They are generally reserved for types of values such as integers, sets, and maps, which are not amenable to specification using operational rules. *`Auxiliary`* introduces a name that is not intended for direct use in language definitions. *`Rule`* introduces a formula or inference rule defining the operational behaviour of a funcon. - `t1 ~> t2` is a *rewrite* from `t1` to `t2`. - `t1 ---> t2` is simple *transition* from `t1` to `t2`. - `e(v) |- t1 ---> t2` specifies dependence on a *contextual entity* named `e`. - ` ---> ` specifies inspection of a *mutable entity* named `s` and its replacement of its value `v1` by `v2`. - `t1 --i?(v*)-> t2` specifies a sequence of values `v*` for an *input entity* named `i`. - `t1 --o!(v*)-> t2` specifies a sequence of values `v*` for an *output entity* named `o`. - `t1 --c(v?)-> t2` specifies an optional value`v?` for a *control entity* named `c`. - An annotated variable `v:t` is restricted to *value* terms; un-annotated variables range over *computation* terms (including value terms), except that type variables declared by *`Meta-variables`* are restricted to type terms. - A single defining rewrite rule for a funcon may be combined with its declaration. - Arguments of funcons in rules may be *patterns* formed from variables and *value constructors* (which are usually introduced by *`Datatype`* definitions). *`Assert`* introduces a formula that expresses the intention that it should hold (either as a consequence of specified definitions, or as a requirement for built-ins). ### Entities *`Entity`* introduces a declaration of a fresh auxiliary entity name. - Entities are implicitly propagated in transition rules when not mentioned. - Rewrites are independent of entities. - The declaration of an entity specifies how the entity is written when used, which determines how it is propagated when omitted in transition formulae. - `e(v:t) |- _ ---> _` declares a *contextual entity* `e` of type `t`, e.g., `environment(_:environments) |- _ ---> _`. When a contextual entity is omitted in a rule, it is implicitly the same in the conclusion and any premises. - ` ---> ` declares a *mutable entity* `s` of type `t`, e.g., ` ---> `. When a mutable entity is omitted in an *axiom*, it is implicitly propagated unchanged. When it is omitted in a rule with a single premise, its value before the transition in the premise is the same as before the transition in the conclusion, and similarly for its value after the transitions. Changes to mutable entities are threaded through sequences of transitions. - `_ --i?(v*:t*)-> _` declares an *input entity* `i` of type `t*`, e.g., `_ -- standard-in?(_:values*) -> _`. When an input entity is omitted in an *axiom*, it is implicitly required to be the empty sequence. When it is omitted in a rule with a single premise, the sequence of values in the conclusion is implicitly the same as in the premise. The value sequences of an input entity are concatenated in sequences of transitions. - `_ --o?(v*:t*)-> _` declares an *output entity* `o` of type `t*`, e.g., `_ -- standard-out!(_:values*) -> _`. When an output entity is omitted in a rule, the implicit requirements are analogous to those for input entities. - `_ --c(v?:t?)-> _` declares a *control entity* `c` of type `t?`, e.g., `_ --abrupted(_:values?)-> _`. When a control entity is omitted in a rule, the implicit requirements are analogous to those for input entities, except that a transition with a non-empty control entity value cannot be followed by a further transition (before being handled). [Browsing Guide]: Browsing [Publications]: Publications [Changes]: Changes [Downloads]: Downloads [Funcons-beta]: Funcons-beta [Unstable-Funcons-beta]: Unstable-Funcons-beta [Funcons-Index]: Funcons-beta/Funcons-Index [Unstable-Funcons-Index]: Unstable-Funcons-beta/Unstable-Funcons-Index [Funcon Reuse]: Languages-beta/Reuse [Languages-beta]: Languages-beta [Unstable-Languages-beta]: Unstable-Languages-beta [CBS-beta]: /CBS-beta [PLanCompS Project]: http://plancomps.org [CBS-beta issues...]: https://github.com/plancomps/plancomps.github.io/issues [Suggest an improvement...]: mailto:plancomps@gmail.com [CBS of IMP]: Languages-beta/IMP/IMP-cbs/IMP/IMP-Start [Values]: Funcons-beta/Values [Computations]: Funcons-beta/Computations [`num ::= '-'?_decimal`]: Languages-beta/IMP/IMP-cbs/IMP/IMP-1/#SyntaxName_num [`decimal`]: Languages-beta/IMP/IMP-cbs/IMP/IMP-1/#SyntaxName_decimal [`fail`]: Funcons-beta/Computations/Abnormal/Failing/#Name_fail [`if-true-else`]: Funcons-beta/Computations/Normal/Flowing/#Name_if-true-else ",
    "url": "/CBS-beta/docs/Notation.html",
    "relUrl": "/docs/Notation.html"
  },"6": {
    "doc": "PDF",
    "title": "PDF",
    "content": "# PDF The PDFs display CBS with mathematical typography rendered using LaTeX and the [CBS-LaTeX] macro package. Names are highlighted, and name references are hyperlinked to declarations. [Pretty] web pages corresponding closely to the PDFs are generated from the same [sources] using the [CBS-KaTeX] macro package and rendered using [KaTeX]. {:.note} > On macOS (Catalina), the [Preview app does not support hyperlinks to specific targets] in PDF pages; > similarly when browsing PDFs in Safari. > Acrobat (Reader) and Firefox support hyperlinks in PDFs just as in web pages. [Pretty]: Pretty [KaTeX]: https://katex.org [sources]: https://github.com/plancomps/CBS-beta/tree/math/_math [CBS-LaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-latex.sty [CBS-KaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-katex.html [Preview app does not support hyperlinks to specific targets]: https://discussions.apple.com/thread/251041261 ",
    "url": "/CBS-beta/docs/PDF.html",
    "relUrl": "/docs/PDF.html"
  },"7": {
    "doc": "Plain",
    "title": "Plain",
    "content": "# Plain These web pages display CBS verbatim. Names are highlighted, and name references are hyperlinked to declarations. Links to related pages support navigation between specifications. [PDFs]: PDF [KaTeX]: https://katex.org [sources]: https://github.com/plancomps/CBS-beta/tree/math/_math [CBS-LaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-latex.sty [CBS-KaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-katex.html ",
    "url": "/CBS-beta/docs/Plain.html",
    "relUrl": "/docs/Plain.html"
  },"8": {
    "doc": "Pretty",
    "title": "Pretty",
    "content": "# Pretty These web pages display CBS with mathematical typography rendered using [KaTeX] and the [CBS-KaTeX] macro package. Names are highlighted, and name references are hyperlinked to declarations. Links to related pages support navigation between specifications. [PDFs] corresponding closely to the Pretty web pages are generated from the same [sources] using the [CBS-LaTeX] macro package. [PDFs]: PDF [KaTeX]: https://katex.org [sources]: https://github.com/plancomps/CBS-beta/tree/math/_math [CBS-LaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-latex.sty [CBS-KaTeX]: https://github.com/plancomps/CBS-beta/blob/math/_includes/cbs-katex.html ",
    "url": "/CBS-beta/docs/Pretty.html",
    "relUrl": "/docs/Pretty.html"
  },"9": {
    "doc": "Publications",
    "title": "Publications",
    "content": "Publications ============ The PLanComps approach to component-based specification of programming languages is based on the ideas and foundations explained in the publications listed below. *Note:* The notation and funcons presented in previous publications vary considerably; future publications should be consistent with the final release of CBS. - P. D. Mosses, __A component-based formal language workbench__, in: *Proceedings F-IDE 2019*, EPTCS 310, 2019, pp. 29-34 [doi:10.4204/EPTCS.310.4](https://doi.org/10.4204/EPTCS.310.4) - P. D. Mosses, __Software meta-language engineering and CBS__, *Journal of Computer Languages* 50 (2019) pp. 39–48. [doi:10.1016/j.jvlc.2018.11.003](https://doi.org/10.1016/j.jvlc.2018.11.003) - L. T. van Binsbergen, N. Sculthorpe, P. D. Mosses, __Executable component-based semantics__, *J. Log. Algebr. Methods Program.* 103 (2019) pp. 184–212. [doi:10.1016/j.jlamp.2018.12.004](https://doi.org/10.1016/j.jlamp.2018.12.004) - L. T. van Binsbergen, N. Sculthorpe, P. D. Mosses, __[Tool support for component-based semantics](http://plancomps.org/modularity2016)__, in: *Companion Proceedings of the 15th International Conference on Modularity,* ACM, 2016, pp. 8-11. [doi:10.1145/2892664.2893464](http://dx.doi.org/10.1145/2892664.2893464) - N. Sculthorpe, P. Torrini, P. D. Mosses, __[A modular structural operational semantics for delimited continuations](http://plancomps.org/WoC2016)__, in: *Post-proceedings of the 2015 Workshop on Continuations,* Vol. 212 of EPTCS, Open Publishing Association, 2016, pp. 63–80. [doi:10.4204/EPTCS.212.5](https://doi.org/10.4204/EPTCS.212.5) - M. Churchill, P. D. Mosses, N. Sculthorpe, P. Torrini, __[Reusable components of semantic specifications](http://plancomps.org/taosd2015)__, in: *Transactions on Aspect-Oriented Software Development XII,* Vol. 8989 of LNCS, Springer, 2015, pp. 132–179. [doi:10.1007/978-3-662-46734-3_4](https://doi.org/10.1007/978-3-662-46734-3_4) - P. D. Mosses, F. Vesely, __Weak bisimulation as a congruence in MSOS__, in: *Logic, Rewriting, and Concurrency,* Vol. 9200 of LNCS, Springer, 2015, pp. 519–538. [doi:10.1007/978-3-319-23165-5_ 24](https://doi.org/10.1007/978-3-319-23165-5_24) - P. D. Mosses, F. Vesely, __[FunKons: Component-based semantics in K](http://plancomps.org/funkons-component-based-semantics-in-k)__, in: *10th International Workshop on Rewriting Logic and Its Applications,* Vol. 8663 of LNCS, Springer, 2014, pp. 213–229. [doi:10.1007/978-3-319-12904-4_12](https://doi.org/10.1007/978-3-319-12904-4_12) - M. Churchill, P. D. Mosses, __[Modular bisimulation theory for computations and values](http://plancomps.org/churchill2013a)__, in: *16th International Conference on Foundations of Software Science and Computation Structures,* Vol. 7794 of LNCS, Springer, 2013, pp. 97–112. [doi:10.1007/ 978-3-642-37075-5_7](https://doi.org/10.1007/978-3-642-37075-5_7) - A. Johnstone, P. D. Mosses, E. Scott, __An agile approach to language modelling and development,__ *Innovations Syst. Softw. Eng.* 6 (2010) pp. 145–153. [doi:10.1007/s11334-009-0111-6](https://doi.org/10.1007/s11334-009-0111-6) - P. D. Mosses, __Component-based semantics__, in: *Proceedings of the 8th international Workshop on Specification and Verification of Component-Based Systems,* ACM, 2009, pp. 3-10. [doi:10.1145/1596486.1596489](https://doi.org/10.1145/1596486.1596489) - P. D. Mosses, M. J. New, __Implicit propagation in structural operational semantics__, *Electr. Notes Theor. Comput. Sci.* 229 (2009) pp. 49-66. [doi:10.1016/j.entcs.2009.07.073](https://doi.org/10.1016/j.entcs.2009.07.073) - P. D. Mosses, __Modular language descriptions__, in: *Third International Conference on Generative Programming and Component Engineering,* Vol. 3286 of LNCS, Springer, 2004, p. 489. [doi:10.1007/978-3-540-30175-2_27](https://doi.org/10.1007/978-3-540-30175-2_27) - P. D. Mosses, __Modular structural operational semantics__, *J. Log. Algebr. Program.* 60-61 (2004) pp. 195-228. [doi:10.1016/j.jlap.2004.03.008](https://doi.org/10.1016/j.jlap.2004.03.008) ",
    "url": "/CBS-beta/docs/Publications.html",
    "relUrl": "/docs/Publications.html"
  },"10": {
    "doc": "Sources",
    "title": "Sources",
    "content": "# Sources The CBS source files are text files on GitHub. They can be browsed online, or downloaded from the [CBS-beta repository] for local browsing. GitHub displays the text with line numbers (useful when reporting issues or suggesting improvements) but no highlighting or hyperlinks. Navigation to related source files requires familiarity with the folder hierarchy. A CBS workbench, implemented in [Spoofax], parses and checks the CBS source files. It then generates Markdown and LaTeX files from them; [kramdown] and pdflatex produce the [PDFs]. and the [plain] and [pretty] web pages. Currently, the source files enclose all informal text in `/*...*/`. They could easily be converted to pure Markdown files, by removing the `/*` and `*/` and enclosing the formal CBS specifications in back-ticks. [CBS-beta repository]: https://github.com/plancomps/CBS-beta [kramdown]: https://kramdown.gettalong.org [Spoofax]: https://www.metaborg.org [PDFs]: PDF [Plain]: Plain [Pretty]: Pretty ",
    "url": "/CBS-beta/docs/Sources.html",
    "relUrl": "/docs/Sources.html"
  },"11": {
    "doc": "Unstable-Funcons-beta",
    "title": "Unstable-Funcons-beta",
    "content": "# Unstable-Funcons-beta {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Unstable-Funcons-beta [Plain]: ../docs/Unstable-Funcons-beta [Pretty]: ../math/Unstable-Funcons-beta ",
    "url": "/CBS-beta/Unstable-Funcons-beta/",
    "relUrl": "/Unstable-Funcons-beta/"
  },"12": {
    "doc": "Languages-beta",
    "title": "Languages-beta",
    "content": "# Languages-beta {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Languages-beta [Plain]: ../docs/Languages-beta [Pretty]: ../math/Languages-beta ",
    "url": "/CBS-beta/Languages-beta/",
    "relUrl": "/Languages-beta/"
  },"13": {
    "doc": "Funcons-beta",
    "title": "Funcons-beta",
    "content": "# Funcons-beta {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Funcons-beta [Plain]: ../docs/Funcons-beta [Pretty]: ../math/Funcons-beta ",
    "url": "/CBS-beta/Funcons-beta/",
    "relUrl": "/Funcons-beta/"
  },"14": {
    "doc": "LangDev-2019",
    "title": "LangDev-2019",
    "content": "# LangDev-2019 {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Unstable-Languages-beta/LangDev-2019 [Plain]: ../../docs/Unstable-Languages-beta/LangDev-2019 [Pretty]: ../../math/Unstable-Languages-beta/LangDev-2019 ",
    "url": "/CBS-beta/Unstable-Languages-beta/LangDev-2019/",
    "relUrl": "/Unstable-Languages-beta/LangDev-2019/"
  },"15": {
    "doc": "Funcons-Index",
    "title": "Funcons-Index",
    "content": "# Funcons-Index {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Funcons-beta/Funcons-Index [Plain]: ../../docs/Funcons-beta/Funcons-Index [Pretty]: ../../math/Funcons-beta/Funcons-Index ",
    "url": "/CBS-beta/Funcons-beta/Funcons-Index/",
    "relUrl": "/Funcons-beta/Funcons-Index/"
  },"16": {
    "doc": "CBS-beta",
    "title": "CBS-beta",
    "content": "CBS-beta ======== > {:.note} > > You can toggle the color scheme between light and dark using the button > > (&#x263c; &#x263d;) at the top of the navigation menu. _CBS_ is a framework and meta-language for _component-based specification of programming languages_. The main idea is to translate languages to so-called _'funcons'_ ([fundamental programming constructs]). The behaviour of the funcons has already been specified, so translating a language to funcons determines the behaviour of programs in that language. > Specifications of translations to funcons can be significantly _simpler_ -- both > to read and to write -- than direct specifications of program behaviour. In fact CBS aims to make specification of language behaviour as easy as specification of context-free syntax! Specifications of translations to funcons are also _highly modular_, to support co-evolution of languages and their specifications. > Funcons are _reusable_ components: the same funcon can be used, unchanged, in > the specifications of many different languages. Funcons correspond closely to concepts of high-level programming languages such as data and control flow, scopes of bindings, mutable variables, streams, abrupt termination, procedural abstraction, etc. Funcon names are strongly suggestive of the corresponding concepts. The [PLanCompS] project has developed an initial collection of funcons. > Crucially, adding new funcons does not require any changes to > the specifications of existing funcons, thanks to the use of a > modular variant of structural operational semantics (MSOS). Current tool support for CBS (not yet released) includes an IDE for CBS with syntax highlighting, hyperlinks from references to declarations, and generation of parsers, translators, and interpreters from specifications of languages and funcons. Using these tools, programs can be executed according to their specified behaviour, allowing rapid prototyping and empirical validation of language design. Beta-release ------------ The funcons provided by the PLanCompS project are to have *fixed* definitions, so *no version control* will be needed for their safe reuse in CBS language specifications. The aim of this beta-release of CBS and its initial library of funcons is to allow review of the current definitions, and subsequent adoption of suggestions for improvement, before their full release. **The beta-release review period has been extended.** The funcon definitions in [Funcons-beta] have been validated by empirical testing of generated interpreters for various programming languages, including those provided in [Languages-beta]. Individual funcon definitions have also been unit-tested. Further testing during the beta-release review period may however reveal issues that require changes to definitions; lack of expected algebraic properties of funcons might also motivate some adjustments. Language specifications that use the affected funcons may then need to be updated to take account of the changes. The current names of funcons have been chosen to be suggestive, but proposals for improvements are welcome. The tension between conciseness and suggestiveness has been addressed by defining short aliases for longer names. Bias towards keywords used in particular language families has been avoided. Many funcons are directly related to fundamental concepts of programming languages, and their names try to reflect current terminology. Unstable funcons and languages ------------------------------ New funcons are likely to be introduced in the beta-release period, and further examples of language definitions will be provided. Compared to the funcons in [Funcons-beta] and the languages specified in [Languages-beta], the new specifications may be less well tested, and relatively unstable, so they are listed separately: - [Unstable-Funcons-beta] specifies new funcons - [Unstable-Languages-beta] specifies languages that use the new funcons Currently, [Unstable-Funcons-beta] provides funcons for *threads*, and [Unstable-Languages-beta] specifies simple multi-threaded extensions of a couple of the languages specified in [Languages-beta]. Demonstration of scaling-up to major languages (e.g., C#) is a longer-term goal. Moreover, the current funcon definitions cover only their dynamic semantics, but are to be extended to static semantics. All additions and changes are listed in the [beta-release change log], as well as in the version history of this project site. Tool support ------------ Tool support for using CBS will be released as soon as it is sufficiently robust and well-documented. The CBS editor has been implemented as a [Spoofax] language project in Eclipse; generation of interpreters from funcon definitions has been implemented as a Haskell package [Funcon.Tools]. The CBS beta-release review period will remain open until the full toolchain has been released. PLanCompS: Programming Language Components and Specifications ---------- CBS has been developed by the [PLanCompS] project. From 2011 to 2016, the research was funded by EPSRC in the UK. The PLanCompS project is now continuing as an open international collaboration, and welcomes new [contributors]. If you would like to contribute to PLanCompS (e.g., by using CBS to define a new or existing language, or by suggesting new or improved funcons) please email plancomps@gmail.com. [Fundamental programming constructs]: /CBS-beta/docs/Funcons-beta [Funcons-beta]: /CBS-beta/docs/Funcons-beta [Languages-beta]: /CBS-beta/docs/Languages-beta [Unstable-Funcons-beta]: /CBS-beta/docs/Unstable-Funcons-beta [Unstable-Languages-beta]: /CBS-beta/docs/Unstable-Languages-beta [Beta-release change log]: /CBS-beta/docs/Changes [Spoofax]: http://www.metaborg.org [Funcon.Tools]: https://hackage.haskell.org/package/funcons-tools/docs/Funcons-Tools.html [PLanCompS]: http://plancomps.org [Contributors]: /CBS-beta/docs/Contributors ",
    "url": "/CBS-beta/",
    "relUrl": "/"
  },"17": {
    "doc": "Unstable-Languages-beta",
    "title": "Unstable-Languages-beta",
    "content": "# Unstable-Languages-beta {% include navigation.md %} [Sources]: https://github.com/plancomps/CBS-beta/tree/math/Unstable-Languages-beta [Plain]: ../docs/Unstable-Languages-beta [Pretty]: ../math/Unstable-Languages-beta ",
    "url": "/CBS-beta/Unstable-Languages-beta/",
    "relUrl": "/Unstable-Languages-beta/"
  },"18": {
    "doc": "LangDev-2019 declaration not found",
    "title": "LangDev-2019 declaration not found",
    "content": "# LangDev-2019 declaration not found A URL of the form `.../CBS-beta/Unstable-Languages-beta/LangDev-2019#id` should redirect to a web page that displays the declaration of the name indicated by `id`. For example, [...CBS-beta/Unstable-Languages-beta#SyntaxName:exp](/CBS-beta/Unstable-Languages-beta/LangDev-2019#SyntaxName:exp) redirects to [...CBS-beta/math/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/#SyntaxName:exp](/CBS-beta/math/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/#SyntaxName:exp). Redirection to the present page indicates that the name indicated by `id` is not declared in the Unstable-Languages-beta/LangDev-2019 specification. This could be due to the omission of a `SyntaxName:` or `SemanticsName:` prefix, or a spelling error in the name itself. ",
    "url": "/CBS-beta/Unstable-Languages-beta/LangDev-2019/LD-cbs/not_found.html",
    "relUrl": "/Unstable-Languages-beta/LangDev-2019/LD-cbs/not_found.html"
  },"19": {
    "doc": "Funcons-beta declaration not found",
    "title": "Funcons-beta declaration not found",
    "content": "# Funcons-beta declaration not found A URL of the form `.../CBS-beta/Funcons-beta#id` should redirect to a web page that displays the declaration of the funcon indicated by `id`. For example, [...CBS-beta/Funcons-beta#Name:scope](/CBS-beta/Funcons-beta#Name:scope) redirects to [...CBS-beta/math/Funcons-beta/Computations/Normal/Binding/#Name:scope](/CBS-beta/math/Funcons-beta/Computations/Normal/Binding/#Name:scope). Redirection to the present page indicates that the funcon indicated by `id` is not declared in the Funcons-beta collection. This could be due to the omission of the `Name:` prefix, or a spelling error. ",
    "url": "/CBS-beta/Funcons-beta/not_found.html",
    "relUrl": "/Funcons-beta/not_found.html"
  },"20": {
    "doc": "Abrupting",
    "title": "Abruptly terminating",
    "content": "[ Funcon stuck Entity abrupted Funcon finalise-abrupting Funcon abrupt Funcon handle-abrupt Funcon finally ] . Meta-variables T, T&prime;, T&prime;&prime; &lt;: values . Funcon stuck : =&gt;empty-type . stuck does not have any computation. It is used to represent the result of a transition that causes the computation to terminate abruptly. Entity _ --abrupted(_:values?)-&gt; _ . abrupted(V) in a label on a tranistion indicates abrupt termination for reason V. abrupted( ) indicates the absence of abrupt termination. Funcon finalise-abrupting(X:=&gt;T) : =&gt;T|null-type ~&gt; handle-abrupt(X, null-value) . finalise-abrupting(X) handles abrupt termination of X for any reason. Funcon abrupt(_:values) :=&gt;empty-type . abrupt(V) terminates abruptly for reason V. Rule abrupt(V:values) --abrupted(V)-&gt; stuck . Funcon handle-abrupt(_:T&prime;=&gt;T, _:T&prime;&prime;=&gt;T) : T&prime;=&gt;T . handle-abrupt(X, Y) first evaluates X. If X terminates normally with value V, then V is returned and Y is ignored. If X terminates abruptly for reason V, then Y is executed with V as given value. handle-abrupt(X, Y) is associative, with abrupt(given) as left and right unit. handle-abrupt(X, else(Y, abrupt(given))) ensures propagation of abrupt termination for the given reason if Y fails . Rule X --abrupted( )-&gt; X&prime; -------------------------------------------------------- handle-abrupt(X, Y) --abrupted( )-&gt; handle-abrupt(X&prime;, Y) Rule X --abrupted(V:T&prime;&prime;)-&gt; X&prime; ---------------------------------------------- handle-abrupt(X, Y) --abrupted( )-&gt; give(V, Y) Rule handle-abrupt(V:T, Y) ~&gt; V . Funcon finally(_:=&gt;T, _:=&gt;null-type) : =&gt;T . finally(X, Y) first executes X. If X terminates normally with value V, then Y is executed before terminating normally with value V. If X terminates abruptly for reason V, then Y is executed before terminating abruptly with the same reason V. Rule X --abrupted( )-&gt; X&prime; -------------------------------------------- finally(X, Y) --abrupted( )-&gt; finally(X&prime;, Y) Rule X --abrupted(V:values)-&gt; X&prime; ----------------------------------------------------- finally(X, Y) --abrupted()-&gt; sequential(Y, abrupt(V)) Rule finally(V:T, Y) ~&gt; sequential(Y,V) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Abrupting/index.html#abruptly-terminating",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Abrupting/index.html#abruptly-terminating"
  },"21": {
    "doc": "Abrupting",
    "title": "Abrupting",
    "content": "Funcons-beta : Abrupting.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Abrupting/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Abrupting/index.html"
  },"22": {
    "doc": "Breaking",
    "title": "Breaking",
    "content": "[ Datatype breaking Funcon broken Funcon finalise-breaking Funcon break Funcon handle-break ] . Meta-variables T &lt;: values . Datatype breaking ::= broken . broken is a reason for abrupt termination. Funcon finalise-breaking(X:=&gt;T) : =&gt;T|null-type ~&gt; finalise-abrupting(X) . finalise-breaking(X) handles abrupt termination of X due to executing break. Funcon break : =&gt;empty-type ~&gt; abrupt(broken) . break abruptly terminates all enclosing computations until it is handled. Funcon handle-break(_:=&gt;null-type) : =&gt;null-type . handle-break(X) terminates normally when X terminates abruptly for the reason broken. Rule X --abrupted( )-&gt; X&prime; ------------------------------------------------ handle-break(X) --abrupted( )-&gt; handle-break(X&prime;) Rule X --abrupted(broken)-&gt; _ --------------------------------------- handle-break(X) --abrupted( )-&gt; null-value Rule X --abrupted(V:~breaking)-&gt; X&prime; ------------------------------------------------ handle-break(X) --abrupted(V)-&gt; handle-break(X&prime;) Rule handle-break(null-value) ~&gt; null-value . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Breaking/index.html#breaking",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Breaking/index.html#breaking"
  },"23": {
    "doc": "Breaking",
    "title": "Breaking",
    "content": "Funcons-beta : Breaking.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Breaking/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Breaking/index.html"
  },"24": {
    "doc": "Continuing",
    "title": "Continuing",
    "content": "[ Datatype continuing Funcon continued Funcon finalise-continuing Funcon continue Funcon handle-continue ] . Meta-variables T &lt;: values . Datatype continuing ::= continued . continued is a reason for abrupt termination. Funcon finalise-continuing(X:=&gt;T) : =&gt;T|null-type ~&gt; finalise-abrupting(X) . finalise-continuing(X) handles abrupt termination of X due to executing continue. Funcon continue : =&gt;empty-type ~&gt; abrupt(continued) . continue abruptly terminates all enclosing computations until it is handled. Funcon handle-continue(_:=&gt;null-type) : =&gt;null-type . handle-continue(X) terminates normally when X terminates abruptly for the reason continued. Rule X --abrupted( )-&gt; X&prime; ------------------------------------------------------ handle-continue(X) --abrupted( )-&gt; handle-continue(X&prime;) Rule X --abrupted(continued)-&gt; _ -------------------------------------------- handle-continue(X) --abrupted( )-&gt; null-value Rule X --abrupted(V:~continuing)-&gt; X&prime; ------------------------------------------------------ handle-continue(X) --abrupted(V)-&gt; handle-continue(X&prime;) Rule handle-continue(null-value) ~&gt; null-value . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Continuing/index.html#continuing",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Continuing/index.html#continuing"
  },"25": {
    "doc": "Continuing",
    "title": "Continuing",
    "content": "Funcons-beta : Continuing.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Continuing/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Continuing/index.html"
  },"26": {
    "doc": "Controlling",
    "title": "Controlling",
    "content": "[ Datatype continuations Funcon continuation Entity plug-signal Funcon hole Funcon resume-continuation Entity control-signal Funcon control Funcon delimit-current-continuation Alias delimit-cc ] . Meta-variables T, T1, T2 &lt;: values . Datatype continuations(T1,T2) ::= continuation(_:abstractions(()=&gt;T2)) . continuations(T1, T2) consists of abstractions whose bodies contain a hole, and which will normally compute a value of type T2 when the hole is plugged with a value of type T1. Entity _ --plug-signal(V?:values?)-&gt; _ . A plug-signal contains the value to be filled into a hole in a continuation, thereby allowing a continuation to resume. Funcon hole : =&gt;values . A hole in a term cannot proceed until it receives a plug-signal containing a value to plug the hole. Rule hole --plug-signal(V)-&gt; V . Funcon resume-continuation(K:continuations(T1, T2), V:T1) : =&gt;T2 . resume-continuation(K, V) resumes a continuation K by plugging the value V into the hole in the continuation. Rule X --plug-signal(V)-&gt; X&prime; --------------------------------------------------------------------------- resume-continuation(continuation(abstraction(X)), V:T) --plug-signal()-&gt; X&prime; . Entity _ --control-signal(F?:(functions(continuations(T1, T2), T2))?)-&gt; _ . A control-signal contains the function to which control is about to be passed by the enclosing delimit-current-continuation(X). Funcon control(F:functions(continuations(T1, T2), T2)) : =&gt;T1 . control(F) emits a control-signal that, when handled by an enclosing delimit-current-continuation(X), will apply F to the current continuation of control(F), (rather than proceeding with that current continuation). Rule control(F:functions(_,_)) --control-signal(F)-&gt; hole . Funcon delimit-current-continuation(X:=&gt;T) : =&gt;T Alias delimit-cc = delimit-current-continuation . delimit-current-continuation(X) delimits the scope of captured continuations. Rule delimit-current-continuation(V:T) ~&gt; V Rule X --control-signal( )-&gt; X&prime; ----------------------------------------------------- delimit-current-continuation(X) --control-signal( )-&gt; delimit-current-continuation(X&prime;) Rule X --control-signal(F)-&gt; X&prime; ------------------------------------------------------------------ delimit-current-continuation(X) --control-signal( )-&gt; delimit-current-continuation(apply(F, continuation closure(X&prime;))) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Controlling/index.html#controlling",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Controlling/index.html#controlling"
  },"27": {
    "doc": "Controlling",
    "title": "Controlling",
    "content": "Funcons-beta : Controlling.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Controlling/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Controlling/index.html"
  },"28": {
    "doc": "Failing",
    "title": "Failing",
    "content": "[ Datatype failing Funcon failed Funcon finalise-failing Funcon fail Funcon else Funcon else-choice Funcon checked Funcon check-true ] . Meta-variables T &lt;: values . Datatype failing ::= failed . failed is a reason for abrupt termination. Funcon finalise-failing(X:=&gt;T) : =&gt;T|null-type ~&gt; finalise-abrupting(X) . finalise-failing(X) handles abrupt termination of X due to executing fail. Funcon fail : =&gt;empty-type ~&gt; abrupt(failed) . fail abruptly terminates all enclosing computations until it is handled. Funcon else(_:=&gt;T, _:(=&gt;T)+) : =&gt;T . else(X1, X2, ...) executes the arguments in turn until either some Xi does not fail, or all arguments Xi have been executed. The last argument executed determines the result. else(X, Y) is associative, with unit fail. Rule X --abrupted( )-&gt; X&prime; -------------------------------------- else(X, Y) --abrupted( )-&gt; else(X&prime;, Y) Rule X --abrupted(failed)-&gt; _ --------------------------------- else(X, Y) --abrupted( )-&gt; Y Rule X --abrupted(V:~failing)-&gt; X&prime; -------------------------------------- else(X, Y) --abrupted(V)-&gt; else(X&prime;, Y) Rule else(V:T, Y) ~&gt; V Rule else(X, Y, Z+) ~&gt; else(X, else(Y, Z+)) . Funcon else-choice(_:(=&gt;T)+) : =&gt;T . else-choice(X,...) executes the arguments in any order until either some Xi does not fail, or all arguments Xi have been executed. The last argument executed determines the result. else(X, Y) is associative and commutative, with unit fail. Rule else-choice(W*, X, Y, Z*) ~&gt; choice(else(X, else-choice(W*, Y, Z*), else(Y, else-choice(W*, X, Z*)))) Rule else-choice(X) ~&gt; X . Funcon check-true(_:booleans) : =&gt;null-type Alias check = check-true . check-true(X) terminates normally if the value computed by X is true, and fails if it is false. Rule check-true(true) ~&gt; null-value Rule check-true(false) ~&gt; fail . Funcon checked(_:(T)?) : =&gt;T . checked(X) fails when X gives the empty sequence of values ( ), representing that an optional value has not been computed. It otherwise computes the same as X. Rule checked(V:T) ~&gt; V Rule checked( ) ~&gt; fail . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Failing/index.html#failing",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Failing/index.html#failing"
  },"29": {
    "doc": "Failing",
    "title": "Failing",
    "content": "Funcons-beta : Failing.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Failing/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Failing/index.html"
  },"30": {
    "doc": "Returning",
    "title": "Returning",
    "content": "[ Datatype returning Funcon returned Funcon finalise-returning Funcon return Funcon handle-return ] . Meta-variables T &lt;: values . Datatype returning ::= returned(_:values) . returned(V?) is a reason for abrupt termination. Funcon finalise-returning(X:=&gt;T) : =&gt;T|null-type ~&gt; finalise-abrupting(X) . finalise-returning(X) handles abrupt termination of X due to executing return(V). Funcon return(V:T) : =&gt;empty-type ~&gt; abrupt(returned(V)) . return(V) abruptly terminates all enclosing computations until it is handled, then giving V. Note that V may be null-value. Funcon handle-return(_:=&gt;T) : =&gt;T . handle-return(X) first evaluates X. If X either terminates abruptly for reason returned(V), or terminates normally with value V, it gives V. Rule X --abrupted( )-&gt; X&prime; -------------------------------------------------- handle-return(X) --abrupted( )-&gt; handle-return(X&prime;) Rule X --abrupted(returned(V:values))-&gt; X&prime; ---------------------------------------------- handle-return(X) --abrupted( )-&gt; V Rule X --abrupted(V&prime;:~returning)-&gt; X&prime; --------------------------------------------------- handle-return(X) --abrupted(V&prime;)-&gt; handle-return(X&prime;) Rule handle-return(V:T) ~&gt; V . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Returning/index.html#returning",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Returning/index.html#returning"
  },"31": {
    "doc": "Returning",
    "title": "Returning",
    "content": "Funcons-beta : Returning.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Returning/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Returning/index.html"
  },"32": {
    "doc": "Throwing",
    "title": "Throwing",
    "content": "[ Datatype throwing Funcon thrown Funcon finalise-throwing Funcon throw Funcon handle-thrown Funcon handle-recursively Funcon catch-else-throw ] . Meta-variables R, S, T, T&prime;, T&prime;&prime; &lt;: values . Datatype throwing ::= thrown(_:values) . thrown(V) is a reason for abrupt termination. Funcon finalise-throwing(X:=&gt;T) : =&gt;T|null-type ~&gt; finalise-abrupting(X) . finalise-throwing(X) handles abrupt termination of X due to executing throw(V). Funcon throw(V:T) : =&gt;empty-type ~&gt; abrupt(thrown(V)) . throw(V) abruptly terminates all enclosing computations uTil it is handled. Funcon handle-thrown(_:T&prime;=&gt;T, _:T&prime;&prime;=&gt;T) : T&prime;=&gt;T . handle-thrown(X, Y) first evaluates X. If X terminates normally with value V, then V is returned and Y is ignored. If X terminates abruptly with a thrown eTity having value V, then Y is executed with V as given value. handle-thrown(X, Y) is associative, with throw(given) as unit. handle-thrown(X, else(Y, throw(given))) ensures that if Y fails, the thrown value is re-thrown. Rule X --abrupted( )-&gt; X&prime; -------------------------------------------------------- handle-thrown(X, Y) --abrupted( )-&gt; handle-thrown(X&prime;, Y) Rule X --abrupted(thrown(V&prime;&prime;:values))-&gt; X&prime; ---------------------------------------------- handle-thrown(X, Y) --abrupted( )-&gt; give(V&prime;&prime;, Y) Rule X --abrupted(V&prime;:~throwing)-&gt; X&prime; --------------------------------------------------------- handle-thrown(X, Y) --abrupted(V&prime;)-&gt; handle-thrown(X&prime;, Y) Rule handle-thrown(V:T, Y) ~&gt; V . Funcon handle-recursively(X:S=&gt;T, Y:R=&gt;T) : S=&gt;T ~&gt; handle-thrown(X, else(handle-recursively(Y, Y), throw(given))) . handle-recursively(X, Y) behaves similarly to handle-thrown(X, Y), except that another copy of the handler attempts to handle any values thrown by Y. Thus, many thrown values may get handled by the same handler. Funcon catch-else-throw(P:values, Y:=&gt;T) : =&gt;T ~&gt; else(case-match(P, Y), throw(given)) . handle-thrown(X, catch-else-throw(P, Y)) handles those values thrown by X that match pattern P. Other thrown values are re-thrown. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Throwing/index.html#throwing",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Throwing/index.html#throwing"
  },"33": {
    "doc": "Throwing",
    "title": "Throwing",
    "content": "Funcons-beta : Throwing.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/Throwing/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/Throwing/index.html"
  },"34": {
    "doc": "Abnormal",
    "title": "Abnormal computations",
    "content": "Funcons for expressing abnormal computation may terminate normally or abnormally. Some of these funcons always cause abnormal termination; others may handle abnormal termination and resume normal flow of control. When a computation terminates abnormally, it generally signals a value, which can be inspected by enclosing handlers. Failure is a particular kind of abnormal termination that does not signal a value, and has special handlers. The CBS library includes funcons corresponding to the following concepts: . Abrupting terminating computations abruptly, and handling abrupt termination Failing abrupt termination for an unspecified reason Throwing abrupt termination for a specified reason Returning abrupt termination giving a computed value Breaking abrupt termination in connection with flow of control Continuing abrupt termination in connection with flow of control Controlling creating and using delimited continuations ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/index.html#abnormal-computations",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/index.html#abnormal-computations"
  },"35": {
    "doc": "Abnormal",
    "title": "Abnormal",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Abnormal/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Abnormal/index.html"
  },"36": {
    "doc": "Computation-Types",
    "title": "Computation Types",
    "content": "Built-in Funcon computation-types : types . For any value type T, the term =&gt;T is the type of computations that compute values of type T whenever they terminate normally. For any subtypes S, T of values, S=&gt;T is the type of computations that compute values of type T whenever they terminate normally, and either do not refer at all to the given entity, or require the given entity to have type S. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Computation-Types/index.html#computation-types",
    "relUrl": "/docs/Funcons-beta/Computations/Computation-Types/index.html#computation-types"
  },"37": {
    "doc": "Computation-Types",
    "title": "Computation-Types",
    "content": "Funcons-beta : Computation-Types.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Computation-Types/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Computation-Types/index.html"
  },"38": {
    "doc": "Binding",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon identifier-tagged Alias id-tagged Funcon fresh-identifier Entity environment Alias env Funcon initialise-binding Funcon bind-value Alias bind Funcon unbind Funcon bound-directly Funcon bound-value Alias bound Funcon closed Funcon scope Funcon accumulate Funcon collateral Funcon bind-recursively Funcon recursive ] . Meta-variables T &lt;: values . Environments . Type environments ~&gt; maps(identifiers, values?) Alias envs = environments . An environment represents bindings of identifiers to values. Mapping an identifier to ( ) represents that its binding is hidden. Circularity in environments (due to recursive bindings) is represented using bindings to cut-points called links. Funcons are provided for making declarations recursive and for referring to bound values without explicit mention of links, so their existence can generally be ignored. Datatype identifiers ::= {_:strings} | identifier-tagged(_:identifiers, _:values) Alias ids = identifiers . Alias id-tagged = identifier-tagged . An identifier is either a string of characters, or an identifier tagged with some value (e.g., with the identifier of a namespace). Funcon fresh-identifier : =&gt;identifiers . fresh-identifier computes an identifier distinct from all previously computed identifiers. Rule fresh-identifier ~&gt; identifier-tagged(\"generated\", fresh-atom) . Current bindings . Entity environment(_:environments) |- _ ---&gt; _ . Alias env = environment . The environment entity allows a computation to refer to the current bindings of identifiers to values. Funcon initialise-binding(X:=&gt;T) : =&gt;T ~&gt; initialise-linking(initialise-generating(closed(X))) . initialise-binding(X) ensures that X does not depend on non-local bindings. It also ensures that the linking entity (used to represent potentially cyclic bindings) and the generating entity (for creating fresh identifiers) are initialised. Funcon bind-value(I:identifiers, V:values) : =&gt;environments ~&gt; { I |-&gt; V } Alias bind = bind-value . bind-value(I, X) computes the environment that binds only I to the value computed by X. Funcon unbind(I:identifiers) : =&gt;environments ~&gt; { I |-&gt; ( ) } . unbind(I) computes the environment that hides the binding of I. Funcon bound-directly(_:identifiers) : =&gt;values . bound-directly(I) returns the value to which I is currently bound, if any, and otherwise fails. bound-directly(I) does not follow links. It is used only in connection with recursively-bound values when references are not encapsulated in abstractions. Rule lookup(Rho, I) ~&gt; (V:values) -------------------------------------------------------- environment(Rho) |- bound-directly(I:identifiers) ---&gt; V Rule lookup(Rho, I) ~&gt; ( ) ----------------------------------------------------------- environment(Rho) |- bound-directly(I:identifiers) ---&gt; fail . Funcon bound-value(I:identifiers) : =&gt;values ~&gt; follow-if-link(bound-directly(I)) Alias bound = bound-value . bound-value(I) inspects the value to which I is currently bound, if any, and otherwise fails. If the value is a link, bound-value(I) returns the value obtained by following the link, if any, and otherwise fails. If the inspected value is not a link, bound-value(I) returns it. bound-value(I) is used for references to non-recursive bindings and to recursively-bound values when references are encapsulated in abstractions. Scope . Funcon closed(X:=&gt;T) : =&gt;T . closed(X) ensures that X does not depend on non-local bindings. Rule environment(map( )) |- X ---&gt; X&prime; ------------------------------------------- environment(_) |- closed(X) ---&gt; closed(X&prime;) Rule closed(V:T) ~&gt; V . Funcon scope(_:environments, _:=&gt;T) : =&gt;T . scope(D,X) executes D with the current bindings, to compute an environment Rho representing local bindings. It then executes X to compute the result, with the current bindings extended by Rho, which may shadow or hide previous bindings. closed(scope(Rho, X)) ensures that X can reference only the bindings provided by Rho. Rule environment(map-override(Rho1, Rho0)) |- X ---&gt; X&prime; --------------------------------------------------------------------- environment(Rho0) |- scope(Rho1:environments, X) ---&gt; scope(Rho1, X&prime;) Rule scope(_:environments, V:T) ~&gt; V . Funcon accumulate(_:(=&gt;environments)*) : =&gt;environments . accumulate(D1, D2) executes D1 with the current bindings, to compute an environment Rho1 representing some local bindings. It then executes D2 to compute an environment Rho2 representing further local bindings, with the current bindings extended by Rho1, which may shadow or hide previous current bindings. The result is Rho1 extended by Rho2, which may shadow or hide the bindings of Rho1. accumulate(_, _) is associative, with map( ) as unit, and extends to any number of arguments. Rule D1 ---&gt; D1&prime; ------------------------------------------- accumulate(D1, D2) ---&gt; accumulate(D1&prime;, D2) Rule accumulate(Rho1:environments, D2) ~&gt; scope(Rho1, map-override(D2, Rho1)) Rule accumulate( ) ~&gt; map( ) Rule accumulate(D1) ~&gt; D1 Rule accumulate(D1, D2, D+) ~&gt; accumulate(D1, accumulate(D2, D+)) . Funcon collateral(Rho*:environments*) : =&gt;environments ~&gt; checked map-unite(Rho*) . collateral(D1, ...) pre-evaluates its arguments with the current bindings, and unites the resulting maps, which fails if the domains are not pairwise disjoint. collateral(D1, D2) is associative and commutative with map( ) as unit, and extends to any number of arguments. Recurse . Funcon bind-recursively(I:identifiers, E:=&gt;values) : =&gt;environments ~&gt; recursive({I}, bind-value(I, E)) . bind-recursively(I, E) binds I to a link that refers to the value of E, representing a recursive binding of I to the value of E. Since bound-value(I) follows links, it should not be executed during the evaluation of E. Funcon recursive(SI:sets(identifiers), D:=&gt;environments) : =&gt;environments ~&gt; re-close(bind-to-forward-links(SI), D) . recursive(SI, D) executes D with potential recursion on the bindings of the identifiers in the set SI (which need not be the same as the set of identifiers bound by D). Auxiliary Funcon re-close(M:maps(identifiers, links), D:=&gt;environments) : =&gt;environments ~&gt; accumulate(scope(M, D), sequential(set-forward-links(M), map( ))) . re-close(M, D) first executes D in the scope M, which maps identifiers to freshly allocated links. This computes an environment Rho where the bound values may contain links, or implicit references to links in abstraction values. It then sets the link for each identifier in the domain of M to refer to its bound value in Rho, and returns Rho as the result. Auxiliary Funcon bind-to-forward-links(SI:sets(identifiers)) : =&gt;maps(identifiers, links) ~&gt; map-unite(interleave-map(bind-value(given, fresh-link(values)), set-elements(SI))) . bind-to-forward-links(SI) binds each identifier in the set SI to a freshly allocated link. Auxiliary Funcon set-forward-links(M:maps(identifiers, links)) : =&gt;null-type ~&gt; effect(interleave-map(set-link(map-lookup(M, given), bound-value(given)), set-elements(map-domain(M)))) . For each identifier I in the domain of M, set-forward-links(M) sets the link to which I is mapped by M to the current bound value of I. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Binding/index.html#binding",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Binding/index.html#binding"
  },"39": {
    "doc": "Binding",
    "title": "Binding",
    "content": "Funcons-beta : Binding.cbs | PRETTY | PDF . Outline . | Binding . | Environments | Current bindings | Scope | Recurse | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Binding/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Binding/index.html"
  },"40": {
    "doc": "Flowing",
    "title": "Flowing",
    "content": "[ Funcon left-to-right Alias l-to-r Funcon right-to-left Alias r-to-l Funcon sequential Alias seq Funcon effect Funcon choice Funcon if-true-else Alias if-else Funcon while-true Alias while Funcon do-while-true Alias do-while Funcon interleave Datatype yielding Funcon signal Funcon yielded Funcon yield Funcon yield-on-value Funcon yield-on-abrupt Funcon atomic ] . Meta-variables T &lt;: values T* &lt;: values* . Sequencing . Funcon left-to-right(_:(=&gt;(T)*)*) : =&gt;(T)* Alias l-to-r = left-to-right . left-to-right(...) computes its arguments sequentially, from left to right, and gives the resulting sequence of values, provided all terminate normally. For example, integer-add(X, Y) may interleave the computations of X and Y, whereas integer-add left-to-right(X, Y) always computes X before Y. When each argument of left-to-right(...) computes a single value, the type of the result is the same as that of the argument sequence. For instance, when X:T and Y:T&prime;, the result of left-to-right(X, Y) is of type (T, T&prime;). The only effect of wrapping an argument sequence in left-to-right(...) is to ensure that when the arguments are to be evaluated, it is done in the specified order. Rule Y ---&gt; Y&prime; ------------------------------------------------------------ left-to-right(V*:(T)*, Y, Z*) ---&gt; left-to-right(V*, Y&prime;, Z*) Rule left-to-right(V*:(T)*) ~&gt; V* . Funcon right-to-left(_:(=&gt;(T)*)*) : =&gt;(T)* Alias r-to-l = right-to-left . right-to-left(...) computes its arguments sequentially, from right to left, and gives the resulting sequence of values, provided all terminate normally. Note that right-to-left(X*) and reverse left-to-right reverse(X*) are not equivalent: reverse(X*) interleaves the evaluation of X*. Rule Y ---&gt; Y&prime; ------------------------------------------------------------ right-to-left(X*, Y, V*:(T)*) ---&gt; right-to-left(X*, Y&prime;, V*) Rule right-to-left(V*:(T)*) ~&gt; V* . Funcon sequential(_:(=&gt;null-type)*, _:=&gt;T) : =&gt;T Alias seq = sequential . sequential(X, ...) computes its arguments in the given order. On normal termination, it returns the value of the last argument; the other arguments all compute null-value. Binary sequential(X, Y) is associative, with unit null-value. Rule X ---&gt; X&prime; ----------------------------------------- sequential(X, Y+) ---&gt; sequential(X&prime;, Y+) Rule sequential(null-value, Y+) ~&gt; sequential(Y+) Rule sequential(Y) ~&gt; Y . Funcon effect(V*:T*) : =&gt;null-type ~&gt; null-value . effect(...) interleaves the computations of its arguments, then discards all the computed values. Choosing . Funcon choice(_:(=&gt;T)+) : =&gt;T . choice(Y, ...) selects one of its arguments, then computes it. It is associative and commutative. Rule choice(X*, Y, Z*) ~&gt; Y . Funcon if-true-else(_:booleans, _:=&gt;T, _:=&gt;T) : =&gt;T Alias if-else = if-true-else . if-true-else(B, X, Y) evaluates B to a Boolean value, then reduces to X or Y, depending on the value of B. Rule if-true-else(true, X, Y) ~&gt; X Rule if-true-else(false, X, Y) ~&gt; Y . Iterating . Funcon while-true(B:=&gt;booleans, X:=&gt;null-type) : =&gt;null-type ~&gt; if-true-else(B, sequential(X, while-true(B, X)), null-value) Alias while = while-true . while-true(B, X) evaluates B to a Boolean value. Depending on the value of B, it either executes X and iterates, or terminates normally. The effect of abruptly breaking the iteration is obtained by the combination handle-break(while-true(B, X)), and that of abruptly continuing the iteration by while-true(B, handle-continue(X)). Funcon do-while-true(X:=&gt;null-type, B:=&gt;booleans) : =&gt;null-type ~&gt; sequential(X, if-true-else(B, do-while-true(X, B), null-value)) Alias do-while = do-while-true . do-while-true(X, B) is equivalent to sequential(X, while-true(B, X)). Interleaving . Funcon interleave(_:T*) : =&gt;T* . interleave(...) computes its arguments in any order, possibly interleaved, and returns the resulting sequence of values, provided all terminate normally. Fairness of interleaving is not required, so pure left-to-right computation is allowed. atomic(X) prevents interleaving in X, except after transitions that emit a yielded(signal). Rule interleave(V*:T*) ~&gt; V* . Datatype yielding ::= signal . Entity _ --yielded(_:yielding?)-&gt; _ . yielded(signal) in a label on a transition allows interleaving at that point in the enclosing atomic computation. yielded( ) indicates interleaving at that point in an atomic computation is not allowed. Funcon yield : =&gt;null-type ~&gt; yield-on-value(null-value) . Funcon yield-on-value(_:T) : =&gt;T . yield-on-value(X) allows interleaving in an enclosing atomic computation on normal termination of X. Rule yield-on-value(V:T) --yielded(signal)-&gt; V . Funcon yield-on-abrupt(_:=&gt;T) : =&gt;T . yield-on-abrupt(X) ensures that abrupt termination of X is propagated through an enclosing atomic computation. Rule X --abrupt(V:T),yielded(_?)-&gt; X&prime; -------------------------------------------------------------------- yield-on-abrupt(X) --abrupt(V),yielded(signal)-&gt; yield-on-abrupt(X&prime;) Rule X --abrupt( )-&gt; X&prime; ---------------------------------------------------- yield-on-abrupt(X) --abrupt( )-&gt; yield-on-abrupt(X&prime;) Rule yield-on-abrupt(V:T) ~&gt; V . Funcon atomic(_:=&gt;T) : =&gt;T . atomic(X) computes X, but controls its potential interleaving with other computations: interleaving is only allowed following a transition of X that emits yielded(signal). Rule X --yielded( )-&gt;1 X&prime; atomic(X&prime;) --yielded( )-&gt;2 X&prime;&prime; ----------------------------------------------- atomic(X) --yielded( )-&gt;1 ; --yielded( )-&gt;2 X&prime;&prime; Rule X --yielded( )-&gt; V V : T --------------------------- atomic(X) --yielded( )-&gt; V Rule atomic(V:T) ~&gt; V Rule X --yielded(signal)-&gt; X&prime; ----------------------------------- atomic(X) --yielded( )-&gt; atomic(X&prime;) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Flowing/index.html#flowing",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Flowing/index.html#flowing"
  },"41": {
    "doc": "Flowing",
    "title": "Flowing",
    "content": "Funcons-beta : Flowing.cbs | PRETTY | PDF . Outline . | Flowing . | Sequencing | Choosing | Iterating | Interleaving | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Flowing/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Flowing/index.html"
  },"42": {
    "doc": "Generating",
    "title": "Generating",
    "content": "[ Type atoms Entity used-atom-set Funcon initialise-generating Funcon fresh-atom Funcon use-atom-not-in ] . Meta-variables T &lt;: values . Built-in Type atoms . atoms is the type of values used as distinguishable tags. Notation for individual atoms is not provided. Entity &lt; _ , used-atom-set(_:sets(atoms)) &gt; ---&gt; &lt; _ , used-atom-set(_:sets(atoms)) &gt; . Built-in Funcon initialise-generating(_:=&gt;T) : =&gt;T . The initial value of the used-atom-set(SA) entity is unspecified. It could contains atoms that are reserved for internal use. Funcon fresh-atom : =&gt;atoms . fresh-atom computes an atom distinct from all previously computed atoms. Rule element-not-in(atoms, SA) ~&gt; A ----------------------------------------------- &lt; fresh-atom , used-atom-set(SA) &gt; ---&gt; &lt; A , used-atom-set(set-insert(A, SA)) &gt; . Funcon use-atom-not-in(_:sets(atoms)) : =&gt;atoms . use-atom-not-in(SA) computes an atom not in the set SA, and inserts it in the used-atom-set(SA&prime;) entity, in case it was not previously used. Rule element-not-in(atoms, SA) ~&gt; A -------------------------------------------------------- &lt; use-atom-not-in(SA:sets(atoms)) , used-atom-set(SA&prime;) &gt; ---&gt; &lt; A , used-atom-set(set-insert(A, SA&prime;)) &gt; . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Generating/index.html#generating",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Generating/index.html#generating"
  },"43": {
    "doc": "Generating",
    "title": "Generating",
    "content": "Funcons-beta : Generating.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Generating/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Generating/index.html"
  },"44": {
    "doc": "Giving",
    "title": "Giving",
    "content": "[ Entity given-value Funcon initialise-giving Funcon give Funcon given Funcon no-given Funcon left-to-right-map Funcon interleave-map Funcon left-to-right-repeat Funcon interleave-repeat Funcon left-to-right-filter Funcon interleave-filter Funcon fold-left Funcon fold-right ] . Meta-variables T, T&prime; &lt;: values T? &lt;: values? . Entity given-value(_:values?) |- _ ---&gt; _ . The given-value entity allows a computation to refer to a single previously-computed V:values. The given value ( ) represents the absence of a current given value. Funcon initialise-giving(X:( )=&gt;T&prime;) : ( )=&gt;T&prime; ~&gt; no-given(X) . initialise-giving(X) ensures that the entities used by the funcons for giving are properly initialised. Funcon give(_:T, _:T=&gt;T&prime;) : =&gt;T&prime; . give(X, Y) executes X, possibly referring to the current given value, to compute a value V. It then executes Y with V as the given value, to compute the result. Rule given-value(V) |- Y ---&gt; Y&prime; ------------------------------------------------ given-value(_?) |- give(V:T, Y) ---&gt; give(V, Y&prime;) Rule give(_:T, W:T&prime;) ~&gt; W . Funcon given : T=&gt;T . given refers to the current given value. Rule given-value(V:values) |- given ---&gt; V Rule given-value( ) |- given ---&gt; fail . Funcon no-given(_:( )=&gt;T&prime;) : ( )=&gt;T&prime; . no-given(X) computes X without references to the current given value. Rule given-value( ) |- X ---&gt; X&prime; ------------------------------------------------ given-value(_?) |- no-given(X) ---&gt; no-given(X&prime;) Rule no-given(U:T&prime;) ~&gt; U . Mapping . Maps on collection values can be expressed directly, e.g., list(left-to-right-map(F, list-elements(L))). Funcon left-to-right-map(_:T=&gt;T&prime;, _:(T)*) : =&gt;(T&prime;)* . left-to-right-map(F, V*) computes F for each value in V* from left to right, returning the sequence of resulting values. Rule left-to-right-map(F, V:T, V*:(T)*) ~&gt; left-to-right(give(V, F), left-to-right-map(F, V*)) Rule left-to-right-map(_, ( )) ~&gt; ( ) . Funcon interleave-map(_:T=&gt;T&prime;, _:(T)*) : =&gt;(T&prime;)* . interleave-map(F, V*) computes F for each value in V* interleaved, returning the sequence of resulting values. Rule interleave-map(F, V:T, V*:(T)*) ~&gt; interleave(give(V, F), interleave-map(F, V*)) Rule interleave-map(_, ( )) ~&gt; ( ) . Funcon left-to-right-repeat(_:integers=&gt;T&prime;, _:integers, _:integers) : =&gt;(T&prime;)* . left-to-right-repeat(F, M, N) computes F for each value from M to N sequentially, returning the sequence of resulting values. Rule is-less-or-equal(M, N) == true ------------------------------------------------------------------------- left-to-right-repeat(F, M:integers, N:integers) ~&gt; left-to-right(give(M, F), left-to-right-repeat(F, int-add(M, 1), N)) Rule is-less-or-equal(M, N) == false ---------------------------------------------- left-to-right-repeat(_, M:integers, N:integers) ~&gt; ( ) . Funcon interleave-repeat(_:integers=&gt;T&prime;, _:integers, _:integers) : =&gt;(T&prime;)* . interleave-repeat(F, M, N) computes F for each value from M to N interleaved, returning the sequence of resulting values. Rule is-less-or-equal(M, N) == true ------------------------------------------------------------------- interleave-repeat(F, M:integers, N:integers) ~&gt; interleave(give(M, F), interleave-repeat(F, int-add(M, 1), N)) Rule is-less-or-equal(M, N) == false ------------------------------------------- interleave-repeat(_, M:integers, N:integers) ~&gt; ( ) . Filtering . Filters on collections of values can be expressed directly, e.g., list(left-to-right-filter(P, list-elements(L))) to filter a list L. Funcon left-to-right-filter(_:T=&gt;booleans, _:(T)*) : =&gt;(T)* . left-to-right-filter(P, V*) computes P for each value in V* from left to right, returning the sequence of argument values for which the result is true. Rule left-to-right-filter(P, V:T, V*:(T)*) ~&gt; left-to-right(when-true(give(V, P), V), left-to-right-filter(P, V*)) Rule left-to-right-filter(_) ~&gt; ( ) . Funcon interleave-filter(_:T=&gt;booleans, _:(T)*) : =&gt;(T)* . interleave-filter(P, V*) computes P for each value in V* interleaved, returning the sequence of argument values for which the result is true. Rule interleave-filter(P, V:T, V*:(T)*) ~&gt; interleave(when-true(give(V, P), V), interleave-filter(P, V*)) Rule interleave-filter(_) ~&gt; ( ) . Folding . Funcon fold-left(_:tuples(T,T&prime;)=&gt;T, _:T, _:(T&prime;)*) : =&gt;T . fold-left(F, A, V*) reduces a sequence V* to a single value by folding it from the left, using A as the initial accumulator value, and iteratively updating the accumulator by giving F the pair of the accumulator value and the first of the remaining arguments. Rule fold-left(_, A:T, ( )) ~&gt; A Rule fold-left(F, A:T, V:T&prime;, V*:(T&prime;)*) ~&gt; fold-left(F, give(tuple(A, V), F), V*) . Funcon fold-right(_:tuples(T,T&prime;)=&gt;T&prime;, _:T&prime;, _:(T)*) : =&gt;T&prime; . fold-right(F, A, V*) reduces a sequence V* to a single value by folding it from the right, using A as the initial accumulator value, and iteratively updating the accumulator by giving F the pair of the the last of the remaining arguments and the accumulator value. Rule fold-right(_, A:T&prime;, ( )) ~&gt; A Rule fold-right(F, A:T&prime;, V*:(T)*, V:T) ~&gt; give(tuple(V, fold-right(F, A, V*)), F) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Giving/index.html#giving",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Giving/index.html#giving"
  },"45": {
    "doc": "Giving",
    "title": "Giving",
    "content": "Funcons-beta : Giving.cbs | PRETTY | PDF . Outline . | Giving . | Mapping | Filtering | Folding | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Giving/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Giving/index.html"
  },"46": {
    "doc": "Interacting",
    "title": "Interacting",
    "content": "Output . [ Entity standard-out Funcon print ] . Entity _ -- standard-out!(_:values*) -&gt; _ . This entity represents the sequence of values output by a particular transition, where the empty sequence ( ) represents the lack of output. Composition of transitions concatenates their output sequences. Funcon print(_:values*) : =&gt;null-type . print(X*) evaluates the arguments X* and emits the resulting sequence of values on the standard-out channel. print( ) has no effect. Rule print(V*:values*) -- standard-out!(V*) -&gt; null-value . Input . [ Entity standard-in Funcon read ] . Entity _ -- standard-in?(_:values*) -&gt; _ . This entity represents the sequence of values input by a particular transition, where the empty sequence ( ) represents that no values are input. The value null-value represents the end of the input. Composition of transitions concatenates their input sequences, except that when the first sequence ends with null-value, the second seqeunce has to be just null-value. Funcon read : =&gt;values . read inputs a single value from the standard-in channel, and returns it. If the end of the input has been reached, read fails. Rule read -- standard-in?(V:~null-type) -&gt; V Rule read -- standard-in?(null-value) -&gt; fail . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Interacting/index.html#interacting",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Interacting/index.html#interacting"
  },"47": {
    "doc": "Interacting",
    "title": "Interacting",
    "content": "Funcons-beta : Interacting.cbs | PRETTY | PDF . Outline . | Interacting . | Output | Input | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Interacting/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Interacting/index.html"
  },"48": {
    "doc": "Linking",
    "title": "Linking",
    "content": "[ Datatype links Funcon initialise-linking Funcon link Funcon fresh-link Funcon fresh-initialised-link Alias fresh-init-link Funcon set-link Funcon follow-if-link ] . Meta-variables T &lt;: values . Datatype links ::= link(_:variables) . Funcon initialise-linking(X:=&gt;T) : =&gt;T ~&gt; initialise-storing(X) . initialise-linking(X) ensures that the entities used by the funcons for linking are properly initialised. Funcon fresh-link(T) : =&gt;links ~&gt; link(allocate-variable(T)) . Funcon fresh-initialised-link(T, V:T) : =&gt;links ~&gt; link(allocate-initialised-variable(T, V)) Alias fresh-init-link = fresh-initialised-link . Funcon set-link(_:links, _:T) : =&gt;null-type . The value of a link can be set only once. Rule set-link(link(Var:variables), V:T) ~&gt; initialise-variable(Var, V) . Funcon follow-link(_:links) : =&gt;values Rule follow-link(link(Var:variables)) ~&gt; assigned(Var) . Funcon follow-if-link(_:values) : =&gt;values . If V is a link, follow-if-link(V) computes the set value, and otherwise it evaluates to V. Rule follow-if-link(link(Var:variables)) ~&gt; assigned(Var) Rule follow-if-link(V:~links) ~&gt; V . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Linking/index.html#linking",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Linking/index.html#linking"
  },"49": {
    "doc": "Linking",
    "title": "Linking",
    "content": "Funcons-beta : Linking.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Linking/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Linking/index.html"
  },"50": {
    "doc": "Storing",
    "title": "Storing",
    "content": "[ Datatype locations Alias locs Type stores Entity store Funcon initialise-storing Funcon store-clear Datatype variables Alias vars Funcon variable Alias var Funcon allocate-variable Alias alloc Funcon recycle-variables Alias recycle Funcon initialise-variable Alias init Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned Funcon current-value Funcon un-assign Funcon structural-assign Funcon structural-assigned ] . Meta-variables T, T&prime; &lt;: values . Stores . Type locations ~&gt; atoms Alias locs = locations . A storage location is represented by an atom. Type stores ~&gt; maps(locations, values?) . The domain of a store is the set of currently allocated locations. Mapping a location to ( ) models the absence of its stored value; removing it from the store allows it to be re-allocated. Entity &lt; _ , store(_:stores) &gt; ---&gt; &lt; _ , store(_:stores) &gt; . The current store is a mutable entity. A transition &lt; X , store(Sigma) &gt; ---&gt; &lt; X&prime; , store(Sigma&prime;) &gt; models a step from X to X&prime; where the difference between Sigma and Sigma&prime; (if any) corresponds to storage effects. Funcon store-clear : =&gt;null-type Rule &lt; store-clear , store(_) &gt; ---&gt; &lt; null-value , store(map( )) &gt; . store-clear ensures the store is empty. Funcon initialise-storing(X:=&gt;T) : =&gt;T ~&gt; sequential(store-clear, initialise-giving(initialise-generating(X))) Alias init-storing = initialise-storing . initialise-storing(X) ensures that the entities used by the funcons for storing are properly initialised. Simple variables . Simple variables may store primitive or structured values. The type of values stored by a variable is fixed when it is allocated. For instance, allocate-variable(integers) allocates a simple integer variable, and allocate-variable(vectors(integers)) allocates a structured variable for storing vectors of integers, which can be updated only monolithically. Datatype variables ::= variable(_:locations, _:value-types) Alias vars = variables . Alias var = variable . variables is the type of simple variables that can store values of a particular type. variable(L, T) constructs a simple variable for storing values of type T at location L. Variables at different locations are independent. Note that variables is a subtype of datatype-values. Funcon allocate-variable(T:types) : =&gt;variables Alias alloc = allocate-variable . allocate-variable(T) gives a simple variable whose location is not in the current store. Subsequent uses of allocate-variable(T&prime;) give independent variables, except after recycle-variables(V,...) or store-clear. Rule &lt; use-atom-not-in(dom(Sigma)) , store(Sigma) &gt; ---&gt; &lt; L , store(Sigma&prime;) &gt; map-override({L |-&gt; ( )}, Sigma&prime;) ~&gt; Sigma&prime;&prime; ------------------------------------------------------------------------- &lt; allocate-variable(T:types) , store(Sigma) &gt; ---&gt; &lt; variable(L, T) , store(Sigma&prime;&prime;) &gt; . Funcon recycle-variables(_:variables+) : =&gt;null-type Alias recycle = recycle-variables . recycle-variables(Var,...) removes the locations of Var, …, from the current store, so that they may subsequently be re-allocated. Rule is-in-set(L, dom(Sigma)) == true --------------------------------------------------------------------- &lt; recycle-variables(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; null-value , store(map-delete(Sigma, {L})) &gt; Rule is-in-set(L, dom(Sigma)) == false --------------------------------------------------------------------- &lt; recycle-variables(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; fail , store(Sigma) &gt; Rule recycle-variables(Var:variables, Var+:variables+) ~&gt; sequential(recycle-variables(Var), recycle-variables(Var+)) . Funcon initialise-variable(_:variables, _:values) : =&gt;null-type Alias init = initialise-variable . initialise-variable(Var, Val) assigns Val as the initial value of Var, and gives null-value. If Var already has an assigned value, it fails. Rule and(is-in-set(L, dom(Sigma)), not is-value(map-lookup(Sigma, L)), is-in-type(Val, T)) == true ---------------------------------------------------------------------------- &lt; initialise-variable(variable(L:locations, T:types), Val:values) , store(Sigma) &gt; ---&gt; &lt; null-value , store(map-override({L|-&gt;Val}, Sigma)) &gt; Rule and(is-in-set(L, dom(Sigma)), not is-value(map-lookup(Sigma, L)), is-in-type(Val, T)) == false ---------------------------------------------------------------------------- &lt; initialise-variable(variable(L:locations, T:types), Val:values) , store(Sigma) &gt; ---&gt; &lt; fail , store(Sigma) &gt; . Funcon allocate-initialised-variable(T, Val:T) : =&gt;variables ~&gt; give(allocate-variable(T), sequential(initialise-variable(given, Val), given)) Alias alloc-init = allocate-initialised-variable . allocate-initialised-variable(T, Val) allocates a simple variable for storing values of type T, initialises its value to Val, and returns the variable. Funcon assign(_:variables, _:values) : =&gt;null-type . assign(Var, Val) assigns the value Val to the variable Var, provided that Var was allocated with a type that contains Val. Rule and(is-in-set(L, dom(Sigma)), is-in-type(Val, T)) == true ----------------------------------------------------------------------- &lt; assign(variable(L:locations, T:types), Val:values) , store(Sigma) &gt; ---&gt; &lt; null-value , store(map-override({L|-&gt;Val}, Sigma)) &gt; Rule and(is-in-set(L, dom(Sigma)), is-in-type(Val, T)) == false -------------------------------------------------------------------------- &lt; assign(variable(L:locations,T:types), Val:values) , store(Sigma) &gt; ---&gt; &lt; fail , store(Sigma) &gt; . Funcon assigned(_:variables) : =&gt;values . assigned(Var) gives the value assigned to the variable Var, failing if no value is currently assigned. Rule map-lookup(Sigma, L) ~&gt; (Val:values) ------------------------------------------------------------------ &lt; assigned(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; Val , store(Sigma) &gt; Rule map-lookup(Sigma, L) == ( ) ------------------------------------------------------------------ &lt; assigned(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; fail , store(Sigma) &gt; . Funcon current-value(_:values) : =&gt;values . current-value(V) gives the same result as assigned(V) when V is a simple variable, and otherwise gives V. It represents implicit dereferencing of a value that might be a variable. Rule current-value(Var:variables) ~&gt; assigned(Var) Rule current-value(U:~variables) ~&gt; U . Funcon un-assign(_:variables) : =&gt;null-type . un-assign(Var) remove the value assigned to the variable Var. Rule is-in-set(L, dom(Sigma)) == true -------------------------------------------------------------------------- &lt; un-assign(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; null-value , store(map-override({L |-&gt; ( )}, Sigma)) &gt; Rule is-in-set(L, dom(Sigma)) == false -------------------------------------------------------------------------- &lt; un-assign(variable(L:locations, T:types)) , store(Sigma) &gt; ---&gt; &lt; fail , store(Sigma) &gt; . Structured variables . Structured variables are structured values where some components are simple variables. Such component variables can be selected using the same funcons as for selecting components of structured values. Structured variables containing both simple variables and values correspond to hybrid structures where particular components are mutable. All datatypes (except for abstractions) can be used to form structured variables. So can maps, but not sets or multisets. Structural generalisations of assign(Var, Val) and assigned(Var) access all the simple variables contained in a structured variable. Assignment requires each component value of a hybrid structured variable to be equal to the corresponding component of the structured value. Funcon structural-assign(_:values, _:values) : =&gt;null-type . structural-assign(V1, V2) takes a (potentially) structured variable V1and a (potentially) structured value V2. Provided that the structure and all non-variable values in V1 match the structure and corresponding values of V2, all the simple variables in V1 are assigned the corresponding values of V2; otherwise the assignment fails. Rule structural-assign(V1:variables, V2:values) ~&gt; assign(V1, V2) Rule V1 : ~(variables) V1 ~&gt; datatype-value(I1:identifiers, V1*:values*) V2 ~&gt; datatype-value(I2:identifiers, V2*:values*) ----------------------------------------------------------------------- structural-assign(V1:datatype-values, V2:datatype-values) ~&gt; sequential( check-true(is-equal(I1, I2)), effect(tuple(interleave-map( structural-assign(tuple-elements(given)), tuple-zip(tuple(V1*), tuple(V2*))))), null-value) . Note that simple variables are datatype values. Rule dom(M1) == {} ------------------------------------------------------ structural-assign(M1:maps(_,_), M2:maps(_,_)) ~&gt; check-true(is-equal(dom(M2), { })) Rule some-element(dom(M1)) ~&gt; K ---------------------------------------------------------------------------- structural-assign(M1:maps(_, _), M2:maps(_, _)) ~&gt; sequential(check-true(is-in-set(K, dom(M2))), structural-assign(map-lookup(M1, K), map-lookup(M2, K)), structural-assign(map-delete(M1, {K}), map-delete(M2, {K}))) Rule V1 : ~(datatype-values|maps(_, _)) --------------------------------------------------------------- structural-assign(V1:values,V2:values) ~&gt; check-true(is-equal(V1, V2)) . Funcon structural-assigned(_:values) : =&gt;values . structural-assigned(V) takes a (potentially) structured variable V, and computes the value of V with all simple variables in V replaced by their assigned values, failing if any of them do not have assigned values. When V is just a simple variable or a (possibly structured) value with no component variables, structural-assigned(V) gives the same result as current-value(V). Rule structural-assigned(Var:variables) ~&gt; assigned(Var) Rule V : ~(variables) V ~&gt; datatype-value(I:identifiers, V*:values*) ---------------------------------------------------------------------------- structural-assigned(V:datatype-values) ~&gt; datatype-value(I, interleave-map(structural-assigned(given), V*)) . Note that simple variables are datatype values. Rule structural-assigned(M:maps(_, _)) ~&gt; map(interleave-map(structural-assigned(given), map-elements(M))) Rule U : ~(datatype-values|maps(_, _)) ------------------------------------------ structural-assigned(U:values) ~&gt; U . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Storing/index.html#storing",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Storing/index.html#storing"
  },"51": {
    "doc": "Storing",
    "title": "Storing",
    "content": "Funcons-beta : Storing.cbs | PRETTY | PDF . Outline . | Storing . | Stores | Simple variables | Structured variables | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/Storing/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/Storing/index.html"
  },"52": {
    "doc": "Normal",
    "title": "Normal computations",
    "content": "Funcons for expressing normal computation generally terminate normally, computing (sequences of) values. If an executed computation argument terminates abnormally, however, these funcons always propagate the abnormal termination. The execution of a funcon for normal computation may also fail, which is a particular kind of abnormal termination used to represent dynamic errors (e.g., referencing an unbound identifier). The CBS library includes funcons corresponding to the following concepts: . Flowing pure flow of control Giving computing values, and referencing the latest computed value Binding binding identifiers to values, and referencing them Generating computing fresh values Storing allocating variables, assigning values to them, and inspecting current values Linking creating potentially cyclic bindings Interacting interactive input and output. ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/index.html#normal-computations",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/index.html#normal-computations"
  },"53": {
    "doc": "Normal",
    "title": "Normal",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/Normal/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/Normal/index.html"
  },"54": {
    "doc": "Computations",
    "title": "Computations",
    "content": "The CBS library provides funcons for expressing and composing various kinds of computations. A funcon takes a sequence of values and/or computations as arguments, and may compute a sequence of values. A value argument is the result of a previous computation, and can be inspected; a computation argument, in contrast, can only be executed or ignored. A computation may terminate normally or abnormally, or never terminate. Values (and sequences of values) correspond to immediately terminating computations. ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/index.html",
    "relUrl": "/docs/Funcons-beta/Computations/index.html"
  },"55": {
    "doc": "Computations",
    "title": "Normal computations",
    "content": "Funcons for expressing normal computations compute (sequences of) values on normal termination. They propagate abnormal termination of their arguments. ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/index.html#normal-computations",
    "relUrl": "/docs/Funcons-beta/Computations/index.html#normal-computations"
  },"56": {
    "doc": "Computations",
    "title": "Abnormal computations",
    "content": "Funcons for expressing abnormal computations may terminate abruptly without computing values; they also include handlers for abnormal termination. ",
    "url": "/CBS-beta/docs/Funcons-beta/Computations/index.html#abnormal-computations",
    "relUrl": "/docs/Funcons-beta/Computations/index.html#abnormal-computations"
  },"57": {
    "doc": "Entities",
    "title": "Entities",
    "content": "The entities used in modular structural operational semantics are classified according to how they flow during program execution: . Contextual A contextual entity remains fixed for successive steps in the computation of a term, but can be different for the computations of sub-terms. Mutable Changes to a mutable entity are threaded sequentially through the computation of a term and its sub-terms. Input An input entity is a sequence of values, and the sequences input by successive steps are independent. Output An output entity is a sequence of values, and the sequences output by successive steps are independent. Control A control entity is a value that can optionally be signalled by a step. The corresponding step of an enclosing term may inspect the value, and signal the same value, signal a different value, or not signal. There are no funcons for reifying entities as values, nor for reflecting values as entities! This is because the way that particular entities flow during funcon execution is inherent and characteristic; reification and reflection would allow the flow to be circumvented. The following entities are used in the definitions of funcons for computations. The execution of a term is unaffected by entities that are not involved in the funcons used in it. | The given-value is a contextual entity that supports references to a previously computed value. Funcon computation arguments that refer to an unknown given value correspond to ‘lambdas’. | The environment is a contextual entity that represents the currently visible bindings. Some funcons affect the environment during the execution of computation arguments, but the entity implicitly reverts back to the previous value afterwards (‘push’ and ‘pop’ steps are not required). | The used-atom-set is a mutable entity supporting the generation of fresh atomic values. | The store is a mutable entity representing the currently allocated variables and their current values. It supports uninitialised variables, and recycling of variables. Single-assignment variables are used to represent cyclic bindings. | The standard-in is an input entity representing a sequences of interactive input values. Inputting a value removes it from the sequence. | The standard-out is an output entity representing sequences of interactive output values. Outputting a value adds it to the sequence. | The abrupted entity is a control entity which signals abrupt termination of a computation. | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Entities/index.html",
    "relUrl": "/docs/Funcons-beta/Entities/index.html"
  },"58": {
    "doc": "Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#computations",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#computations"
  },"59": {
    "doc": "Funcons-Index",
    "title": "Types of computation",
    "content": "[ Funcon computation-types ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#types-of-computation",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#types-of-computation"
  },"60": {
    "doc": "Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#normal-computation"
  },"61": {
    "doc": "Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon left-to-right Alias l-to-r Funcon right-to-left Alias r-to-l Funcon sequential Alias seq Funcon effect Funcon choice Funcon if-true-else Alias if-else Funcon while-true Alias while Funcon do-while-true Alias do-while Funcon interleave Datatype yielding Funcon signal Funcon yielded Funcon yield Funcon yield-on-value Funcon yield-on-abrupt Funcon atomic ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#flowing"
  },"62": {
    "doc": "Funcons-Index",
    "title": "Giving",
    "content": "[ Entity given-value Funcon initialise-giving Funcon give Funcon given Funcon no-given Funcon left-to-right-map Funcon interleave-map Funcon left-to-right-repeat Funcon interleave-repeat Funcon left-to-right-filter Funcon interleave-filter Funcon fold-left Funcon fold-right ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#giving",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#giving"
  },"63": {
    "doc": "Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon identifier-tagged Alias id-tagged Funcon fresh-identifier Entity environment Alias env Funcon initialise-binding Funcon bind-value Alias bind Funcon unbind Funcon bound-directly Funcon bound-value Alias bound Funcon closed Funcon scope Funcon accumulate Funcon collateral Funcon bind-recursively Funcon recursive ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#binding",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#binding"
  },"64": {
    "doc": "Funcons-Index",
    "title": "Generating",
    "content": "[ Type atoms Entity used-atom-set Funcon initialise-generating Funcon fresh-atom Funcon use-atom-not-in ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#generating",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#generating"
  },"65": {
    "doc": "Funcons-Index",
    "title": "Storing",
    "content": "[ Datatype locations Alias locs Type stores Entity store Funcon initialise-storing Funcon store-clear Datatype variables Alias vars Funcon variable Alias var Funcon allocate-variable Alias alloc Funcon recycle-variables Alias recycle Funcon initialise-variable Alias init Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned Funcon current-value Funcon un-assign Funcon structural-assign Funcon structural-assigned ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#storing",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#storing"
  },"66": {
    "doc": "Funcons-Index",
    "title": "Linking",
    "content": "[ Datatype links Funcon initialise-linking Funcon link Funcon fresh-link Funcon fresh-initialised-link Alias fresh-init-link Funcon set-link Funcon follow-if-link ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#linking",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#linking"
  },"67": {
    "doc": "Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Entity standard-in Funcon read ] . Output . [ Entity standard-out Funcon print ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#interacting"
  },"68": {
    "doc": "Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#abnormal-computation"
  },"69": {
    "doc": "Funcons-Index",
    "title": "Terminating abruptly",
    "content": "[ Funcon stuck Entity abrupted Funcon finalise-abrupting Funcon abrupt Funcon handle-abrupt Funcon finally ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#terminating-abruptly",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#terminating-abruptly"
  },"70": {
    "doc": "Funcons-Index",
    "title": "Failing",
    "content": "[ Datatype failing Funcon failed Funcon finalise-failing Funcon fail Funcon else Funcon else-choice Funcon checked Funcon check-true ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#failing",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#failing"
  },"71": {
    "doc": "Funcons-Index",
    "title": "Throwing",
    "content": "[ Datatype throwing Funcon thrown Funcon finalise-throwing Funcon throw Funcon handle-thrown Funcon handle-recursively Funcon catch-else-throw ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#throwing",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#throwing"
  },"72": {
    "doc": "Funcons-Index",
    "title": "Returning",
    "content": "[ Datatype returning Funcon returned Funcon finalise-returning Funcon return Funcon handle-return ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#returning",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#returning"
  },"73": {
    "doc": "Funcons-Index",
    "title": "Breaking",
    "content": "[ Datatype breaking Funcon broken Funcon finalise-breaking Funcon break Funcon handle-break ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#breaking",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#breaking"
  },"74": {
    "doc": "Funcons-Index",
    "title": "Continuing",
    "content": "[ Datatype continuing Funcon continued Funcon finalise-continuing Funcon continue Funcon handle-continue ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#continuing",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#continuing"
  },"75": {
    "doc": "Funcons-Index",
    "title": "Controlling",
    "content": "[ Datatype continuations Funcon continuation Entity plug-signal Funcon hole Funcon resume-continuation Entity control-signal Funcon control Funcon delimit-current-continuation Alias delimit-cc ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#controlling",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#controlling"
  },"76": {
    "doc": "Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#values",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#values"
  },"77": {
    "doc": "Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Type value-types Alias types Type empty-type Funcon is-in-type Alias is Funcon is-value Alias is-val Funcon when-true Alias when Type cast-to-type Alias cast Type ground-values Alias ground-vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#value-types"
  },"78": {
    "doc": "Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#primitive-values"
  },"79": {
    "doc": "Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not Funcon implies Funcon and Funcon or Funcon exclusive-or Alias xor ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#booleans"
  },"80": {
    "doc": "Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Type integers-from Alias from Type integers-up-to Alias up-to Type bounded-integers Alias bounded-ints Type positive-integers Alias pos-ints Type negative-integers Alias neg-ints Type natural-numbers Alias nats Funcon natural-successor Alias nat-succ Funcon natural-predecessor Alias nat-pred Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-modulo Alias int-mod Funcon integer-power Alias int-pow Funcon integer-absolute-value Alias int-abs Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon binary-natural Alias binary Funcon octal-natural Alias octal Funcon decimal-natural Alias decimal Funcon hexadecimal-natural Alias hexadecimal Funcon integer-sequence ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#integers",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#integers"
  },"81": {
    "doc": "Funcons-Index",
    "title": "Floats",
    "content": "[ Datatype float-formats Funcon binary32 Funcon binary64 Funcon binary128 Funcon decimal64 Funcon decimal128 Type floats Funcon float Funcon quiet-not-a-number Alias qNaN Funcon signaling-not-a-number Alias sNaN Funcon positive-infinity Alias pos-inf Funcon negative-infinity Alias neg-inf Funcon float-convert Funcon float-equal Funcon float-is-less Funcon float-is-less-or-equal Funcon float-is-greater Funcon float-is-greater-or-equal Funcon float-negate Funcon float-absolute-value Funcon float-add Funcon float-subtract Funcon float-multiply Funcon float-multiply-add Funcon float-divide Funcon float-remainder Funcon float-sqrt Funcon float-integer-power Funcon float-float-power Funcon float-round-ties-to-even Funcon float-round-ties-to-infinity Funcon float-floor Funcon float-ceiling Funcon float-truncate Funcon float-pi Funcon float-e Funcon float-log Funcon float-log10 Funcon float-exp Funcon float-sin Funcon float-cos Funcon float-tan Funcon float-asin Funcon float-acos Funcon float-atan Funcon float-sinh Funcon float-cosh Funcon float-tanh Funcon float-asinh Funcon float-acosh Funcon float-atanh Funcon float-atan2 ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#floats",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#floats"
  },"82": {
    "doc": "Funcons-Index",
    "title": "Characters",
    "content": "[ Type characters Alias chars Datatype unicode-characters Alias unicode-chars Type unicode-points Funcon unicode-character Alias unicode-char Funcon unicode-point Alias unicode Type basic-multilingual-plane-characters Alias bmp-chars Type basic-multilingual-plane-points Type iso-latin-1-characters Alias latin-1-chars Type iso-latin-1-points Type ascii-characters Alias ascii-chars Type ascii-points Funcon ascii-character Alias ascii-char Funcon utf-8 Funcon utf-16 Funcon utf-32 Funcon backspace Funcon horizontal-tab Funcon line-feed Funcon form-feed Funcon carriage-return Funcon double-quote Funcon single-quote Funcon backslash ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#characters",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#characters"
  },"83": {
    "doc": "Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#the-null-value"
  },"84": {
    "doc": "Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#composite-values"
  },"85": {
    "doc": "Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon is-in Funcon first Funcon second Funcon third Funcon first-n Funcon drop-first-n Funcon reverse Funcon n-of Funcon intersperse ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#sequences-of-values"
  },"86": {
    "doc": "Funcons-Index",
    "title": "Datatypes",
    "content": "[ Funcon datatype-value Funcon datatype-value-id Funcon datatype-value-elements ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#datatypes",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#datatypes"
  },"87": {
    "doc": "Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements Funcon tuple-zip ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#tuples"
  },"88": {
    "doc": "Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list Funcon list-elements Funcon list-nil Alias nil Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail Funcon list-length Funcon list-append ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#lists",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#lists"
  },"89": {
    "doc": "Funcons-Index",
    "title": "Strings",
    "content": "[ Type strings Funcon string Funcon string-append Funcon to-string ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#strings",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#strings"
  },"90": {
    "doc": "Funcons-Index",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#vectors",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#vectors"
  },"91": {
    "doc": "Funcons-Index",
    "title": "Bits and bit vectors",
    "content": "[ Type bits Datatype bit-vectors Funcon bit-vector Type bytes Alias octets Funcon bit-vector-not Funcon bit-vector-and Funcon bit-vector-or Funcon bit-vector-xor Funcon bit-vector-shift-left Funcon bit-vector-logical-shift-right Funcon bit-vector-arithmetic-shift-right Funcon integer-to-bit-vector Funcon bit-vector-to-integer Funcon bit-vector-to-natural Funcon unsigned-bit-vector-maximum Funcon signed-bit-vector-maximum Funcon signed-bit-vector-minimum Funcon is-in-signed-bit-vector Funcon is-in-unsigned-bit-vector ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#bits-and-bit-vectors",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#bits-and-bit-vectors"
  },"92": {
    "doc": "Funcons-Index",
    "title": "Sets",
    "content": "[ Type sets Funcon set Funcon set-elements Funcon is-in-set Funcon is-subset Funcon set-insert Funcon set-unite Funcon set-intersect Funcon set-difference Funcon set-size Funcon some-element Funcon element-not-in ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#sets",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#sets"
  },"93": {
    "doc": "Funcons-Index",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-elements Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite Funcon map-delete ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#maps",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#maps"
  },"94": {
    "doc": "Funcons-Index",
    "title": "Multisets (bags)",
    "content": "[ Type multisets Funcon multiset Funcon multiset-elements Funcon multiset-occurrences Funcon multiset-insert Funcon multiset-delete Funcon is-submultiset ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#multisets-bags",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#multisets-bags"
  },"95": {
    "doc": "Funcons-Index",
    "title": "Trees",
    "content": "[ Datatype trees Funcon tree Funcon tree-root-value Funcon tree-branch-sequence Funcon single-branching-sequence Funcon forest-root-value-sequence Funcon forest-branch-sequence Funcon forest-value-sequence ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#trees",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#trees"
  },"96": {
    "doc": "Funcons-Index",
    "title": "Graphs",
    "content": "[ Type directed-graphs Funcon is-cyclic Funcon topological-sort ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#graphs",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#graphs"
  },"97": {
    "doc": "Funcons-Index",
    "title": "References and pointers",
    "content": "[ Datatype references Funcon reference Type pointers Funcon dereference ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#references-and-pointers",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#references-and-pointers"
  },"98": {
    "doc": "Funcons-Index",
    "title": "Records",
    "content": "[ Datatype records Funcon record Funcon record-map Funcon record-select ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#records",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#records"
  },"99": {
    "doc": "Funcons-Index",
    "title": "Variants",
    "content": "[ Datatype variants Funcon variant Funcon variant-id Funcon variant-value ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#variants",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#variants"
  },"100": {
    "doc": "Funcons-Index",
    "title": "Classes",
    "content": "[ Datatype classes Funcon class Funcon class-instantiator Funcon class-feature-map Funcon class-superclass-name-sequence Funcon class-name-tree Funcon is-subclass-name Funcon class-name-single-inheritance-feature-map ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#classes",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#classes"
  },"101": {
    "doc": "Funcons-Index",
    "title": "Objects",
    "content": "[ Datatype objects Funcon object Funcon object-identity Funcon object-class-name Funcon object-feature-map Funcon object-subobject-sequence Funcon object-tree Funcon object-single-inheritance-feature-map ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#objects",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#objects"
  },"102": {
    "doc": "Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#abstraction-values"
  },"103": {
    "doc": "Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Type abstractions Funcon abstraction Funcon closure Funcon enact ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#generic-abstractions"
  },"104": {
    "doc": "Funcons-Index",
    "title": "Thunks",
    "content": "[ Datatype thunks Funcon thunk Funcon force ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#thunks",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#thunks"
  },"105": {
    "doc": "Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply Funcon supply Funcon compose Funcon uncurry Funcon curry Funcon partial-apply ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#functions",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#functions"
  },"106": {
    "doc": "Funcons-Index",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon pattern-any Funcon pattern-bind Funcon pattern-type Funcon pattern-else Funcon pattern-unite Funcon match Funcon match-loosely Funcon case-match Funcon case-match-loosely Funcon case-variant-value ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html#patterns",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html#patterns"
  },"107": {
    "doc": "Funcons-Index",
    "title": "Funcons-Index",
    "content": "Funcons-beta : Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Types of computation | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Linking | Interacting . | Input | Output | . | . | Abnormal computation . | Terminating abruptly | Failing | Throwing | Returning | Breaking | Continuing | Controlling | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | Floats | Characters | The null value | . | Composite values . | Sequences of values | Datatypes | Tuples | Lists | Strings | Vectors | Bits and bit vectors | Sets | Maps | Multisets (bags) | Trees | Graphs | References and pointers | Records | Variants | Classes | Objects | . | Abstraction values . | Generic abstractions | Thunks | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Funcons-Index/index.html",
    "relUrl": "/docs/Funcons-beta/Funcons-Index/index.html"
  },"108": {
    "doc": "Functions",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply Funcon supply Funcon compose Funcon uncurry Funcon curry Funcon partial-apply ] . Meta-variables T, T&prime;, T1, T2 &lt;: values . Datatype functions(T,T&prime;) ::= function(A:abstractions(T=&gt;T&prime;)) . functions(T, T&prime;) consists of abstractions whose bodies may depend on a given value of type T, and whose executions normally compute values of type T&prime;. function(abstraction(X)) evaluates to a function with dynamic bindings, function(closure(X)) computes a function with static bindings. Funcon apply(_:functions(T, T&prime;), _:T) : =&gt;T&prime; . apply(F, V) applies the function F to the argument value V. This corresponds to call by value; using thunks as argument values corresponds to call by name. Moreover, using tuples as argument values corresponds to application to multiple arguments. Rule apply(function(abstraction(X)), V:T) ~&gt; give(V, X) . Funcon supply(_:functions(T, T&prime;), _:T) : =&gt;thunks(T&prime;) . supply(F, V) determines the argument value of a function application, but returns a thunk that defers executing the body of the function. Rule supply(function(abstraction(X)), V:T) ~&gt; thunk(abstraction(give(V, X))) . Funcon compose(_:functions(T2, T&prime;), _:functions(T1, T2)) : =&gt;functions(T1, T&prime;) . compose(F2, F1) returns the function that applies F1 to its argument, then applies F2 to the result of F1. Rule compose(function(abstraction(Y)), function(abstraction(X))) ~&gt; function(abstraction(give(X, Y))) . Funcon uncurry(F:functions(T1, functions(T2, T&prime;))) : =&gt;functions(tuples(T1, T2), T&prime;) ~&gt; function(abstraction( apply( apply(F, checked index(1, tuple-elements given)), checked index(2, tuple-elements given)))) . uncurry(F) takes a curried function F and returns a function that takes a pair of arguments.. Funcon curry(F:functions(tuples(T1, T2), T&prime;)) : =&gt;functions(T1, functions(T2, T&prime;)) ~&gt; function(abstraction(partial-apply(F, given))) . curry(F) takes a function F that takes a pair of arguments, and returns the corresponding ‘curried’ function. Funcon partial-apply(F:functions(tuples(T1, T2), T&prime;), V:T1) : =&gt;functions(T2, T&prime;) ~&gt; function(abstraction(apply(F,tuple(V,given)))) . partial-apply(F, V) takes a function F that takes a pair of arguments, and determines the first argument, returning a function of the second argument. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Functions/index.html#functions",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Functions/index.html#functions"
  },"109": {
    "doc": "Functions",
    "title": "Functions",
    "content": "Funcons-beta : Functions.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Functions/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Functions/index.html"
  },"110": {
    "doc": "Generic",
    "title": "Generic abstractions",
    "content": "[ Type abstractions Funcon abstraction Funcon closure Funcon enact ] . Meta-variables T &lt;: values T? &lt;: values? . Type abstractions(_:computation-types) . Funcon abstraction(_:T?=&gt;T) : abstractions(T?=&gt;T) . The funcon abstraction(X) forms abstraction values from computations. References to bindings of identifiers in X are dynamic. The funcon closure(X) forms abstractions with static bindings. Funcon closure(_:T?=&gt;T) : =&gt;abstractions(T?=&gt;T) . closure(X) computes a closed abstraction from the computation X. In contrast to abstraction(X), references to bindings of identifiers in X are static. Moreover, closure(X) is not a value constructor, so it cannot be used in pattern terms in rules. Rule environment(Rho) |- closure(X) ---&gt; abstraction(closed(scope(Rho, X))) . Funcon enact(_:abstractions(T?=&gt;T)) : T?=&gt;T . enact(A) executes the computation of the abstraction A, with access to all the current entities. Rule enact(abstraction(X)) ~&gt; X . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Generic/index.html#generic-abstractions",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Generic/index.html#generic-abstractions"
  },"111": {
    "doc": "Generic",
    "title": "Generic",
    "content": "Funcons-beta : Generic.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Generic/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Generic/index.html"
  },"112": {
    "doc": "Patterns",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon pattern-any Funcon pattern-bind Funcon pattern-type Funcon pattern-else Funcon pattern-unite Funcon match Funcon match-loosely Funcon case-match Funcon case-match-loosely Funcon case-variant-value ] . General patterns are simple patterns or structured patterns. Matching a pattern to a value either computes an environment or fails. Simple patterns are constructed from abstractions whose bodies depend on a given value, and whose executions either compute environments or fail. Structured patterns are composite values whose components may include simple patterns as well as other values. Matching a structured value to a structured pattern is similar to assigning a structured value to a structured variable, with simple pattern components matching component values analogously to simple variable components assigned component values. Note that patterns match only values, not (empty or proper) sequences. Meta-variables T, T&prime; &lt;: values . Simple patterns . Datatype patterns ::= pattern(_:abstractions(values=&gt;environments)) . patterns is the type of simple patterns that can match values of a particular type. pattern(abstraction(X)) constructs a pattern with dynamic bindings, and pattern(closure(X)) computes a pattern with static bindings. However, there is no difference between dynamic and static bindings when the pattern is matched in the same scope where it is constructed. Funcon pattern-any : =&gt;patterns ~&gt; pattern(abstraction(map( ))) . pattern-any matches any value, computing the empty environment. Funcon pattern-bind(I:identifiers) : =&gt;patterns ~&gt; pattern(abstraction(bind-value(I, given))) . pattern-bind(I) matches any value, computing the environment binding I to that value. Funcon pattern-type(T) : =&gt;patterns ~&gt; pattern(abstraction(if-true-else(is-in-type(given, T), map( ), fail))) . pattern-type(T) matches any value of type T, computing the empty environment. Funcon pattern-else(_:values, _:values) : =&gt;patterns Rule pattern-else(P1:values, P2:values) ~&gt; pattern(abstraction(else(match(given, P1), match(given, P2)))) . pattern-else(P1, P2) matches all values matched by P1 or by P2. If a value matches P1, that match gives the computed environment; if a value does not match P1 but matches P2, that match gives the computed environment; otherwise the match fails. Funcon pattern-unite(_:values, _:values) : =&gt;patterns Rule pattern-unite(P1:values, P2:values) ~&gt; pattern(abstraction(collateral(match(given, P1), match(given, P2)))) . pattern-unite(P1, P2) matches all values matched by both P1 and P2, then uniting the computed environments, which fails if the domains of the environments overlap. Pattern matching . Funcon match(_:values, _:values) : =&gt;environments . match(V, P) takes a (potentially structured) value V and a (potentially structured) pattern P. Provided that the structure and all components of P exactly match the structure and corresponding components of V, the environments computed by the simple pattern matches are united. Rule match(V:values, pattern(abstraction(X))) ~&gt; give(V, X) Rule I2 =/= \"pattern\" -------------------------------------------- match(datatype-value(I1:identifiers, V1*:values*), datatype-value(I2:identifiers, V2*:values*)) ~&gt; sequential( check-true(is-equal(I1, I2)), check-true(is-equal(length V1*, length V2*)), collateral(interleave-map( match(tuple-elements(given)), tuple-zip(tuple(V1*), tuple(V2*))))) Rule dom(M2) == {} ------------------------------------------------------ match(M1:maps(_,_), M2:maps(_,_)) ~&gt; if-true-else(is-equal(dom(M1), {}), map( ), fail) Rule dom(M2) =/= {} some-element(dom(M2)) ~&gt; K ------------------------------------------------------- match(M1:maps(_,_), M2:maps(_,_)) ~&gt; if-true-else( is-in-set(K, dom(M1)), collateral( match(map-lookup(M1, K), map-lookup(M2, K)), match(map-delete(M1, {K}), map-delete(M2, {K}))), fail) Rule P : ~(datatype-values|maps(_,_)) ----------------------------------------------- match(V:values, P:values) ~&gt; if-true-else(is-equal(V, P), map( ), fail) . Funcon match-loosely(_:values, _:values) : =&gt;environments . match-loosely(V, P) takes a (potentially structured) value V and a (potentially structured) pattern P. Provided that the structure and all components of P loosely match the structure and corresponding components of V, the environments computed by the simple pattern matches are united. Rule match-loosely(V:values, pattern(abstraction(X))) ~&gt; give(V, X) Rule I2 =/= \"pattern\" --------------------------------------------------- match-loosely(datatype-value(I1:identifiers, V1*:values*), datatype-value(I2:identifiers, V2*:values*)) ~&gt; sequential( check-true(is-equal(I1, I2)), check-true(is-equal(length V1*, length V2*)), collateral(interleave-map( match-loosely(tuple-elements(given)), tuple-zip(tuple(V1*), tuple(V2*))))) Rule dom(M2) == {} ------------------------------------------------- match-loosely(M1:maps(_,_), M2:maps(_,_)) ~&gt; map() Rule dom(M2) =/= {} some-element(dom(M2)) ~&gt; K -------------------------------------------------------------- match-loosely(M1:maps(_,_), M2:maps(_,_)) ~&gt; if-true-else( is-in-set(K, dom(M1)), collateral( match-loosely(map-lookup(M1, K), map-lookup(M2, K)), match-loosely(map-delete(M1, {K}), map-delete(M2, {K}))), fail) Rule P : ~(datatype-values|maps(_,_)) ------------------------------------------- match-loosely(DV:values, P:values) ~&gt; if-true-else(is-equal(DV, P), map( ), fail) . Funcon case-match(_:values, _:=&gt;T&prime;) : =&gt;T&prime; . case-match(P, X) matches P exactly to the given value. If the match succeeds, the computed bindings have scope X. Rule case-match(P:values, X) ~&gt; scope(match(given, P), X) . Funcon case-match-loosely(_:values, _:=&gt;T&prime;) : =&gt;T&prime; . case-match(P, X) matches P loosely to the given value. If the match succeeds, the computed bindings have scope X. Rule case-match-loosely(P:values, X) ~&gt; scope(match-loosely(given, P), X) . Funcon case-variant-value(_:identifiers) : =&gt;values . case-variant-value(I) matches values of variant I, then giving the value contained in the variant. Rule case-variant-value(I:identifiers) ~&gt; case-match(variant(I, pattern-any), variant-value(given)) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Patterns/index.html#patterns",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Patterns/index.html#patterns"
  },"113": {
    "doc": "Patterns",
    "title": "Patterns",
    "content": "Funcons-beta : Patterns.cbs | PRETTY | PDF . Outline . | Patterns . | Simple patterns | Pattern matching | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Patterns/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Patterns/index.html"
  },"114": {
    "doc": "Thunks",
    "title": "Thunks",
    "content": "[ Datatype thunks Funcon thunk Funcon force ] . Meta-variables T &lt;: values . Datatype thunks(T) ::= thunk(_:abstractions(()=&gt;T)) . thunks(T) consists of abstractions whose bodies do not depend on a given value, and whose executions normally compute values of type T. thunk(abstraction(X)) evaluates to a thunk with dynamic bindings, thunk(closure(X)) computes a thunk with static bindings. Funcon force(_:thunks(T)) : =&gt;T . force(H) enacts the abstraction of the thunk H. Rule force(thunk(abstraction(X))) ~&gt; no-given(X) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Thunks/index.html#thunks",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Thunks/index.html#thunks"
  },"115": {
    "doc": "Thunks",
    "title": "Thunks",
    "content": "Funcons-beta : Thunks.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/Thunks/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/Thunks/index.html"
  },"116": {
    "doc": "Abstraction",
    "title": "Abstraction",
    "content": "Abstraction values are formed by a constructor with an unevaluated computation argument. Enacting an abstraction value executes its computation argument – potentially in a different context from that where the abstraction was constructed. Constructed abstraction values thus naturally have dynamic scopes for bindings. To obtain static scopes, it is necessary to explicitly compute a closure value. The closure value computed from an abstraction value is an abstraction whose computation argument provides the current bindings to the original unevaluated computation argument. The funcon that computes closures cannot be a constructor, since the resulting value depends on the current bindings. Although abstractions are essentially procedural, they can also be used to represent potentially infinite data. However, they are not ground values, and cannot be tested for equality. Abstractions values corresponding to procedural abstractions Thunks values formed from abstractions not referencing any given value Functions values formed from abstractions referencing a single given value Patterns values formed from abstractions matching a single given value ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Abstraction/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Abstraction/index.html"
  },"117": {
    "doc": "Bits",
    "title": "Bits and bit vectors",
    "content": "[ Type bits Datatype bit-vectors Funcon bit-vector Type bytes Alias octets Funcon bit-vector-not Funcon bit-vector-and Funcon bit-vector-or Funcon bit-vector-xor Funcon bit-vector-shift-left Funcon bit-vector-logical-shift-right Funcon bit-vector-arithmetic-shift-right Funcon integer-to-bit-vector Funcon bit-vector-to-integer Funcon bit-vector-to-natural Funcon unsigned-bit-vector-maximum Funcon signed-bit-vector-maximum Funcon signed-bit-vector-minimum Funcon is-in-signed-bit-vector Funcon is-in-unsigned-bit-vector ] . Bits . Type bits ~&gt; booleans . false represents the absence of a bit, true its presence. Bit vectors . Datatype bit-vectors(N:natural-numbers) ::= bit-vector(_:bits^N) . Type bytes ~&gt; bit-vectors(8) Alias octets = bytes . Meta-variables BT &lt;: bit-vectors(_) . Built-in Funcon bit-vector-not(_:BT) : =&gt;BT . Built-in Funcon bit-vector-and(_:BT, _:BT) : =&gt;BT . Built-in Funcon bit-vector-or(_:BT, _:BT) : =&gt;BT . Built-in Funcon bit-vector-xor(_:BT, _:BT) : =&gt;BT . The above four funcons are the natural extensions of funcons from booleans to bit-vectors(N) of the same length. Built-in Funcon bit-vector-shift-left(_:BT, _:natural-numbers) : BT . Built-in Funcon bit-vector-logical-shift-right(_:BT, _:natural-numbers) : BT . Built-in Funcon bit-vector-arithmetic-shift-right(_:BT, _:natural-numbers) : BT . Built-in Funcon integer-to-bit-vector(_:integers, N:natural-numbers) : bit-vectors(N) . integer-to-bit-vector(M, N) converts an integer M to a bit-vector of length N, using Two’s Complement representation. If the integer is out of range of the representation, it will wrap around (modulo 2^N). Built-in Funcon bit-vector-to-integer(_:BT) : =&gt;integers . bit-vector-to-integer(B) interprets a bit-vector BV as an integer in Two’s Complement representation. Built-in Funcon bit-vector-to-natural(_:BT) : =&gt;natural-numbers . bit-vector-to-natural(BV) interprets a bit-vector BV as a natural number in unsigned representation. Funcon unsigned-bit-vector-maximum(N:natural-numbers) : =&gt;natural-numbers ~&gt; integer-subtract(integer-power(2, N), 1) . Funcon signed-bit-vector-maximum(N:natural-numbers) : =&gt;integers ~&gt; integer-subtract(integer-power(2, integer-subtract(N, 1)), 1) . Funcon signed-bit-vector-minimum(N:natural-numbers) : =&gt;integers ~&gt; integer-negate(integer-power(2, integer-subtract(N, 1))) . Funcon is-in-signed-bit-vector(M:integers, N:natural-numbers) : =&gt;booleans ~&gt; and(integer-is-less-or-equal(M, signed-bit-vector-maximum(N)), integer-is-greater-or-equal(M, signed-bit-vector-minimum(N))) . Funcon is-in-unsigned-bit-vector(M:integers, N:natural-numbers) : =&gt;booleans ~&gt; and(integer-is-less-or-equal(M, unsigned-bit-vector-maximum(N)), integer-is-greater-or-equal(M, 0)) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Bits/index.html#bits-and-bit-vectors",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Bits/index.html#bits-and-bit-vectors"
  },"118": {
    "doc": "Bits",
    "title": "Bits",
    "content": "Funcons-beta : Bits.cbs | PRETTY | PDF . Outline . | Bits and bit vectors . | Bits | Bit vectors | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Bits/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Bits/index.html"
  },"119": {
    "doc": "Classes",
    "title": "Classes",
    "content": "[ Datatype classes Funcon class Funcon class-instantiator Funcon class-feature-map Funcon class-superclass-name-sequence Funcon class-name-tree Funcon is-subclass-name Funcon class-name-single-inheritance-feature-map ] . Datatype classes ::= class(_:thunks(references(objects)), _:environments, _:identifiers*) . class(Thunk, Env, C*) is a class with: . | a thunk Thunk for instantiating the class, | an environment Env with the features declared by the class, and | a sequence C* of names of direct superclasses. class(Thunk, Env) is a base class, having no superclasses. class(Thunk, Env, C) is a class with a single superclass. | . Class instantiation forces its thunk to compute a reference to an object. Features are inherited from superclasses. When features with the same name are declared in simultaneously inherited classes, the order of the superclass identifiers in C* may affect resolution of references to features. Overloading of feature names is supported by using type maps as features. The class table is represented by binding class names to classes. The class superclass hierarchy is assumed to be acyclic. Funcon class-instantiator(_:classes) : =&gt;thunks(references(objects)) Rule class-instantiator class(Thunk:thunks(_), Envs:environments, C*:identifiers*) ~&gt; Thunk . Funcon class-feature-map(_:classes) : =&gt;environments Rule class-feature-map class(Thunk:thunks(_), Env:environments, C*:identifiers*) ~&gt; Env . Funcon class-superclass-name-sequence(_:classes) : =&gt;identifiers* Rule class-superclass-name-sequence class(Thunk:thunks(_), Env:environments, C*:identifiers*) ~&gt; C* . Funcon class-name-tree(_:identifiers) : =&gt;trees(identifiers) . class-name-tree C forms a tree where the branches are the class name trees for the superclasses of C. Rule class-name-tree(C : identifiers) ~&gt; tree(C, interleave-map( class-name-tree given, class-superclass-name-sequence bound-value C)) . Funcon is-subclass-name(C:identifiers, C&prime;:identifiers) : =&gt;booleans ~&gt; is-in-set(C, { forest-value-sequence class-name-tree C&prime; }) . The result of is-subclass-name(C, C&prime;) does not depend on the order of the names in forest-value-sequence class-name-tree C&prime;. Funcon class-name-single-inheritance-feature-map(C:identifiers) : =&gt;environments ~&gt; map-override interleave-map( class-feature-map bound-value given, single-branching-sequence class-name-tree C) . For multiple inheritance, different resolution orders can be specified by using different linearisations of the class name tree. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Classes/index.html#classes",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Classes/index.html#classes"
  },"120": {
    "doc": "Classes",
    "title": "Classes",
    "content": "Funcons-beta : Classes.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Classes/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Classes/index.html"
  },"121": {
    "doc": "Datatypes",
    "title": "Datatypes",
    "content": "[ Type datatype-values Funcon datatype-value Funcon datatype-value-id Funcon datatype-value-elements ] . A datatype value consists of an identifier and a sequence of values. ‘Datatype T ::= …’ declares the type T to refer to a fresh value constructor in types, and asserts T &lt;: datatype-values. Each constructor funcon ‘F(_:T_1,…,_:T_n)’ of the datatype declaration generates values in T of the form datatype-value(\"F\", V_1, ..., V_n) from V_1:T_1, …, V_n:T_n. Note that a computation X cannot be directly included in datatype values: it is necessary to encapsulate it in abstraction(X). ‘Datatype T’, followed by declarations of constructor funcons for ‘T’, allows specification of GADTs. Built-in Type datatype-values . Built-in Funcon datatype-value(_:identifiers, _:values*) : datatype-values . Funcon datatype-value-id(_:datatype-values) : =&gt;identifiers Rule datatype-value-id(datatype-value(I:identifiers, _*:values*)) ~&gt; I . Funcon datatype-value-elements(_:datatype-values) : =&gt;values* Rule datatype-value-elements(datatype-value(_:identifiers, V*:values*)) ~&gt; V* . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Datatypes/index.html#datatypes",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Datatypes/index.html#datatypes"
  },"122": {
    "doc": "Datatypes",
    "title": "Datatypes",
    "content": "Funcons-beta : Datatypes.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Datatypes/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Datatypes/index.html"
  },"123": {
    "doc": "Graphs",
    "title": "Graphs",
    "content": "[ Type directed-graphs Funcon is-cyclic Funcon topological-sort ] . Meta-variables GT &lt;: ground-values . Type directed-graphs(GT) ~&gt; maps(GT, sets(GT)) . directed-graphs(GT) models directed graphs with vertices of type GT, represented as maps from vertices to the set of vertices to which the vertex has an edge. E.g., the graph . (1)---&gt;(2) . would be represented as { 1 |-&gt; {2}, 2 |-&gt; {} } . Built-in Funcon is-cyclic(_:directed-graphs(GT)) : =&gt;booleans . Built-in Funcon topological-sort(_:directed-graphs(GT)) : =&gt;(GT)* . topological-sort(DG) returns a topological ordering of the vertices of the graph DG, as a sequence of vertices, provided that DG is not cyclic. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Graphs/index.html#graphs",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Graphs/index.html#graphs"
  },"124": {
    "doc": "Graphs",
    "title": "Graphs",
    "content": "Funcons-beta : Graphs.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Graphs/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Graphs/index.html"
  },"125": {
    "doc": "Lists",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list Funcon list-elements Funcon list-nil Alias nil Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail Funcon list-length Funcon list-append ] . Meta-variables T &lt;: values . Datatype lists(T) ::= list(_:(T)*) . lists(T) is the type of possibly-empty finite lists [V_1,...,V_n] where V_1:T, …, V_n:T. N.B. [T] is always a single list value, and not interpreted as the type lists(T). The notation [V_1, ..., V_n] for list(V_1, ..., V_n) is built-in. Assert [V*:values*] == list(V*) . Funcon list-elements(_:lists(T)) : =&gt;(T)* Rule list-elements(list(V*:values*)) ~&gt; V* . Funcon list-nil : =&gt;lists(_) ~&gt; [ ] Alias nil = list-nil . Funcon list-cons(_:T, _:lists(T)) : =&gt;lists(T) Alias cons = list-cons . Rule list-cons(V:values, [V*:values*]) ~&gt; [V, V*] . Funcon list-head(_:lists(T)) : =&gt;(T)? Alias head = list-head . Rule list-head[V:values, _*:values*] ~&gt; V Rule list-head[ ] ~&gt; ( ) . Funcon list-tail(_:lists(T)) : =&gt;(lists(T))? Alias tail = list-tail . Rule list-tail[_:values, V*:values*] ~&gt; [V*] Rule list-tail[ ] ~&gt; ( ) . Funcon list-length(_:lists(T)) : =&gt;natural-numbers Rule list-length[V*:values*] ~&gt; length(V*) . Funcon list-append(_:(lists(T))*) : =&gt;lists(T) Rule list-append([V1*:values*], [V2*:values*]) ~&gt; [V1*, V2*] Rule list-append(L1:lists(_), L2:lists(_), L3:lists(_), L*:(lists(_))*) ~&gt; list-append(L1, list-append(L2, L3, L*)) Rule list-append( ) ~&gt; [ ] Rule list-append(L:lists(_)) ~&gt; L . Datatypes of infinite and possibly-infinite lists can be specified as algebraic datatypes using abstractions. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Lists/index.html#lists",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Lists/index.html#lists"
  },"126": {
    "doc": "Lists",
    "title": "Lists",
    "content": "Funcons-beta : Lists.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Lists/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Lists/index.html"
  },"127": {
    "doc": "Maps",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-elements Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite Funcon map-delete ] . Meta-variables GT &lt;: ground-values T? &lt;: values? . Built-in Type maps(GT, T?) . maps(GT, T?) is the type of possibly-empty finite maps from values of type GT to optional values of type T?. Built-in Funcon map(_:(tuples(GT, T?))*) : =&gt;(maps(GT, T?))? . map(tuple(K_1, V_1?), ..., tuple(K_n, V_n?)) constructs a map from K_1 to V_1?, …, K_n to V_n?, provided that K_1, …, K_n are distinct, otherwise the result is ( ). Note that map(...) is not a constructor operation. The built-in notation {K_1|-&gt;V_1?, ..., K_n|-&gt;V_n?} is equivalent to map(tuple(K_1, V_1?), ..., tuple(K_n, V_n?)). Note however that in general, maps cannot be identified with sets of tuples, since the values V_i? are not restricted to ground-values. When T? &lt;: types, maps(GT, T?) &lt;: types. The type MT:maps(GT, T?) represents the set of value-maps MV:maps(GT, values?) such that dom(MV) is a subset of dom(MT) and for all K in dom(MV), map-lookup(MV, K) : map-lookup(MT, K). Built-in Funcon map-elements(_:maps(GT, T?)) : =&gt;(tuples(GT, T?))* . The sequence of tuples (tuple(K_1, V_1?), ..., tuple(K_n, V_n?)) given by map-elements(M) contains each mapped value K_i just once. The order of the elements is unspecified, and may vary between maps. Assert map(map-elements(M)) == M . Built-in Funcon map-lookup(_:maps(GT, T?), K:GT) : =&gt;(T?)? Alias lookup = map-lookup . map-lookup(M,K) gives the optional value to which K is mapped by M, if any, and otherwise ( ). Built-in Funcon map-domain(_:maps(GT, T?)) : =&gt;sets(GT) Alias dom = map-domain . map-domain(M) gives the set of values mapped by M. map-lookup(M, K) is always ( ) when K is not in map-domain(M). Built-in Funcon map-override(_:(maps(GT, T?))*) : =&gt;maps(GT,T?) . map-override(...) takes a sequence of maps. It returns the map whose domain is the union of their domains, and which maps each of those values to the same optional value as the first map in the sequence in whose domain it occurs . When the domains of the M* are disjoint, map-override(M*) is equivalent to map-unite(M*). Built-in Funcon map-unite(_:(maps(GT, T?))*) : =&gt;(maps(GT, T?))? . map-unite(...) takes a sequence of maps. It returns the map whose domain is the union of their domains, and which maps each of those values to the same optional value as the map in the sequence in whose domain it occurs, provided that those domains are disjoint - otherwise the result is ( ). Built-in Funcon map-delete(_:maps(GT, T?), _:sets(GT)) : =&gt;maps(GT, T?) . map-delete(M, S) takes a map M and a set of values S, and returns the map obtained from M by removing S from its domain. Assert map-domain(map-delete(M, S)) == set-difference(map-domain(M), S) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Maps/index.html#maps",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Maps/index.html#maps"
  },"128": {
    "doc": "Maps",
    "title": "Maps",
    "content": "Funcons-beta : Maps.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Maps/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Maps/index.html"
  },"129": {
    "doc": "Multisets",
    "title": "Multisets (bags)",
    "content": "[ Type multisets Funcon multiset Funcon multiset-elements Funcon multiset-occurrences Funcon multiset-insert Funcon multiset-delete Funcon is-submultiset ] . Meta-variables GT &lt;: ground-values . Built-in Type multisets(GT) . multisets(GT) is the type of possibly-empty finite multisets of elements of GT. Built-in Funcon multiset(_:(GT)*) : =&gt;multisets(GT) . Note that multiset(...) is not a constructor operation. The order of argument values is ignored, but duplicates are significant, e.g., multiset(1, 2, 2) is equivalent to multiset(2, 1, 2), but not to multiset(1, 2) or multiset(2, 1). Built-in Funcon multiset-elements(_:multisets(GT)) : =&gt;(GT)* . For each multiset MS, the sequence of values V* returned by multiset-elements(MS) contains each element of MS the same number of times as MS does. The order of the values in V* is unspecified, and may vary between multisets. Assert multiset(multiset-elements(S)) == S . Built-in Funcon multiset-occurrences(_:GT, _:multisets(GT)) : =&gt;natural-numbers . multiset-occurrences(GV, MS) returns the number of occurrences of GV in MS. Built-in Funcon multiset-insert(_:GT, _:natural-numbers, _:multisets(GT)) : =&gt;multisets(GT) . multiset-insert(GV, N, MS) returns the multiset that differs from MS by containing N more copies of GV. Built-in Funcon multiset-delete(_:multisets(GT), _:GT, _:natural-numbers) : =&gt;multisets(GT) . multiset-delete(MS, GV, N) removes N copies of V from the multiset MS, or all copies of GV if there are fewer than N in MS. Built-in Funcon is-submultiset(_:multisets(GT), _:multisets(GT)) : =&gt;booleans . is-submultiset(MS1, MS2) tests whether every element of MS1 has equal or fewer occurrences in MS1 than in MS2. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Multisets/index.html#multisets-bags",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Multisets/index.html#multisets-bags"
  },"130": {
    "doc": "Multisets",
    "title": "Multisets",
    "content": "Funcons-beta : Multisets.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Multisets/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Multisets/index.html"
  },"131": {
    "doc": "Objects",
    "title": "Objects",
    "content": "[ Datatype objects Funcon object Funcon object-identity Funcon object-class-name Funcon object-feature-map Funcon object-subobject-sequence Funcon object-tree Funcon object-single-inheritance-feature-map ] . Datatype objects ::= object(_:atoms, _:identifiers, _:environments, _:objects*) . object( A, C, Env, O*) is an object: . | distinguished by an atom A, | of a class named C, | with an environment Env with the features of the object, and | a sequence O* of subobjects of the direct superclasses of C. object( A, C, Env) is an object of a base class. object( A, C, Env, O&prime;) is an object of a class with a single superclass. With multiple inheritance, subobjects due to repeated inheritance of the same class may be shared. | . Implementations of objects generally represent an object as a vector of fields, and use pointers and offsets for efficient access to individual fields. The representation of objects used in this specification is independent of such implementation concerns. Funcon object-identity(_:objects) : =&gt;atoms Rule object-identity object(A:atoms, _:identifiers, _:environments, _*:objects*) ~&gt; A . Funcon object-class-name(_:objects) : =&gt;identifiers Rule object-class-name object(_:atoms, C:identifiers, _:environments, _*:objects*) ~&gt; C . Funcon object-feature-map(_:objects) : =&gt;environments Rule object-feature-map object(_:atoms, _:identifiers, Env:environments, _*:objects*) ~&gt; Env . Funcon object-subobject-sequence(_:objects) : =&gt;objects* Rule object-subobject-sequence object(_:atoms, _:identifiers, _:environments, O*:objects*) ~&gt; O* . Funcon object-tree(_:objects) : =&gt;trees(objects) . object-tree O forms a tree where the branches are the object trees for the direct subobjects of O. Rule object-tree(O:objects) ~&gt; tree(O, interleave-map ( object-tree given, object-subobject-sequence O)) . Funcon object-single-inheritance-feature-map(O:objects) : =&gt;environments ~&gt; map-override left-to-right-map( object-feature-map given, single-branching-sequence object-tree O) . For multiple inheritance, different resolution orders can be specified by using difference linearisations of the object tree. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Objects/index.html#objects",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Objects/index.html#objects"
  },"132": {
    "doc": "Objects",
    "title": "Objects",
    "content": "Funcons-beta : Objects.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Objects/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Objects/index.html"
  },"133": {
    "doc": "Records",
    "title": "Records",
    "content": "[ Datatype records Funcon record Funcon record-map Funcon record-select ] . Meta-variables T &lt;: values . Datatype records(T) ::= record(_:maps(identifiers,T)) . A value of type records(T) contains a map from identifiers to values of type T. Funcon record-map(_:records(T)) : =&gt;maps(identifiers,T) Rule record-map(record(M:maps(_,_))) ~&gt; M . Funcon record-select(R:records(T), I:identifiers) : =&gt;T? ~&gt; map-lookup(record-map(R), I) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Records/index.html#records",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Records/index.html#records"
  },"134": {
    "doc": "Records",
    "title": "Records",
    "content": "Funcons-beta : Records.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Records/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Records/index.html"
  },"135": {
    "doc": "References",
    "title": "References and pointers",
    "content": "[ Datatype references Funcon reference Type pointers Funcon pointer-null Funcon dereference ] . Meta-variables T &lt;: values . Datatype references(T) ::= reference(_:T) . Datatype pointers(T) ::= pointer-null | { _:references(T) } . Funcon dereference(_:pointers(T)) : =&gt;(T)? Rule dereference(reference(V:T)) ~&gt; V Rule dereference(pointer-null) ~&gt; ( ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/References/index.html#references-and-pointers",
    "relUrl": "/docs/Funcons-beta/Values/Composite/References/index.html#references-and-pointers"
  },"136": {
    "doc": "References",
    "title": "References",
    "content": "Funcons-beta : References.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/References/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/References/index.html"
  },"137": {
    "doc": "Sequences",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon is-in Funcon first Funcon second Funcon third Funcon first-n Funcon drop-first-n Funcon reverse Funcon n-of Funcon intersperse ] . Sequences of two or more values are not themselves values, nor is the empty sequence a value. However, sequences can be provided to funcons as arguments, and returned as results. Many operations on composite values can be expressed by extracting their components as sequences, operating on the sequences, then forming the required composite values from the resulting sequences. A sequence with elements X_1, …, X_n is written X_1,...,X_n. A sequence with a single element X is identified with (and written) X. An empty sequence is indicated by the absence of a term. Any sequence X* can be enclosed in parentheses (X*), e.g.: ( ), (1), (1,2,3). Superfluous commas are ignored. The elements of a type sequence T_1,...,T_n are the value sequences V_1,...,V_n where V_1:T_1, …, V_n:T_n. The only element of the empty type sequence ( ) is the empty value sequence ( ). (T)^N is equivalent to T,...,T with N occurrences of T. (T)* is equivalent to the union of all (T)^N for N&gt;=0, (T)+ is equivalent to the union of all (T)^N for N&gt;=1, and (T)? is equivalent to T | ( ). The parentheses around T above can be omitted when they are not needed for disambiguation. (Non-trivial) sequence types are not values, so not included in types. Meta-variables T, T&prime; &lt;: values . Funcon length(_:values*) : =&gt;natural-numbers . length(V*) gives the number of elements in V*. Rule length( ) ~&gt; 0 Rule length(V:values, V*:values*) ~&gt; natural-successor(length(V*)) . Funcon is-in(_:values, _:values*) : =&gt;booleans Rule is-in(V:values ,V&prime;:values, V*:values*) ~&gt; or(is-equal(V, V&prime;), is-in(V, V*)) Rule is-in(V:values, ( )) ~&gt; false . Sequence indexing . Funcon index(_:natural-numbers, _:values*) : =&gt;values? . index(N, V*) gives the Nth element of V*, if it exists, otherwise ( ). Rule index(1, V:values, V*:values*) ~&gt; V Rule natural-predecessor(N) ~&gt; N&prime; ----------------------------------------------------------------- index(N:positive-integers, _:values, V*:values*) ~&gt; index(N&prime;, V*) Rule index(0, V*:values*) ~&gt; ( ) Rule index(_:positive-integers, ( )) ~&gt; ( ) . Total indexing funcons: . Funcon first(_:T, _:values*) : =&gt;T Rule first(V:T, V*:values*) ~&gt; V . Funcon second(_:values, _:T, _:values*) : =&gt;T Rule second(_:values, V:T, V*:values*) ~&gt; V . Funcon third(_:values, _:values, _:T, _:values*) : =&gt;T Rule third(_:values, _:values, V:T, V*:values*) ~&gt; V . Homogeneous sequences . Funcon first-n(_:natural-numbers, _:(T)*) : =&gt;(T)* Rule first-n(0, V*:(T)*) ~&gt; ( ) Rule natural-predecessor(N) ~&gt; N&prime; ----------------------------------------------------------------- first-n(N:positive-integers, V:T, V*:(T)*) ~&gt; (V,first-n(N&prime;, V*)) Rule first-n(N:positive-integers, ( )) ~&gt; ( ) . Funcon drop-first-n(_:natural-numbers, _:(T)*) : =&gt;(T)* Rule drop-first-n(0, V*:(T)*) ~&gt; V* Rule natural-predecessor(N) ~&gt; N&prime; ----------------------------------------------------------------------- drop-first-n(N:positive-integers, _:T, V*:(T)*) ~&gt; drop-first-n(N&prime;, V*) Rule drop-first-n(N:positive-integers, ( )) ~&gt; ( ) . Funcon reverse(_:(T)*) : =&gt;(T)* Rule reverse( ) ~&gt; ( ) Rule reverse(V:T, V*:(T)*) ~&gt; (reverse(V*), V) . Funcon n-of(N:natural-numbers, V:T) : =&gt;(T)* Rule n-of(0, _:T) ~&gt; ( ) Rule natural-predecessor(N) ~&gt; N&prime; -------------------------------------------------- n-of(N:positive-integers, V:T) ~&gt; (V, n-of(N&prime;, V)) . Funcon intersperse(_:T&prime;, _:(T)*) : =&gt;(T, (T&prime;, T)*)? Rule intersperse(_:T&prime;, ( )) ~&gt; ( ) Rule intersperse(_:T&prime;, V) ~&gt; V Rule intersperse(V&prime;:T&prime;, V1:T, V2:T, V*:(T)*) ~&gt; (V1, V&prime;, intersperse(V&prime;, V2, V*)) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Sequences/index.html#sequences-of-values",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Sequences/index.html#sequences-of-values"
  },"138": {
    "doc": "Sequences",
    "title": "Sequences",
    "content": "Funcons-beta : Sequences.cbs | PRETTY | PDF . Outline . | Sequences of values . | Sequence indexing | Homogeneous sequences | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Sequences/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Sequences/index.html"
  },"139": {
    "doc": "Sets",
    "title": "Sets",
    "content": "[ Type sets Funcon set Funcon set-elements Funcon is-in-set Funcon is-subset Funcon set-insert Funcon set-unite Funcon set-intersect Funcon set-difference Funcon set-size Funcon some-element Funcon element-not-in ] . Meta-variables GT &lt;: ground-values . Built-in Type sets(GT) . sets(GT) is the type of possibly-empty finite sets {V_1, ..., V_n} where V_1:GT, …, V_n:GT. Built-in Funcon set(_:(GT)*) : =&gt;sets(GT) . The notation {V_1, ..., V_n} for set(V_1, ..., V_n) is built-in. Assert {V*:(GT)*} == set(V*) . Note that set(...) is not a constructor operation. The order and duplicates of argument values are ignored (e.g., {1,2,1} denotes the same set as {1,2} and {2,1}). Built-in Funcon set-elements(_:sets(GT)) : =&gt;(GT)* . For each set S, the sequence of values V* returned by set-elements(S) contains each element of S just once. The order of the values in V* is unspecified, and may vary between sets (e.g., set-elements{1,2} could be (1,2) and set-elements{1,2,3} could be (3,2,1)). Assert set(set-elements(S)) == S . Built-in Funcon is-in-set(_:GT, _:sets(GT)) : =&gt;booleans . is-in-set(GV,S) tests whether GV is in the set S. Assert is-in-set(GV:GT, { }) == false Assert is-in-set(GV:GT, {GV}:sets(GT)) == true . Built-in Funcon is-subset(_:sets(GT), _:sets(GT)) : =&gt;booleans . is-subset(S1,S2) tests whether S1 is a subset of S2. Assert is-subset({ }, S:sets(GT)) == true Assert is-subset(S:sets(GT), S) == true . Built-in Funcon set-insert(_:GT, _:sets(GT)) : =&gt;sets(GT) . set-insert(GV, S) returns the set union of {GV} and S. Assert is-in-set(GV:GT, set-insert(GV:GT, S:sets(GT))) == true . Built-in Funcon set-unite(_:(sets(GT))*) : =&gt;sets(GT) . set-unite(...) unites a sequence of sets. Assert set-unite(S:sets(GT), S) == S Assert set-unite(S1:sets(GT), S2:sets(GT)) == set-unite(S2, S1) Assert set-unite(S1:sets(GT), set-unite(S2:sets(GT), S3:sets(GT))) == set-unite(set-unite(S1, S2), S3) Assert set-unite(S1:sets(GT), S2:sets(GT), S3:sets(GT)) == set-unite(S1, set-unite(S2, S3)) Assert set-unite(S:sets(GT)) == S Assert set-unite( ) == { } . Built-in Funcon set-intersect(_:(sets(GT))+) : =&gt;sets(GT) . set-intersect(GT,...) intersects a non-empty sequence of sets. Assert set-intersect(S:sets(GT), S) == S Assert set-intersect(S1:sets(GT), S2:sets(GT)) == set-intersect(S2, S1) Assert set-intersect(S1:sets(GT), set-intersect(S2:sets(GT), S3:sets(GT))) == set-intersect(set-intersect(S1, S2), S3) Assert set-intersect(S1:sets(GT), S2:sets(GT), S3:sets(GT)) == set-intersect(S1, set-intersect(S2, S3)) Assert set-intersect(S:sets(GT)) == S . Built-in Funcon set-difference(_:sets(GT), _:sets(GT)) : =&gt;sets(GT) . set-difference(S1, S2) returns the set containing those elements of S1 that are not in S2. Built-in Funcon set-size(_:sets(GT)) : =&gt;natural-numbers . Assert set-size(S:sets(GT)) == length(set-elements(S)) . Funcon some-element(_:sets(GT)) : =&gt;GT? Assert some-element(S:sets(GT)) == index(1, set-elements(S)) Assert some-element{ } == ( ) . Built-in Funcon element-not-in(GT:types, _:set(GT)) : =&gt;GT? . element-not-in(GT, S) gives an element of the type GT not in the set S, or ( ) when S is empty. When the set of elements of GT is infinite, element-not-in(GT, S) never gives ( ). | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Sets/index.html#sets",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Sets/index.html#sets"
  },"140": {
    "doc": "Sets",
    "title": "Sets",
    "content": "Funcons-beta : Sets.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Sets/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Sets/index.html"
  },"141": {
    "doc": "Strings",
    "title": "Strings",
    "content": "[ Type strings Funcon string Funcon string-append Funcon to-string ] . Type strings ~&gt; lists(characters) . Funcon string(C*:characters*) : =&gt;strings ~&gt; [C*] . Literal strings are written \"C_1...C_n\". A double-quote or backslash needs to be escaped: \"...\\\\\\\"...\", \"...\\\\\\\\...\". Funcon string-append(S*:strings*) : =&gt;strings ~&gt; list-append(S*) . Built-in Funcon to-string(_:ground-values) : =&gt;strings . The strings returned by to-string(GV) are unspecified, except that when GV is already a string, it is returned unchanged. Assert to-string(S:strings) == S . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Strings/index.html#strings",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Strings/index.html#strings"
  },"142": {
    "doc": "Strings",
    "title": "Strings",
    "content": "Funcons-beta : Strings.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Strings/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Strings/index.html"
  },"143": {
    "doc": "Trees",
    "title": "Trees",
    "content": "[ Datatype trees Funcon tree Funcon tree-root-value Funcon tree-branch-sequence Funcon single-branching-sequence Funcon forest-root-value-sequence Funcon forest-branch-sequence Funcon forest-value-sequence ] . Meta-variables T &lt;: values . Datatype trees(T) ::= tree( _:T, _:(trees(T))*) . trees(T) consists of finitely-branching trees with elements of type T. When V:T, tree(V) is a leaf, and tree(V,B_1,...,B_n) is a tree with branches B_1, …, B_n. Funcon tree-root-value(_:trees(T)) : =&gt;(T)? Rule tree-root-value tree(V:T, _*:(trees(T))*) ~&gt; V . Funcon tree-branch-sequence(_:trees(T)) : =&gt;(trees(T))* Rule tree-branch-sequence tree(_:T, B*:(trees(T))*) ~&gt; B* . Funcon single-branching-sequence(_:trees(T)) : =&gt;T+ . single-branching-sequence B extracts the values in B starting from the root, provided that B is at most single-branching; otherwise it fails. Rule single-branching-sequence tree(V:T) ~&gt; V Rule single-branching-sequence tree(V:T, B:trees(T)) ~&gt; left-to-right( V, single-branching-sequence B) Rule single-branching-sequence tree(_:T, _:trees(T), _+:(trees(T))+) ~&gt; fail . A sequence of trees corresponds to a forest, and the selector funcons on trees B extend to forests B*: . Funcon forest-root-value-sequence(_:(trees(T))*) : =&gt;T* Rule forest-root-value-sequence(B:trees(T), B*:(trees(T))*) ~&gt;(tree-root-value B , forest-root-value-sequence B*) Rule forest-root-value-sequence( ) ~&gt;( ) . Funcon forest-branch-sequence(_:(trees(T))*) : =&gt;T* Rule forest-branch-sequence(B:trees(T), B*:(trees(T))*) ~&gt;(tree-branch-sequence B , forest-branch-sequence B*) Rule forest-branch-sequence( ) ~&gt;( ) . Funcon forest-value-sequence(_:(trees(T))*) : =&gt;T* . forest-value-sequence B* provides the values from a left-to-right pre-order depth-first traversal. Rule forest-value-sequence(tree(V:T, B1*:(trees(T))*), B2*:(trees(T))*) ~&gt;(V , forest-value-sequence B1*, forest-value-sequence B2*) Rule forest-value-sequence( ) ~&gt;( ) . Other linearizations of trees can be added: breadth-first, right-to-left, C3, etc. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Trees/index.html#trees",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Trees/index.html#trees"
  },"144": {
    "doc": "Trees",
    "title": "Trees",
    "content": "Funcons-beta : Trees.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Trees/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Trees/index.html"
  },"145": {
    "doc": "Tuples",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements Funcon tuple-zip ] . Meta-variables T1, T2 &lt;: values T1+, T2+ &lt;: values+ T*, T1*, T2* &lt;: values* . Datatype tuples(T*) ::= tuple(_:T*) . T* can be any sequence of types, including ( ) and values*. The values of type tuples(T_1, ..., T_n) are of the form tuple(V_1, ..., V_n) with V_1:T_1, …, V_n:T_n. Funcon tuple-elements(_:tuples(T*)) : =&gt;(T*) Rule tuple-elements(tuple(V*:T*)) ~&gt; V* . Funcon tuple-zip(_:tuples(values*), _:tuples(values*)) : =&gt;(tuples(values,values))* . tuple-zip(TV1, TV2) takes two tuples, and returns the sequence of pairs of their elements, provided that they have the same length. If they have different lengths, the last elements of the longer sequence are ignored. Rule tuple-zip(tuple(V1:T1, V1*:T1*), tuple(V2:T2, V2*:T2*)) ~&gt; (tuple(V1, V2), tuple-zip(tuple(V1*), tuple(V2*))) Rule tuple-zip(tuple( ), tuple( )) ~&gt; ( ) Rule tuple-zip(tuple(V1+:T1+), tuple( )) ~&gt; ( ) Rule tuple-zip(tuple( ), tuple(V2+:T2+)) ~&gt; ( ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Tuples/index.html#tuples",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Tuples/index.html#tuples"
  },"146": {
    "doc": "Tuples",
    "title": "Tuples",
    "content": "Funcons-beta : Tuples.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Tuples/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Tuples/index.html"
  },"147": {
    "doc": "Variants",
    "title": "Variants",
    "content": "[ Datatype variants Funcon variant Funcon variant-id Funcon variant-value ] . Meta-variables T &lt;: values . Datatype variants(T) ::= variant(_:identifiers, _:T) . A value of type variants(T) is a pair formed from an identifier and a value of type T. Funcon variant-id(_:variants(T)) : =&gt;identifiers Rule variant-id(variant(I:identifiers, _:T)) ~&gt; I . Funcon variant-value(_:variants(T)) : =&gt;T Rule variant-value(variant(_:identifiers, V:T)) ~&gt; V . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Variants/index.html#variants",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Variants/index.html#variants"
  },"148": {
    "doc": "Variants",
    "title": "Variants",
    "content": "Funcons-beta : Variants.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Variants/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Variants/index.html"
  },"149": {
    "doc": "Vectors",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . Meta-variables T &lt;: values . Datatype vectors(T) ::= vector(_:(T)*) . Funcon vector-elements(_:vectors(T)) : =&gt;(T)* Rule vector-elements(vector(V*:(T)*)) ~&gt; V* . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Vectors/index.html#vectors",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Vectors/index.html#vectors"
  },"150": {
    "doc": "Vectors",
    "title": "Vectors",
    "content": "Funcons-beta : Vectors.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/Vectors/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/Vectors/index.html"
  },"151": {
    "doc": "Composite",
    "title": "Composite values",
    "content": "Conceptually, composite values are constructed from sequences of argument values. The types of composite values include parametrised algebraic data types, with a generic representation. Various algebraic datatypes are defined, and new ones can be introduced. Composite values include also built-in parametrised types of sets, maps, multi-sets, and graphs. A composite value can always be decomposed into a sequence of values from which it can be reconstructed. For algebraic datatypes such as lists, the decomposition is unique. For a built-in type such as sets, the funcon provided to compute values is not a constructor. and it may compute the same composite value from different sequences of arguments. All composite ground values can be tested for equality. The CBS library includes types of composite values corresponding to the following concepts: . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/index.html#composite-values",
    "relUrl": "/docs/Funcons-beta/Values/Composite/index.html#composite-values"
  },"152": {
    "doc": "Composite",
    "title": "Algebraic datatypes",
    "content": "Algebraic datatypes correspond to unions of subtypes, The values of each subtype generally consist of a fixed constructor identifier together with different sequences of argument values. The constructors can be declared separately from the types of their values, supporting GADTs. Tuples grouped sequences of values Lists grouped sequences of values with the usual operations (strings are lists of characters) Vectors grouped sequences of values Trees finitely branching, with values at branch points References values that represent other values (pointers are references or pointer-null) Records unordered indexed aggregate values Variants values tagged by identifiers Classes collections of features, allowing multiple superclasses, with abstractions to create objects Objects classified collections of features Bit-vectors including bits and bytes ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/index.html#algebraic-datatypes",
    "relUrl": "/docs/Funcons-beta/Values/Composite/index.html#algebraic-datatypes"
  },"153": {
    "doc": "Composite",
    "title": "Other types",
    "content": "The following types of composite values are all built-in. The funcons used to compute such values are not regarded as constructors, as they are not injective. Sets unordered, unindexed collections of values Maps unordered, indexed collections of values Multisets unordered, unindexed collections of values with multiplicities (bags) Graphs directed, possibly cyclic, graphs ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/index.html#other-types",
    "relUrl": "/docs/Funcons-beta/Values/Composite/index.html#other-types"
  },"154": {
    "doc": "Composite",
    "title": "Composite",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Composite/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Composite/index.html"
  },"155": {
    "doc": "Booleans",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not Funcon implies Funcon and Funcon or Funcon exclusive-or Alias xor ] . Datatype booleans ::= true | false Alias bools = booleans . Funcon not(_:booleans) : =&gt;booleans . not(B) is logical negation. Rule not(false) ~&gt; true Rule not(true) ~&gt; false . Funcon implies(_:booleans, _:booleans) : =&gt;booleans . implies(B1, B2) is logical implication. Rule implies(false, false) ~&gt; true Rule implies(false, true) ~&gt; true Rule implies(true, true) ~&gt; true Rule implies(true, false) ~&gt; false . Funcon and(_:booleans*) : =&gt;booleans . and(B, ...) is logical conjunction of any number of Boolean values. Rule and( ) ~&gt; true Rule and(false, _*:booleans*) ~&gt; false Rule and(true, B*:booleans*) ~&gt; and(B*) . Funcon or(_:booleans*) : =&gt;booleans . or(B, ...) is logical disjunction of any number of Boolean values. Rule or( ) ~&gt; false Rule or(true, _*:booleans*) ~&gt; true Rule or(false, B*:booleans*) ~&gt; or(B*) . Funcon exclusive-or(_:booleans, _:booleans) : =&gt;booleans Alias xor = exclusive-or . exclusive-or(B1, B2) is exclusive disjunction. Rule exclusive-or(false, false) ~&gt; false Rule exclusive-or(false, true) ~&gt; true Rule exclusive-or(true, false) ~&gt; true Rule exclusive-or(true, true) ~&gt; false . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Booleans/index.html#booleans",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Booleans/index.html#booleans"
  },"156": {
    "doc": "Booleans",
    "title": "Booleans",
    "content": "Funcons-beta : Booleans.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Booleans/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Booleans/index.html"
  },"157": {
    "doc": "Characters",
    "title": "Characters",
    "content": "[ Type characters Alias chars Datatype unicode-characters Alias unicode-chars Type unicode-points Funcon unicode-character Alias unicode-char Funcon unicode-point Alias unicode Type basic-multilingual-plane-characters Alias bmp-chars Type basic-multilingual-plane-points Type iso-latin-1-characters Alias latin-1-chars Type iso-latin-1-points Type ascii-characters Alias ascii-chars Type ascii-points Funcon ascii-character Alias ascii-char Funcon utf-8 Funcon utf-16 Funcon utf-32 Funcon backspace Funcon horizontal-tab Funcon line-feed Funcon form-feed Funcon carriage-return Funcon double-quote Funcon single-quote Funcon backslash ] . Built-in Type characters &lt;: values . Literal characters can be written 'C' where C is any visible character other than a single-quote or backslash character, which need to be escaped as '\\'' and '\\\\'. Alias chars = characters . Unicode character set . The set of Unicode characters and allocated points is open to extension. See https://en.wikipedia.org/wiki/Plane_(Unicode) . Built-in Datatype unicode-characters &lt;: characters Alias unicode-chars = unicode-characters . Built-in Type unicode-points &lt;: bounded-integers(0, unsigned-bit-vector-maximum(21)) . Built-in Funcon unicode-character(_:unicode-points) : unicode-characters Alias unicode-char = unicode-character . The values in unicode-characters are the values of unicode-character(UP:unicode-points). Funcon unicode-point(_:unicode-characters) : =&gt;unicode-points Alias unicode = unicode-point . Rule unicode-point(unicode-character(UP:unicode-points)) ~&gt; UP . Unicode basic multilingual plane . The set of Unicode BMP characters and allocated points is open to extension. Built-in Datatype basic-multilingual-plane-characters &lt;: unicode-characters Alias bmp-chars = basic-multilingual-plane-characters . Built-in Type basic-multilingual-plane-points &lt;: bounded-integers(0, unsigned-bit-vector-maximum(17)) . The values in basic-multilingual-plane-characters are the values of unicode-character(BMPP:basic-multilingual-plane-points). ISO Latin-1 character set . Built-in Datatype iso-latin-1-characters &lt;: basic-multilingual-plane-characters Alias latin-1-chars = iso-latin-1-characters . Type iso-latin-1-points ~&gt; bounded-integers(0, unsigned-bit-vector-maximum(8)) . The values in iso-latin-1-characters are the values of unicode-character(ILP:iso-latin-1-points). ASCII character set . Built-in Type ascii-characters &lt;: iso-latin-1-characters Alias ascii-chars = ascii-characters . Type ascii-points ~&gt; bounded-integers(0, unsigned-bit-vector-maximum(7)) . The values in ascii-characters are the values of unicode-character(AP:ascii-points). Funcon ascii-character(_:strings) : =&gt;ascii-characters? Alias ascii-char = ascii-character . ascii-character\"C\" takes a string. When it consists of a single ASCII character C it gives the character, otherwise ( ). Rule ascii-character[C:ascii-characters] ~&gt; C Rule C : ~ ascii-characters ------------------------------------ ascii-character[C:characters] ~&gt; ( ) Rule length(C*) =/= 1 -------------------------------------- ascii-character[C*:characters*] ~&gt; ( ) . Character point encodings . See https://en.wikipedia.org/wiki/Character_encoding . Built-in Funcon utf-8(_:unicode-points) : =&gt;(bytes, (bytes, (bytes, bytes?)? )? ) . Built-in Funcon utf-16(_:unicode-points) : =&gt;(bit-vectors(16), (bit-vectors(16))? ) . Built-in Funcon utf-32(_:unicode-points) : =&gt;bit-vectors(32) . Control characters . Funcon backspace : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"0008\") . Funcon horizontal-tab : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"0009\") . Funcon line-feed : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"000a\") . Funcon form-feed : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"000c\") . Funcon carriage-return : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"000d\") . Funcon double-quote : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"0022\") . Funcon single-quote : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"0027\") . Funcon backslash : =&gt;ascii-characters ~&gt; unicode-character(hexadecimal-natural\"005c\") . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Characters/index.html#characters",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Characters/index.html#characters"
  },"158": {
    "doc": "Characters",
    "title": "Characters",
    "content": "Funcons-beta : Characters.cbs | PRETTY | PDF . Outline . | Characters . | Unicode character set | Unicode basic multilingual plane | ISO Latin-1 character set | ASCII character set | Character point encodings | Control characters | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Characters/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Characters/index.html"
  },"159": {
    "doc": "Floats",
    "title": "Floats",
    "content": "[ Datatype float-formats Funcon binary32 Funcon binary64 Funcon binary128 Funcon decimal64 Funcon decimal128 Type floats Funcon float Funcon quiet-not-a-number Alias qNaN Funcon signaling-not-a-number Alias sNaN Funcon positive-infinity Alias pos-inf Funcon negative-infinity Alias neg-inf Funcon float-convert Funcon decimal-float Funcon float-equal Funcon float-is-less Funcon float-is-less-or-equal Funcon float-is-greater Funcon float-is-greater-or-equal Funcon float-negate Funcon float-absolute-value Funcon float-add Funcon float-subtract Funcon float-multiply Funcon float-multiply-add Funcon float-divide Funcon float-remainder Funcon float-sqrt Funcon float-integer-power Funcon float-float-power Funcon float-round-ties-to-even Funcon float-round-ties-to-infinity Funcon float-floor Funcon float-ceiling Funcon float-truncate Funcon float-pi Funcon float-e Funcon float-log Funcon float-log10 Funcon float-exp Funcon float-sin Funcon float-cos Funcon float-tan Funcon float-asin Funcon float-acos Funcon float-atan Funcon float-sinh Funcon float-cosh Funcon float-tanh Funcon float-asinh Funcon float-acosh Funcon float-atanh Funcon float-atan2 ] . Floating-point numbers according to the IEEE 754 Standard (2008). See: . | http://doi.org/10.1109/IEEESTD.2008.4610935 | https://en.wikipedia.org/wiki/IEEE_754 | . Datatype float-formats ::= binary32 | binary64 | binary128 | decimal64 | decimal128 . Built-in Type floats(_:float-formats) . Note that for distinct formats FF1, FF2, the types floats(FF1) and floats(FF2) are not necessarily disjoint. Built-in Funcon float(FF:float-formats, _:bounded-integers(0, 1), _:natural-numbers, _:integers) : =&gt;floats(FF) . Each finite number is described by three integers: . | s = a sign (zero or one), | c = a significand (or ‘coefficient’), | q = an exponent. The numerical value of a finite number is (-1)^s * c * b^q where b is the base (2 or 10), also called radix. | . The possible finite values that can be represented in a format are determined by the base b, the number of digits in the significand (precision p), and the exponent parameter emax: . | c must be an integer in the range zero through (b^p)-1 (e.g., if b=10 and p=7 then c is 0 through 9999999); | q must be an integer such that 1-emax &lt;= q+p-1 &lt;= emax (e.g., if p=7 and emax=96 then q is -101 through 90). | . Note that float(FF, S, C, Q) is not a 1-1 operation. Built-in Funcon quiet-not-a-number(FF:float-formats) : floats(FF) Alias qNaN = quiet-not-a-number . Built-in Funcon signaling-not-a-number(FF:float-formats) : floats(FF) Alias sNaN = signaling-not-a-number . Built-in Funcon positive-infinity(FF:float-formats) : floats(FF) Alias pos-inf = positive-infinity . Built-in Funcon negative-infinity(FF:float-formats) : floats(FF) Alias neg-inf = negative-infinity . Conversions . Built-in Funcon float-convert(FF1:float-formats, FF2:float-formats, F:floats(FF1)) : =&gt;floats(FF2) . Built-in Funcon decimal-float(FF:float-formats, _:strings, _:strings, _:strings) : =&gt;floats(FF) . decimal-float(F, \"M\", \"N\", \"E\") is an approximation in floats(FF) to the value of ‘M.N’ times 10 to the power ‘E’, where “M.N” is decimal notation (optionally-signed) for a fixed-point number and “E” is decimal notation (optionally signed) for an integer. When any argument string is invalid, the result is quiet-not-a-number(F). Comparison . Built-in Funcon float-equal(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;booleans . Built-in Funcon float-is-less(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;booleans . Built-in Funcon float-is-less-or-equal(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;booleans . Built-in Funcon float-is-greater(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;booleans . Built-in Funcon float-is-greater-or-equal(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;booleans . Arithmetic . Built-in Funcon float-negate(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-absolute-value(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-add(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-subtract(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-multiply(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-multiply-add(FF:float-formats, _:floats(FF), _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-divide(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-remainder(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-sqrt(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-integer-power(FF:float-formats, _:floats(FF), _:integers) : =&gt;floats(FF) . Built-in Funcon float-float-power(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . Rounding . Built-in Funcon float-round-ties-to-even(FF:float-formats, _:floats(FF)) : =&gt;integers . Built-in Funcon float-round-ties-to-infinity(FF:float-formats, _:floats(FF)) : =&gt;integers . Built-in Funcon float-floor(FF:float-formats, _:floats(FF)) : =&gt;integers . Built-in Funcon float-ceiling(FF:float-formats, _:floats(FF)) : =&gt;integers . Built-in Funcon float-truncate(FF:float-formats, _:floats(FF)) : =&gt;integers . Miscellaneous . Built-in Funcon float-pi(FF:float-formats) : =&gt;floats(FF) . Built-in Funcon float-e(FF:float-formats) : =&gt;floats(FF) . Built-in Funcon float-log(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-log10(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-exp(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-sin(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-cos(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-tan(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-asin(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-acos(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-atan(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-sinh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-cosh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-tanh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-asinh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-acosh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-atanh(FF:float-formats, _:floats(FF)) : =&gt;floats(FF) . Built-in Funcon float-atan2(FF:float-formats, _:floats(FF), _:floats(FF)) : =&gt;floats(FF) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Floats/index.html#floats",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Floats/index.html#floats"
  },"160": {
    "doc": "Floats",
    "title": "Floats",
    "content": "Funcons-beta : Floats.cbs | PRETTY | PDF . Outline . | Floats . | Conversions | Comparison | Arithmetic | Rounding | Miscellaneous | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Floats/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Floats/index.html"
  },"161": {
    "doc": "Integers",
    "title": "Integers",
    "content": "[ Type integers Alias ints Type integers-from Alias from Type integers-up-to Alias up-to Type bounded-integers Alias bounded-ints Type positive-integers Alias pos-ints Type negative-integers Alias neg-ints Type natural-numbers Alias nats Funcon natural-successor Alias nat-succ Funcon natural-predecessor Alias nat-pred Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-modulo Alias int-mod Funcon integer-power Alias int-pow Funcon integer-absolute-value Alias int-abs Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon binary-natural Alias binary Funcon octal-natural Alias octal Funcon decimal-natural Alias decimal Funcon hexadecimal-natural Alias hexadecimal Funcon integer-sequence ] . Built-in Type integers Alias ints = integers . integers is the type of unbounded integers. Decimal notation is used to express particular integer values. Subtypes of integers . Built-in Type integers-from(_:integers) &lt;: integers Alias from = integers-from . integers-from(M) is the subtype of integers greater than or equal to M. Built-in Type integers-up-to(_:integers) &lt;: integers Alias up-to = integers-up-to . integers-up-to(N) is the subtype of integers less than or equal to N. Type bounded-integers(M:integers, N:integers) ~&gt; integers-from(M) &amp; integers-up-to(N) Alias bounded-ints = bounded-integers . bounded-integers(M,N) is the subtype of integers from M to N, inclusive. Type positive-integers ~&gt; integers-from(1) Alias pos-ints = positive-integers . Type negative-integers ~&gt; integers-up-to(-1) Alias neg-ints = negative-integers . Natural numbers . Type natural-numbers ~&gt; integers-from(0) Alias nats = natural-numbers . Built-in Funcon natural-successor(N:natural-numbers) : =&gt;natural-numbers Alias nat-succ = natural-successor . Built-in Funcon natural-predecessor(_:natural-numbers) : =&gt;natural-numbers? Alias nat-pred = natural-predecessor . Assert natural-predecessor(0) == ( ) . Arithmetic . Built-in Funcon integer-add(_:integers*) : =&gt;integers Alias int-add = integer-add . Built-in Funcon integer-subtract(_:integers, _:integers) : =&gt;integers Alias int-sub = integer-subtract . Built-in Funcon integer-multiply(_:integers*) : =&gt;integers Alias int-mul = integer-multiply . Built-in Funcon integer-divide(_:integers, _:integers) : =&gt;integers? Alias int-div = integer-divide . Assert integer-divide(_:integers, 0) == ( ) . Built-in Funcon integer-modulo(_:integers, _:integers) : =&gt;integers? Alias int-mod = integer-modulo . Assert integer-modulo(_:integers, 0) == ( ) . Built-in Funcon integer-power(_:integers, _:natural-numbers) : =&gt;integers Alias int-pow = integer-power . Built-in Funcon integer-absolute-value(_:integers) : =&gt;natural-numbers Alias int-abs = integer-absolute-value . Funcon integer-negate(N:integers) : =&gt;integers ~&gt; integer-subtract(0, N) Alias int-neg = integer-negate . Comparison . Built-in Funcon integer-is-less(_:integers, _:integers) : =&gt;booleans Alias is-less = integer-is-less . Built-in Funcon integer-is-less-or-equal(_:integers, _:integers) : =&gt;booleans Alias is-less-or-equal = integer-is-less-or-equal . Built-in Funcon integer-is-greater(_:integers, _:integers) : =&gt;booleans Alias is-greater = integer-is-greater . Built-in Funcon integer-is-greater-or-equal(_:integers, _:integers) : =&gt;booleans Alias is-greater-or-equal = integer-is-greater-or-equal . Conversion . Built-in Funcon binary-natural(_:strings) : =&gt;natural-numbers? Alias binary = binary-natural . Built-in Funcon octal-natural(_:strings) : =&gt;natural-numbers? Alias octal = octal-natural . Built-in Funcon decimal-natural(_:strings) : =&gt;natural-numbers? Alias decimal = decimal-natural . Literal natural numbers N are equivalent to decimal-natural\"N\". Built-in Funcon hexadecimal-natural(_:strings) : =&gt;natural-numbers? Alias hexadecimal = hexadecimal-natural . Funcon integer-sequence(_:integers, _:integers) : =&gt;integers* . integer-sequence(M, N) is the seqeunce of integers from M to N, except that if M is greater than N, it is the empty sequence. Rule is-greater(M, N) == false ------------------------------------------------ integer-sequence(M:integers, N:integers) ~&gt; (M, integer-sequence(integer-add(M, 1), N)) Rule is-greater(M, N) == true ----------------------------------------------- integer-sequence(M:integers, N:integers) ~&gt; ( ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Integers/index.html#integers",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Integers/index.html#integers"
  },"162": {
    "doc": "Integers",
    "title": "Integers",
    "content": "Funcons-beta : Integers.cbs | PRETTY | PDF . Outline . | Integers . | Subtypes of integers | Natural numbers | Arithmetic | Comparison | Conversion | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Integers/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Integers/index.html"
  },"163": {
    "doc": "Null",
    "title": "Null",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . Datatype null-type ::= null-value Alias null = null-value . The only element of the datatype null-type is null-value. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Null/index.html#null",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Null/index.html#null"
  },"164": {
    "doc": "Null",
    "title": "Null",
    "content": "Funcons-beta : Null.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/Null/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/Null/index.html"
  },"165": {
    "doc": "Primitive",
    "title": "Primitive values",
    "content": "Conceptually, primitive values are atomic, and not formed from other values: each primitive value corresponds to a constant constructor. For large (or infinite) types of primitive values, however, it is infeasible to declare a separate constant for each value. So in practice, funcons used to construct primitive values usually take other values as arguments. For example, a funcon for constructing a character value takes the integer corresponding to its point in a Unicode plane as argument; and a funcon for constructing an integer value takes its representation in decimal notation as a string argument. The CBS library includes types of primitive values corresponding to the following concepts: . Booleans the usual Boolean truth-values Integers unbounded integer arithmetic, together with subtypes of bounded integers Floats IEEE floating point arithmetic Characters Unicode, its various subtypes, and its encodings as byte sequences null-type a singleton type ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/index.html#primitive-values",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/index.html#primitive-values"
  },"166": {
    "doc": "Primitive",
    "title": "Primitive",
    "content": " ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Primitive/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Primitive/index.html"
  },"167": {
    "doc": "Value-Types",
    "title": "Value Types",
    "content": "[ Type values Alias vals Type value-types Alias types Type empty-type Funcon is-in-type Alias is Funcon is-value Alias is-val Funcon when-true Alias when Type cast-to-type Alias cast Type ground-values Alias ground-vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html#value-types",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html#value-types"
  },"168": {
    "doc": "Value-Types",
    "title": "Values",
    "content": "Built-in Type values Alias vals = values . The type values includes all values provided by CBS. Some funcons are declared as value constructors. Values are constructed by applying value constructor funcons to the required arguments. Values are immutable and context-independent. Their structure can be inspected using patterns formed from value constructors and variables. Computations can be extracted from values and executed, but the structure of computations cannot be inspected. Some types of values and their funcons are declared as built-in, and not further specified in CBS. New types of built-in values can be added to CBS by its developers. New algebraic datatypes may be declared by users of CBS. Their values are disjoint from built-in values. Meta-variables T, T1, T2 &lt;: values . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html#values",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html#values"
  },"169": {
    "doc": "Value-Types",
    "title": "Types",
    "content": "Built-in Type value-types Alias types = value-types . Built-in Type empty-type . A type T is a value that represents a set of values. The values of type types are all the types, including types itself. The formula V : T holds when V is a value of type T, i.e., V is in the set represented by the type T. The formula T1 &lt;: T2 holds when T1 is a subtype of T2, i.e., the set represented by T1 is a subset of the set represented by T2. The set of types forms a Boolean algebra with the following operations and constants: . | T1 &amp; T2 (meet/intersection) | T1 | T2 (join/union) | ~ T (complement) | values (top) | empty-type (bottom) | . Subtyping: T1 &lt;: T2 is the partial order defined by the algebra. Subsumption: If V : T1 and T1 &lt;: T2 both hold, so does V : T2. Indivisibility: For each value V and type T, either V : T or V : ~T holds. Universality: V : values holds for all values V. Emptiness: V : empty-type holds for no value V. ‘Type N’ declares the name ‘N’ to refer to a fresh value constructor and includes it as an element of types. ‘Type N ~&gt; T’ moreover specifies ‘Rule N ~&gt; T’, so that ‘N’ can be used as an abbreviation for the type term ‘T’. ‘Type N &lt;: T’ declares the name ‘N’ to refer to a fresh value constructor in types, and asserts ‘N &lt;: T’. Parametrised type declarations introduce generic (possibly dependent) types, i.e., families of individual types, indexed by types (and by other values). For example, lists(T) is parameterised by the type of list elements T. Replacing a parameter by _ denotes the union over all instances of that parameter, e.g., lists(_) is the union of all types lists(T) with T:types. Qualified variables V:T in terms range over values of type T. Qualified variables T1&lt;:T2 in terms range over subtypes T1 of T2. Funcon is-in-type(V:values, T:types) : =&gt;booleans Alias is = is-in-type . is-in-type(V, T) tests whether V : T holds. The value V need not be a ground value, but T should not require testing any computation types. Rule V : T ------------------------------------- is-in-type(V:values, T:types) ~&gt; true Rule V : ~ T -------------------------------------- is-in-type(V:values, T:types) ~&gt; false . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html#types",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html#types"
  },"170": {
    "doc": "Value-Types",
    "title": "Option types",
    "content": "For any value type T, the elements of the option type (T)? are the elements of T together with the empty sequence ( ), which represents the absence of a value. Option types are a special case of sequence types. A funcon whose result type is an option type (T)? may compute a value of type T or the empty sequence ( ); the latter represents undefined results of partial operations. The parentheses in (T)? and ( ) can be omitted when this does not give rise to grouoing ambiguity. Note however that T? is a meta-variable ranging over option types, whereas (T)? is the option type for the value type T. Funcon is-value(_:values?) : =&gt;booleans Alias is-val = is-value . is-value(V?) tests whether the optional value V? is a value or absent. Rule is-value(_:values) ~&gt; true Rule is-value( ) ~&gt; false . Funcon when-true(_:booleans, _:T) : =&gt;(T)? Alias when = when-true . when-true(B, V) gives V when B is true, and ( ) when B is false. Rule when-true(true, V:values) ~&gt; V Rule when-true(false, V:values) ~&gt; ( ) . Funcon cast-to-type(V:values, T:types) : =&gt;(T)? Alias cast = cast-to-type . cast-to-type(V, T) gives V if it is in T, otherwise ( ). Rule V : T ------------------------------------- cast-to-type(V:values, T:types) ~&gt; V Rule V : ~ T -------------------------------------- cast-to-type(V:values, T:types) ~&gt; ( ) . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html#option-types",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html#option-types"
  },"171": {
    "doc": "Value-Types",
    "title": "Ground values",
    "content": "Built-in Type ground-values Alias ground-vals = ground-values . The elements of ground-values are all values that are formed entirely from value-constructors, and thus do not involve computations. A type is a subtype of ground-values if and only if all its elements are included in ground-values. Funcon is-equal(V:values, W:values) : =&gt;booleans Alias is-eq = is-equal . is-equal(V, W) returns true when V and W are identical ground values, otherwise false. Rule V == W -------------------------------------------------- is-equal(V:ground-values, W:ground-values) ~&gt; true Rule V =/= W --------------------------------------------------- is-equal(V:ground-values, W:ground-values) ~&gt; false Rule is-equal(V:~ground-values, W:values) ~&gt; false Rule is-equal(V:values, W:~ground-values) ~&gt; false . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html#ground-values",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html#ground-values"
  },"172": {
    "doc": "Value-Types",
    "title": "Value-Types",
    "content": "Funcons-beta : Value-Types.cbs | PRETTY | PDF . Outline . | Value Types . | Values | Types | Option types | Ground values | . | . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/Value-Types/index.html",
    "relUrl": "/docs/Funcons-beta/Values/Value-Types/index.html"
  },"173": {
    "doc": "Values",
    "title": "Values",
    "content": "The CBS library provides funcons for expressing and computing various kinds of values. The characteristic feature of values is that they are immutable (computations cannot cause them to change) and inert (they cannot change themselves). Values can be bound to identifiers, assigned to variables, input, output, etc., and matched against patterns of constructors. In contrast, computations can only be executed. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html",
    "relUrl": "/docs/Funcons-beta/Values/index.html"
  },"174": {
    "doc": "Values",
    "title": "Kinds of values",
    "content": "Values are classified in various ways (non-exclusively) as follows. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#kinds-of-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#kinds-of-values"
  },"175": {
    "doc": "Values",
    "title": "Ground values",
    "content": "Ground values are formed inductively from constructors, and represent finite data. All ground values can be tested for equality. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#ground-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#ground-values"
  },"176": {
    "doc": "Values",
    "title": "Abstraction values",
    "content": "Abstraction values are formed by a constructor with an unevaluated computation argument. Enacting an abstraction value executes its computation argument – potentially in a different context from that where the abstraction was constructed. Although abstractions are essentially procedural, they can also be used to represent potentially infinite data. However, they are not ground values, and cannot be tested for equality. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#abstraction-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#abstraction-values"
  },"177": {
    "doc": "Values",
    "title": "Types of values",
    "content": "Value-types are values used to classify (possibly infinite) sets of values. The universal type classifies all values (including itself!) and the vacuous type classifies no values. Type union, intersection, and complement correspond to the familiar set-theoretic operations on the classified sets of values. Type equality is non-extensional: equality of ground type values implies that they classify the same set of values, but different type values may classify the same set of values. Similarly for subtypes: type inclusion implies subset inclusion for the sets of classified values, but not vice versa. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#types-of-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#types-of-values"
  },"178": {
    "doc": "Values",
    "title": "Composite values",
    "content": "Composite values are constructed from sequences of argument values. The types of composite values include parametrised algebraic data types, with a generic representation. Various algebraic datatypes are defined, and new ones can be introduced. Composite values include also built-in parametrised types of sets, maps, multi-sets, and graphs. A composite value can always be decomposed into a sequence of values from which it can be reconstructed. For algebraic datatypes such as lists, the decomposition is unique. For a built-in type such as sets, the funcon provided to compute values is not a constructor. and it may compute the same composite value from different sequences of arguments. All composite ground values can be tested for equality. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#composite-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#composite-values"
  },"179": {
    "doc": "Values",
    "title": "Primitive values",
    "content": "Primitive values are atomic, and not constructed from other values:. The types of primitive values include the Boolean truth values, Unicode characters, unbounded integers (with bounded subtypes), IEEE-754 floating-point numbers, and a null value. Further types of values, introduced in connection with particular kinds of computations, are defined in terms of the above types. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#primitive-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#primitive-values"
  },"180": {
    "doc": "Values",
    "title": "Built-in values",
    "content": "Built-in types of values are regarded as parameters of the universe of values. The signatures of their required operations and some of their required properties are specified in CBS. Most of the primitive types are built-in (as it would not be feasible to define them in CBS). ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#built-in-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#built-in-values"
  },"181": {
    "doc": "Values",
    "title": "Value computation",
    "content": "Value funcons compute values from argument values without use of auxiliary entities. In particular, their computations always terminate normally: abrupt termination and non-termination cannot arise. These funcons are defined using an embedding of conditional term rewriting in modular structural operational semantics, with all entities implicitly propagated between premises and conclusions of rules. Value constructors are not affected by rewriting, so they do not have any defining rules. Value funcon computations may be non-deterministic. For example, a funcon may select an arbitrary element from a composite set value. ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#value-computation",
    "relUrl": "/docs/Funcons-beta/Values/index.html#value-computation"
  },"182": {
    "doc": "Values",
    "title": "Sequences of values",
    "content": "Funcons can take sequences of values as arguments, and they may compute sequences of values as results. The only sequences that are themselves values are trivial sequences of length one. The absence of a computed value is represented by the empty sequence ( ). Funcons that may compute ( ) have result types of the form T?, and generally need to be preceded by checked when used as arguments of other funcons. Value funcons that compute ( ) correspond to partial operations on values, . ",
    "url": "/CBS-beta/docs/Funcons-beta/Values/index.html#sequences-of-values",
    "relUrl": "/docs/Funcons-beta/Values/index.html#sequences-of-values"
  },"183": {
    "doc": "Funcons-beta",
    "title": "Funcons-beta",
    "content": "This page introduces the beta-release of an initial collection of so-called ‘funcons’ (fundamental programming constructs). Other pages introduce and motivate the use of funcons in the CBS framework, and explain the purpose of the beta-release. Funcons are reusable components of programming language specifications: the semantics of a language is specified by translating its syntax to funcons, reusing (by reference) the definitions of the required funcons. Specifying a language by translation to funcons – and updating the specification as the language evolves – should be much less effort than defining its semantics in previous frameworks! See Languages-beta for some illustrative examples of language specifications in CBS, and LangDev-2019 for a demonstration of the ease of updating a language specification as the language evolves. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html",
    "relUrl": "/docs/Funcons-beta/index.html"
  },"184": {
    "doc": "Funcons-beta",
    "title": "Funcon definitions",
    "content": "Funcons are defined using a variant of structural operational semantics (SOS, developed by Gordon Plotkin in the 1980s). Computations are sequences of labelled transitions between states, which generally consist of syntax, computed values, and auxiliary entities such as stores and environments. Computed values are final states, having no transitions. However, SOS specifications lack modularity: when a new auxiliary entity is introduced for specifying an extended language, all the previous rules may need to be updated. And modularity is crucial for CBS, since adding new funcons to the collection must not require any changes at all to the definitions of previous funcons. In the modular variant of SOS used in CBS for defining funcons, auxiliary entities are implicitly propagated when omitted in particular rules: adding a new auxiliary entity never affects existing rules. Such modular SOS rules also look a lot simpler than the corresponding conventional SOS rules, since each rule references only the entities that it actually requires. Funcons have signatures, which specify the numbers and types of their arguments and results, and whether particular arguments are to be evaluated before using the specified rules or not (corresponding closely to strictness annotations in the K-framework). ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#funcon-definitions",
    "relUrl": "/docs/Funcons-beta/index.html#funcon-definitions"
  },"185": {
    "doc": "Funcons-beta",
    "title": "Operational semantics",
    "content": "The operational semantics of a funcon term is the set of all its computations, where each computation consists of a (possibly-empty, possibly infinite) sequence of transitions according to the specified rules. The computations generally depend on the computations of any subterms; they may also depend on the initial values of auxiliary entities. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#operational-semantics",
    "relUrl": "/docs/Funcons-beta/index.html#operational-semantics"
  },"186": {
    "doc": "Funcons-beta",
    "title": "Computations",
    "content": "The computations page introduces funcons for specifying flow of control, and funcons whose execution generally involves auxiliary entities (environments, stores, etc.). These funcons are defined using a modular variant of structural operational semantics: entities that are not essential for a particular funcon are implicitly propagated between premises and conclusions of the rules used to define it, so the rules do not need updating when new entities are introduced. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#computations",
    "relUrl": "/docs/Funcons-beta/index.html#computations"
  },"187": {
    "doc": "Funcons-beta",
    "title": "Entities",
    "content": "The entities page lists the entities that are used in the definitions of funcons for computations. The execution of a term is unaffected by entities that are not involved in the funcons used in it. There are no funcons for reifying auxiliary entities as values, nor for reflecting values as entities! This is because the way that particular entities flow during funcon execution is inherent and characteristic; reification and reflection would allow the flow to be circumvented. For instance, stores that represent assignments to imperative variables are implicitly threaded through the individual steps of funcon executions, and cannot be (directly) copied or reset. There are funcons for allocating a variable, initialising its value, inspecting its value, and assigning a new value – but not for making a copy of the current store, nor for replacing the entire store. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#entities",
    "relUrl": "/docs/Funcons-beta/index.html#entities"
  },"188": {
    "doc": "Funcons-beta",
    "title": "Values",
    "content": "Value constructors are particularly simple funcons: they have no rules at all, and the values they compute are formed by replacing their arguments by computed values. Funcon terms formed entirely from value constructors are ground values; non-ground values include abstractions, formed from value constructors that have unevaluated arguments. The only computation starting from a value is trivial: the empty sequence of transitions. The values page introduces funcons whose executions compute values from argument values without use of auxiliary entities. These funcons are defined using an embedding of conditional term rewriting in modular structural operational semantics, with all entities implicitly propagated between premises and conclusions of rules. Value constructors are not affected by rewriting, and can be matched in argument patterns in rules for funcon computation. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#values",
    "relUrl": "/docs/Funcons-beta/index.html#values"
  },"189": {
    "doc": "Funcons-beta",
    "title": "Funcons-Index",
    "content": "The Funcons-Index page lists the names of all the funcons defined in the CBS library (including aliases). The funcons are grouped together according to the types and entities involved in their definitions. Sections of the Funcons-Index page correspond to the folders and files that contain the funcon definitions. However, no familiarity with the file system is required when browsing CBS specifications, since references to funcons are always hyperlinked to the corresponding definitions. CBS does not have explicit packages: each language specification implicitly imports the entire library, and the list of the funcons that it uses is generated from the specification. This not only eliminates tedious lists of imported packages, but also reduces the effort of making changes. ",
    "url": "/CBS-beta/docs/Funcons-beta/index.html#funcons-index",
    "relUrl": "/docs/Funcons-beta/index.html#funcons-index"
  },"190": {
    "doc": "IMP-1",
    "title": "1 Arithmetic expressions",
    "content": "Syntax AExp : aexp ::= num | id | aexp '+' aexp | aexp '/' aexp | '(' aexp ')' . Semantics eval-arith[[ _:aexp ]] : =&gt;integers Rule eval-arith[[ N ]] = int-val[[ N ]] Rule eval-arith[[ I ]] = assigned(bound(id[[ I ]])) Rule eval-arith[[ AExp1 '+' AExp2 ]] = integer-add(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-arith[[ AExp1 '/' AExp2 ]] = checked integer-divide(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-arith[[ '(' AExp ')' ]] = eval-arith[[ AExp ]] . Syntax N : num ::= '-'?_decimal Lexis D : decimal ::= ('0'-'9')+ . Semantics int-val[[ _:num ]] : integers Rule int-val[[ D ]] = decimal-natural(\\\"D\\\") Rule int-val[[ '-' D ]] = integer-negate(int-val[[ D ]]) . Lexis I : id ::= ('A'-'Z'|'a'-'z')+ . Semantics id[[ _:id ]] : ids Rule id[[ I ]] = \\\"I\\\" . Lexis keyword ::= 'else' | 'false' | 'if' | 'true' | 'while' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-1/index.html#SectionNumber_1",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-1/index.html#SectionNumber_1"
  },"191": {
    "doc": "IMP-1",
    "title": "IMP-1",
    "content": "Languages-beta : IMP-1.cbs | PRETTY | PDF . Language \"IMP\" . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-1/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-1/index.html"
  },"192": {
    "doc": "IMP-2",
    "title": "2 Boolean expressions",
    "content": "Syntax BExp : bexp ::= 'false' | 'true' | aexp '&lt;=' aexp | '!' bexp | bexp '&amp;&amp;' bexp | '(' bexp ')' . Semantics eval-bool[[ _:bexp ]] : =&gt;booleans Rule eval-bool[[ 'false' ]] = false Rule eval-bool[[ 'true' ]] = true Rule eval-bool[[ AExp1 '&lt;=' AExp2 ]] = is-less-or-equal(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-bool[[ '!' BExp ]] = not(eval-bool[[ BExp ]]) Rule eval-bool[[ BExp1 '&amp;&amp;' BExp2 ]] = if-true-else(eval-bool[[ BExp1 ]], eval-bool[[ BExp2 ]], false) Rule eval-bool[[ '(' BExp ')' ]] = eval-bool[[ BExp ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-2/index.html#SectionNumber_2",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-2/index.html#SectionNumber_2"
  },"193": {
    "doc": "IMP-2",
    "title": "IMP-2",
    "content": "Languages-beta : IMP-2.cbs | PRETTY | PDF . Language \"IMP\" . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-2/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-2/index.html"
  },"194": {
    "doc": "IMP-3",
    "title": "3 Statements and blocks",
    "content": "Syntax Stmt : stmt ::= block | id '=' aexp ';' | 'if' '(' bexp ')' block ('else' block)? | 'while' '(' bexp ')' block | stmt stmt Syntax Block : block ::= '{' stmt? '}' . Rule [[ 'if' '(' BExp ')' Block ]] : stmt = [[ 'if' '(' BExp ')' Block 'else' '{' '}' ]] . Semantics execute[[ _:stmt ]] : =&gt;null-type Rule execute[[ I '=' AExp ';' ]] = assign(bound(id[[ I ]]), eval-arith[[ AExp ]]) Rule execute[[ 'if' '(' BExp ')' Block1 'else' Block2 ]] = if-true-else(eval-bool[[ BExp ]], execute[[ Block1 ]], execute[[ Block2 ]]) Rule execute[[ 'while' '(' BExp ')' Block ]] = while-true(eval-bool[[ BExp ]], execute[[ Block ]]) Rule execute[[ Stmt1 Stmt2 ]] = sequential(execute[[ Stmt1 ]], execute[[ Stmt2 ]]) Rule execute[[ '{' '}' ]] = null Rule execute[[ '{' Stmt '}' ]] = execute[[ Stmt ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-3/index.html#SectionNumber_3",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-3/index.html#SectionNumber_3"
  },"195": {
    "doc": "IMP-3",
    "title": "IMP-3",
    "content": "Languages-beta : IMP-3.cbs | PRETTY | PDF . Language \"IMP\" . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-3/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-3/index.html"
  },"196": {
    "doc": "IMP-4",
    "title": "4 Programs and variable declarations",
    "content": "Syntax Pgm : pgm ::= 'int' idlist ';' stmt . Semantics run[[ _:pgm ]] : =&gt;null-type Rule run[[ 'int' IL ';' Stmt ]] = scope( collateral(declare-int-vars[[ IL ]]), execute[[ Stmt ]] ) . Syntax IL : idlist ::= id (',' idlist)? . Semantics declare-int-vars[[ _: idlist ]] : (=&gt;environments)+ Rule declare-int-vars[[ I ]] = bind(id[[ I ]], allocate-initialised-variable(integers, 0)) Rule declare-int-vars[[ I ',' IL ]] = declare-int-vars[[ I ]], declare-int-vars[[ IL ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-4/index.html#SectionNumber_4",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-4/index.html#SectionNumber_4"
  },"197": {
    "doc": "IMP-4",
    "title": "IMP-4",
    "content": "Languages-beta : IMP-4.cbs | PRETTY | PDF . Language \"IMP\" . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-4/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-4/index.html"
  },"198": {
    "doc": "IMP-Disambiguation",
    "title": "A Disambiguation",
    "content": "Lexis SDF lexical syntax id = keyword {reject} lexical restrictions id -/- [A-Za-z0-9] Syntax SDF context-free syntax aexp ::= aexp '+' aexp {assoc} bexp ::= bexp '&amp;&amp;' bexp {assoc} stmt ::= stmt stmt {right} . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Disambiguation/index.html#SectionNumber_A"
  },"199": {
    "doc": "IMP-Disambiguation",
    "title": "IMP-Disambiguation",
    "content": "Languages-beta : IMP-Disambiguation.cbs | PRETTY | PDF . Language \"IMP\" . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Disambiguation/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Disambiguation/index.html"
  },"200": {
    "doc": "IMP-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#computations"
  },"201": {
    "doc": "IMP-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#normal-computation"
  },"202": {
    "doc": "IMP-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#flowing"
  },"203": {
    "doc": "IMP-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon initialise-giving ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#giving"
  },"204": {
    "doc": "IMP-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon scope Funcon collateral ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#binding"
  },"205": {
    "doc": "IMP-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#storing"
  },"206": {
    "doc": "IMP-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#abnormal-computation"
  },"207": {
    "doc": "IMP-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon checked ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#failing"
  },"208": {
    "doc": "IMP-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#values",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#values"
  },"209": {
    "doc": "IMP-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#primitive-values"
  },"210": {
    "doc": "IMP-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#booleans"
  },"211": {
    "doc": "IMP-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Funcon integer-add Alias int-add Funcon integer-divide Alias int-div Funcon integer-negate Alias int-neg Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#integers"
  },"212": {
    "doc": "IMP-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html#the-null-value"
  },"213": {
    "doc": "IMP-Funcons-Index",
    "title": "IMP-Funcons-Index",
    "content": "Languages-beta : IMP-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Storing | . | Abnormal computation . | Failing | . | . | Values . | Primitive values . | Booleans | Integers | The null value | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Funcons-Index/index.html"
  },"214": {
    "doc": "IMP-Start",
    "title": "Top level",
    "content": "Syntax START: start ::= pgm . Semantics start[[_:start]] : =&gt;null-type Rule start[[ Pgm ]] = initialise-binding initialise-storing initialise-giving finalise-failing run[[ Pgm ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Start/index.html#top-level",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Start/index.html#top-level"
  },"215": {
    "doc": "IMP-Start",
    "title": "IMP-Start",
    "content": "Languages-beta : IMP-Start.cbs | PRETTY | PDF . Language \"IMP\" . [ # 1 Arithmetic expressions # 2 Boolean expressions # 3 Statements and blocks # 4 Programs and variable declarations # A Disambiguation ] . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Start/index.html",
    "relUrl": "/docs/Languages-beta/IMP/IMP-cbs/IMP/IMP-Start/index.html"
  },"216": {
    "doc": "IMP",
    "title": "IMP",
    "content": "Grigore Rosu gave a definition of IMP in the K framework. He wrote: . IMP is considered a folklore language, without an official inventor, and has been used in many textbooks and papers, often with slight syntactic variations and often without being called IMP. It includes the most basic imperative language constructs, namely basic constructs for arithmetic and Boolean expressions, and variable assignment, conditional, while loop and sequential composition constructs for statements. IMP is a very small imperative language. Its CBS specification illustrates the basic features of the framework. The start of the specification of IMP in CBS is at IMP. ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/index.html",
    "relUrl": "/docs/Languages-beta/IMP/index.html"
  },"217": {
    "doc": "IMP",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete, derived from IMP in the K framework | dynamic semantics: complete | static semantics: not relevant | disambiguation: incomplete | . Tests: . | 9 tests and 3 small programs | high coverage (to be verified) | . Evolution: . | supersedes CBS of IMP in all previously published papers | . Reuse of funcons: . | IMP-Funcons-Index | . References: . | IMP in the K framework | . Keywords: . | imperative, illustrative, simple, disambiguation, K framework | . Main contributors: . | Peter Mosses | . ",
    "url": "/CBS-beta/docs/Languages-beta/IMP/index.html#colophon",
    "relUrl": "/docs/Languages-beta/IMP/index.html#colophon"
  },"218": {
    "doc": "MiniJava-Dynamics",
    "title": "1 Programs",
    "content": "Syntax P: program ::= main-class class-declaration* MC: main-class ::= 'class' identifier '{' 'public' 'static' 'void' 'main' '(' 'String' '[' ']' identifier ')' '{' statement '}' '}' . Semantics run[[ P:program ]] : =&gt; null-type Rule run[['class' ID1 '{' 'public' 'static' 'void' 'main' '(' 'String' '[' ']' ID2 ')' '{' S '}' '}' CD*]] = scope ( recursive ( bound-names[[CD*]], declare-classes[[CD*]] ), execute[[S]] ) . ID1 and ID2 are not referenced in S or CD* . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_1",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_1"
  },"219": {
    "doc": "MiniJava-Dynamics",
    "title": "2 Declarations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_2",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_2"
  },"220": {
    "doc": "MiniJava-Dynamics",
    "title": "Classes",
    "content": "Syntax CD: class-declaration ::= 'class' identifier ( 'extends' identifier )? '{' var-declaration* method-declaration* '}' . Semantics bound-names[[CD*:class-declaration*]] : =&gt; sets(ids) Rule bound-names[['class' ID1 '{' VD* MD* '}']] = { id[[ID1]] } Rule bound-names[['class' ID1 'extends' ID2 '{' VD* MD* '}']] = { id[[ID1]] } Rule bound-names[[ ]] = { } Rule bound-names[[CD CD+]] = set-unite ( bound-names[[CD]], bound-names[[CD+]] ) . Semantics declare-classes[[CD*:class-declaration*]] : =&gt; envs Rule declare-classes[['class' ID1 '{' VD* MD* '}']] = { id[[ID1]] |-&gt; class ( thunk closure // class instantiator reference object ( fresh-atom, // object identifier id[[ID1]], // object class name declare-variables[[VD*]] ), // object field variable map declare-methods[[MD*]] // class feature map ) } Rule declare-classes[['class' ID1 'extends' ID2 '{' VD* MD* '}']] = { id[[ID1]] |-&gt; class ( thunk closure // class instantiator reference object ( fresh-atom, // object identifier id[[ID1]], // object class name declare-variables[[VD*]], // object field variable map dereference force class-instantiator bound id[[ID2]] ), // superclass subobject declare-methods[[MD*]], // class feature map id[[ID2]] // superclass name ) } Rule declare-classes[[ ]] = map ( ) Rule declare-classes[[CD CD+]] = collateral ( declare-classes[[CD]], declare-classes[[CD+]] ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#classes",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#classes"
  },"221": {
    "doc": "MiniJava-Dynamics",
    "title": "Variables",
    "content": "Syntax VD: var-declaration ::= type identifier ';' . Semantics declare-variables[[VD*:var-declaration*]] : =&gt; envs Rule declare-variables[[T ID ';']] = { id[[ID]] |-&gt; allocate-initialised-variable ( type[[T]], initial-value[[T]] ) } Rule declare-variables[[ ]] = map ( ) Rule declare-variables[[VD VD+]] = collateral ( declare-variables[[VD]], declare-variables[[VD+]] ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#variables",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#variables"
  },"222": {
    "doc": "MiniJava-Dynamics",
    "title": "Types",
    "content": "Syntax T: type ::= 'int' '[' ']' | 'boolean' | 'int' | identifier . Semantics type[[T:type]] : =&gt; types Rule type[['int' '[' ']']] = vectors(variables) Rule type[['boolean']] = booleans Rule type[['int']] = integers Rule type[[ID]] = pointers(objects) . Semantics initial-value[[T:type]] : =&gt; minijava-values Rule initial-value[['int' '[' ']']] = vector( ) Rule initial-value[['boolean']] = false Rule initial-value[['int']] = 0 Rule initial-value[[ID]] = pointer-null . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#types",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#types"
  },"223": {
    "doc": "MiniJava-Dynamics",
    "title": "Methods",
    "content": "Syntax MD: method-declaration ::= 'public' type identifier '(' formal-list? ')' '{' var-declaration* statement* 'return' expression ';' '}' . Type methods ~&gt; functions(tuples(references(objects), minijava-values*), minijava-values) . Semantics declare-methods[[MD*:method-declaration*]] : =&gt; envs Rule declare-methods[['public' T ID '(' FL? ')' '{' VD* S* 'return' E ';' '}']] = { id[[ID]] |-&gt; function closure scope ( collateral ( // variables not allowed to shadow visible fields match ( given, tuple ( pattern abstraction { \"this\" |-&gt; allocate-initialised-variable ( pointers(objects), given ) }, bind-formals[[FL?]] ) ), object-single-inheritance-feature-map checked dereference first tuple-elements given, declare-variables[[VD*]] ), sequential ( execute[[S*]], evaluate[[E]] ) ) } Rule declare-methods[[ ]] = map ( ) Rule declare-methods[[MD MD+]] = collateral ( declare-methods[[MD]], declare-methods[[MD+]] ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#methods",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#methods"
  },"224": {
    "doc": "MiniJava-Dynamics",
    "title": "Formals",
    "content": "Syntax FL: formal-list ::= type identifier ( ',' formal-list )? . Semantics bind-formals[[FL?:formal-list?]] : =&gt; patterns* Rule bind-formals[[T ID]] = pattern abstraction { id[[ID]] |-&gt; allocate-initialised-variable ( type[[T]], given ) } Rule bind-formals[[T ID ',' FL]] = bind-formals[[T ID]], bind-formals[[FL]] Rule bind-formals[[ ]] = ( ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#formals",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#formals"
  },"225": {
    "doc": "MiniJava-Dynamics",
    "title": "3 Statements",
    "content": "Syntax S: statement ::= '{' statement* '}' | 'if' '(' expression ')' statement 'else' statement | 'while' '(' expression ')' statement | 'System''.''out''.''println' '(' expression ')' ';' | identifier '=' expression ';' | identifier '[' expression ']' '=' expression ';' . Semantics execute[[S*:statement*]] : =&gt; null-type Rule execute[['{' S* '}']] = execute[[S*]] Rule execute[['if' '(' E ')' S1 'else' S2]] = if-true-else ( evaluate[[E]], execute[[S1]], execute[[S2]] ) Rule execute[['while' '(' E ')' S]] = while-true ( evaluate[[E]], execute[[S]] ) Rule execute[['System''.''out''.''println' '(' E ')' ';']] = print ( to-string evaluate[[E]], \"\\n\" ) Rule execute[[ID '=' E ';']] = assign ( bound id[[ID]], evaluate[[E]] ) Rule execute[[ID '[' E1 ']' '=' E2 ';']] = assign ( checked index ( integer-add ( evaluate[[E1]], 1 ), vector-elements assigned bound id[[ID]] ), evaluate[[E2]] ) Rule execute[[ ]] = null Rule execute[[S S+]] = sequential ( execute[[S]], execute[[S+]] ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_3",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_3"
  },"226": {
    "doc": "MiniJava-Dynamics",
    "title": "4 Expressions",
    "content": "Syntax E: expression ::= expression '&amp;&amp;' expression | expression '&lt;' expression | expression '+' expression | expression '-' expression | expression '*' expression | expression '[' expression ']' | expression '.' 'length' | expression '.' identifier '(' expression-list? ')' | integer-literal | 'true' | 'false' | identifier | 'this' | 'new' 'int' '[' expression ']' | 'new' identifier '(' ')' | '!' expression | '(' expression ')' . Type minijava-values ~&gt; booleans | integers | vectors(variables) | pointers(objects) . Semantics evaluate[[E:expression]] : =&gt; minijava-values . evaluate[[_]] is a well-typed funcon term only when _ is a well-typed MiniJava expression. Rule evaluate[[E1 '&amp;&amp;' E2]] = if-true-else ( evaluate[[E1]], evaluate[[E2]], false ) Rule evaluate[[E1 '&lt;' E2]] = integer-is-less ( evaluate[[E1]], evaluate[[E2]] ) Rule evaluate[[E1 '+' E2]] = integer-add ( evaluate[[E1]], evaluate[[E2]] ) Rule evaluate[[E1 '-' E2]] = integer-subtract ( evaluate[[E1]], evaluate[[E2]] ) Rule evaluate[[E1 '*' E2]] = integer-multiply ( evaluate[[E1]], evaluate[[E2]] ) Rule evaluate[[E1 '[' E2 ']']] = assigned checked index ( integer-add ( evaluate[[E2]], 1 ), vector-elements evaluate[[E1]] ) Rule evaluate[[E '.' 'length']] = length vector-elements evaluate[[E]] Rule evaluate[[E '.' ID '(' EL? ')']] = give ( evaluate[[E]], apply ( lookup ( class-name-single-inheritance-feature-map object-class-name checked dereference given, id[[ID]] ), tuple ( given, evaluate-actuals[[EL?]] ) ) ) Rule evaluate[[IL]] = integer-value[[IL]] Rule evaluate[['true']] = true Rule evaluate[['false']] = false Rule evaluate[[ID]] = assigned bound id[[ID]] Rule evaluate[['this']] = assigned bound \"this\" Rule evaluate[['new' 'int' '[' E ']']] = vector ( interleave-repeat( allocate-initialised-variable ( integers, 0 ), 1, evaluate[[E]] ) ) Rule evaluate[['new' ID '(' ')']] = force class-instantiator bound id[[ID]] Rule evaluate[['!' E]] = not evaluate[[E]] Rule evaluate[['(' E ')']] = evaluate[[E]] . Syntax EL: expression-list ::= expression ( ',' expression-list )? . Semantics evaluate-actuals[[EL?:expression-list?]] : (=&gt; minijava-values)* Rule evaluate-actuals[[E]] = evaluate[[E]] Rule evaluate-actuals[[E ',' EL]] = evaluate[[E]], evaluate-actuals[[EL]] Rule evaluate-actuals[[ ]] = ( ) . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_4",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_4"
  },"227": {
    "doc": "MiniJava-Dynamics",
    "title": "5 Lexemes",
    "content": "Lexis ID: identifier ::= letter ( letter | digit | '_' )* . Semantics id[[ID:identifier]] : =&gt; ids = \\\"ID\\\" . Lexis IL: integer-literal ::= digit+ letter ::= 'a'-'z' | 'A'-'Z' digit ::= '0'-'9' . Semantics integer-value[[IL:integer-literal]] : =&gt; integers = decimal-natural \\\"IL\\\" . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_5",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html#SectionNumber_5"
  },"228": {
    "doc": "MiniJava-Dynamics",
    "title": "MiniJava-Dynamics",
    "content": "Languages-beta : MiniJava-Dynamics.cbs | PRETTY | PDF . Outline . | 1 Programs | 2 Declarations . | Classes | Variables | Types | Methods | Formals | . | 3 Statements | 4 Expressions | 5 Lexemes | . Language \"MiniJava\" . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Dynamics/index.html"
  },"229": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#computations"
  },"230": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#normal-computation"
  },"231": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#flowing"
  },"232": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon initialise-giving Funcon give Funcon given Funcon interleave-repeat ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#giving"
  },"233": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bound-value Alias bound Funcon scope Funcon collateral Funcon recursive ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#binding"
  },"234": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Generating",
    "content": "[ Funcon fresh-atom ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#generating",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#generating"
  },"235": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Datatype variables Alias vars Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#storing"
  },"236": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Interacting",
    "content": "Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#interacting"
  },"237": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#abnormal-computation"
  },"238": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon checked ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#failing"
  },"239": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#values",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#values"
  },"240": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type value-types Alias types ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#value-types"
  },"241": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#primitive-values"
  },"242": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#booleans"
  },"243": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-is-less Alias is-less Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#integers"
  },"244": {
    "doc": "MiniJava-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#the-null-value"
  },"245": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#composite-values"
  },"246": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon first ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#sequences-of-values"
  },"247": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#tuples"
  },"248": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Strings",
    "content": "[ Funcon to-string ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#strings",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#strings"
  },"249": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#vectors",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#vectors"
  },"250": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Sets",
    "content": "[ Type sets Funcon set-unite ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#sets",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#sets"
  },"251": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Maps",
    "content": "[ Funcon map Funcon map-lookup Alias lookup ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#maps"
  },"252": {
    "doc": "MiniJava-Funcons-Index",
    "title": "References and pointers",
    "content": "[ Datatype references Funcon reference Type pointers Funcon dereference ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#references-and-pointers",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#references-and-pointers"
  },"253": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Classes",
    "content": "[ Funcon class Funcon class-instantiator Funcon class-name-single-inheritance-feature-map ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#classes",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#classes"
  },"254": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Objects",
    "content": "[ Datatype objects Funcon object Funcon object-class-name Funcon object-single-inheritance-feature-map ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#objects",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#objects"
  },"255": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#abstraction-values"
  },"256": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Funcon abstraction Funcon closure ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#generic-abstractions"
  },"257": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Thunks",
    "content": "[ Funcon thunk Funcon force ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#thunks",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#thunks"
  },"258": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply ] . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#functions"
  },"259": {
    "doc": "MiniJava-Funcons-Index",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon match ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#patterns",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html#patterns"
  },"260": {
    "doc": "MiniJava-Funcons-Index",
    "title": "MiniJava-Funcons-Index",
    "content": "Languages-beta : MiniJava-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Interacting . | Output | . | . | Abnormal computation . | Failing | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Sequences of values | Tuples | Strings | Vectors | Sets | Maps | References and pointers | Classes | Objects | . | Abstraction values . | Generic abstractions | Thunks | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Funcons-Index/index.html"
  },"261": {
    "doc": "MiniJava-Start",
    "title": "MiniJava-Start",
    "content": "Languages-beta : MiniJava-Start.cbs | PRETTY | PDF . Language \"MiniJava\" . Syntax START: start ::= program . Semantics start[[ START:start ]] : =&gt; null-type Rule start[[ P ]] = initialise-binding initialise-storing initialise-giving finalise-failing run[[P]] . Contents: . [ # 1 Programs # 2 Declarations # 3 Statements # 4 Expressions # 5 Lexemes # 6 Disambiguation ] . The section numbers above are links into other files. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Start/index.html",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Start/index.html"
  },"262": {
    "doc": "MiniJava-Syntax",
    "title": "1 Programs",
    "content": "Syntax START: start ::= program P: program ::= main-class class-declaration* MC: main-class ::= 'class' identifier '{' 'public' 'static' 'void' 'main' '(' 'String' '[' ']' identifier ')' '{' statement '}' '}' . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#1-programs",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#1-programs"
  },"263": {
    "doc": "MiniJava-Syntax",
    "title": "2 Declarations",
    "content": "Syntax CD: class-declaration ::= 'class' identifier ( 'extends' identifier )? '{' var-declaration* method-declaration* '}' VD: var-declaration ::= type identifier ';' MD: method-declaration ::= 'public' type identifier '(' formal-list? ')' '{' var-declaration* statement* 'return' expression ';' '}' T: type ::= 'int' '[' ']' | 'boolean' | 'int' | identifier FL: formal-list ::= type identifier ( ',' formal-list )? . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#2-declarations",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#2-declarations"
  },"264": {
    "doc": "MiniJava-Syntax",
    "title": "3 Statements",
    "content": "Syntax S: statement ::= '{' statement* '}' | 'if' '(' expression ')' statement 'else' statement | 'while' '(' expression ')' statement | 'System''.''out''.''println' '(' expression ')' ';' | identifier '=' expression ';' | identifier '[' expression ']' '=' expression ';' . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#3-statements",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#3-statements"
  },"265": {
    "doc": "MiniJava-Syntax",
    "title": "4 Expressions",
    "content": "Syntax E: expression ::= expression '&amp;&amp;' expression | expression '&lt;' expression | expression '+' expression | expression '-' expression | expression '*' expression | expression '[' expression ']' | expression '.' 'length' | expression '.' identifier '(' expression-list? ')' | integer-literal | 'true' | 'false' | identifier | 'this' | 'new' 'int' '[' expression ']' | 'new' identifier '(' ')' | '!' expression | '(' expression ')' EL: expression-list ::= expression ( ',' expression-list )? . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#4-expressions",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#4-expressions"
  },"266": {
    "doc": "MiniJava-Syntax",
    "title": "5 Lexemes",
    "content": "Lexis ID: identifier ::= letter ( letter | digit | '_' )* IL: integer-literal ::= digit+ letter ::= 'a'-'z' | 'A'-'Z' digit ::= '0'-'9' . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#5-lexemes",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#5-lexemes"
  },"267": {
    "doc": "MiniJava-Syntax",
    "title": "6 Disambiguation",
    "content": "The mixture of CBS and SDF below specifies how MiniJava texts are to be disambiguated by parsers generated from the above grammar. The specified rules are adequate to disambiguate all the example programs provided at https://www.cambridge.org/us/features/052182060X/#progs. Syntax SDF context-free syntax expression ::= expression '*' expression {left} expression ::= expression '+' expression {left} expression ::= expression '-' expression {left} expression ::= expression '&lt;' expression {non-assoc} expression ::= expression '&amp;&amp;' expression {left} context-free priorities { expression ::= expression '.' identifier '(' expression-list? ')' expression ::= expression '[' expression ']' } &lt;0&gt; &gt; expression ::= '!' expression &gt; expression ::= expression '*' expression &gt; { expression ::= expression '+' expression expression ::= expression '-' expression } &gt; expression ::= expression '&lt;' expression &gt; expression ::= expression '&amp;&amp;' expression Lexis SDF lexical restrictions identifier -/- [a-zA-Z0-9\\_] integer-literal -/- [0-9] lexical syntax identifier = reserved-id {reject} Lexis reserved-id::= 'String' | 'System' | 'boolean' | 'class' | 'else' | 'extends' | 'false' | 'if' | 'int' | 'length' | 'main' | 'new' | 'out' | 'println' | 'public' | 'return' | 'static' | 'this' | 'true' | 'void' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#SectionNumber_6",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html#SectionNumber_6"
  },"268": {
    "doc": "MiniJava-Syntax",
    "title": "MiniJava-Syntax",
    "content": "Languages-beta : MiniJava-Syntax.cbs | PRETTY | PDF . Language \"MiniJava\" . [The MiniJava Reference Manual]: http://www.cambridge.org/us/features/052182060X/mjreference/mjreference.html . [Modern Compiler Implementation in Java: the MiniJava Project]: http://www.cambridge.org/us/features/052182060X/ . The grammar used here is mostly a transliteration of the one provided at: http://www.cambridge.org/us/features/052182060X/grammar.html (which differs in trivial ways from the one in the cited reference manual). The rest of this file gives an overview of the MiniJava syntax. It is mostly in the form of a comment with embedded productions. The nonterminal symbols are hyperlinks to their actual specifications; similarly, section numbers (such as # 1 below) link to the corresponding specification section. ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html",
    "relUrl": "/docs/Languages-beta/MiniJava/MiniJava-cbs/MiniJava/MiniJava-Syntax/index.html"
  },"269": {
    "doc": "MiniJava",
    "title": "MiniJava",
    "content": "Joao Cangussu, Jens Palsberg and Vidyut Samanta gave a BNF grammar for a very simple subset of Java in the MiniJava project. They wrote: . MiniJava is a subset of Java. The meaning of a MiniJava program is given by its meaning as a Java program. Overloading is not allowed in MiniJava. […] . MiniJava is a very simple subset of Java. Its CBS illustrates the funcons for classes and objects. The start of the specification of MiniJava in CBS is at MiniJava. ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/index.html",
    "relUrl": "/docs/Languages-beta/MiniJava/index.html"
  },"270": {
    "doc": "MiniJava",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete, derived from BNF for MiniJava | dynamic semantics: complete | static semantics: not specified | disambiguation: complete | . Tests: . | 8 small-to-medium-size programs from the MiniJava Project | 65 small unit tests, high coverage | . Evolution: . | first version | . Reuse of funcons: . | MiniJava-Funcons-Index | . References: . | MiniJava Project | Java Manual | BNF for MiniJava | . Keywords: . | Java, object-oriented | . Main contributors: . | Peter Mosses | . ",
    "url": "/CBS-beta/docs/Languages-beta/MiniJava/index.html#colophon",
    "relUrl": "/docs/Languages-beta/MiniJava/index.html#colophon"
  },"271": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "1 Lexical conventions",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#SectionNumber_1",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#SectionNumber_1"
  },"272": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Identifiers",
    "content": "Lexis I : ident ::= capitalized-ident | lowercase-ident CI : capitalized-ident ::= uppercase ( uppercase | lowercase | decimal | '_' | '\\'' )* LI : lowercase-ident ::= lowercase ( uppercase | lowercase | decimal | '_' | '\\'' )* | '_' ( uppercase | lowercase | decimal | '_' | '\\'' )+ // restricted to exclude the keyword '_' used in patterns uppercase ::= 'A'-'Z' lowercase ::= 'a'-'z' decimal ::= '0'-'9' . Semantics id[[ _:ident ]] : ids Rule id[[ I ]] = \\\"I\\\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#identifiers",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#identifiers"
  },"273": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Integer literals",
    "content": "Syntax IL : integer-literal ::= '-'? _ natural-literal NL : natural-literal ::= decimal-plus | ('0x'|'0X') hexadecimal-plus | ('0o'|'0O') octal-plus | ('0b'|'0B') binary-plus Lexis DP : decimal-plus ::= decimal+ HP : hexadecimal-plus ::= ( decimal | 'A'-'F' | 'a'-'f' )+ OP : octal-plus ::= ( '0'-'7' )+ BP : binary-plus ::= ( '0'|'1' )+ . Semantics integer-value[[ _:integer-literal ]] : =&gt;implemented-integers Rule integer-value[[ '-' NL ]] = integer-negate(integer-value[[ NL ]]) Rule integer-value[[ DP ]] = implemented-integer decimal-natural(\\\"DP\\\") . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#integer-literals",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#integer-literals"
  },"274": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Floating-point literals",
    "content": "Syntax FL : float-literal ::= '-'? _ non-negative-float-literal NNFL : non-negative-float-literal ::= decimal-plus _ '.' _ decimal-plus | decimal-plus _ '.' | decimal-plus _ '.' _ decimal-plus _ float-exponent | decimal-plus _ '.' _ float-exponent | decimal-plus _ float-exponent FE : float-exponent ::= ('e'|'E') _ ('+'|'-')? _ decimal-plus . Rule [[ DP1 '.' DP2 ]] : non-negative-float-literal = [[ DP1 '.' DP2 'e' '1' ]] Rule [[ DP '.' ]] : non-negative-float-literal = [[ DP '.' '0' 'e' '1' ]] Rule [[ DP '.' FE ]] : non-negative-float-literal = [[ DP '.' '0' FE ]] Rule [[ DP FE ]] : non-negative-float-literal = [[ DP '.' '0' FE ]] Rule [[ 'e' '+' DP ]] : float-exponent = [[ 'e' DP ]] Rule [[ 'E' '+' DP ]] : float-exponent = [[ 'e' DP ]] Rule [[ 'E' '-' DP ]] : float-exponent = [[ 'e' '-' DP ]] . Semantics float-value[[ _:float-literal ]] : =&gt;implemented-floats . float-value[[ _ ]] is unspecified if the literal value is not representable in floats(implemented-floats-format). Rule float-value[[ '-' NNFL ]] = float-negate(implemented-floats-format, float-value[[ NNFL]]) Rule float-value[[ DP1 '.' DP2 'e' DP3 ]] = decimal-float( implemented-floats-format, \\\"DP1\\\", \\\"DP2\\\", \\\"DP3\\\") Rule float-value[[ DP1 '.' DP2 'e' '-' DP3 ]] = decimal-float( implemented-floats-format, \\\"DP1\\\", \\\"DP2\\\", cons('-', \\\"DP3\\\")) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#floating-point-literals",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#floating-point-literals"
  },"275": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Character literals",
    "content": "Syntax CL : char-literal ::= '\\'' _ regular-char _ '\\'' | '\\'' _ escape-sequence _ '\\'' ES : escape-sequence ::= '\\\\' _ escaped-char | '\\\\' _ escaped-char-code Lexis RC : regular-char ::= ~ ( '\\'' | '\\\\' ) EC : escaped-char ::= '\\\\' | '\"' | '\\'' | 'n' | 't' | 'b' | 'r' | ' ' ECC : escaped-char-code ::= decimal decimal decimal . Semantics character-value[[ _:char-literal ]] : =&gt;implemented-characters Rule character-value[[ '\\'' RC '\\'' ]] = ascii-character(\\\"RC\\\") Rule character-value[[ '\\'' ES '\\'' ]] = capture[[ ES ]] . Semantics capture[[ _:escape-sequence ]] : implemented-characters Rule capture[[ '\\' '\\' ]] = backslash Rule capture[[ '\\' '\\'' ]] = '\\'' Rule capture[[ '\\' 'n' ]] = line-feed Rule capture[[ '\\' 't' ]] = horizontal-tab Rule capture[[ '\\' 'b' ]] = backspace Rule capture[[ '\\' 'r' ]] = carriage-return Rule capture[[ '\\' ECC ]] = checked implemented-character unicode-character decimal-natural(\\\"ECC\\\") . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#character-literals",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#character-literals"
  },"276": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "String literals",
    "content": "Syntax SL : string-literal ::= '\"' _ string-character-star _ '\"' SCS : string-character-star ::= string-character _ string-character-star | ( ) SC : string-character ::= regular-string-char | escape-sequence// | '\\\\' _ '\\n' _ (' '|'\\t')* Lexis RSC : regular-string-char ::= ~ ('\"' | '\\\\') . Semantics string-value[[ _:string-literal ]] : =&gt;implemented-strings Rule string-value[[ '\"' SCS '\"' ]] = checked implemented-string [ string-chars[[ SCS ]] ] . Semantics string-chars[[ _:string-character-star ]] : =&gt;implemented-characters* Rule string-chars[[ ]] = Rule string-chars[[ SC SCS ]] = string-capture[[ SC ]], string-chars[[ SCS ]] . Semantics string-capture[[ _:string-character ]] : implemented-characters Rule string-capture[[ RSC ]] = ascii-character(\\\"RSC\\\") Rule string-capture[[ ES ]] = capture[[ ES ]] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#string-literals",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#string-literals"
  },"277": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Prefix and infix symbols",
    "content": "Lexis // infix-symbol // ::= ( '=' | '&lt;' | '&gt;' | '@' | '^' | '|' // | '&amp;' | '+' | '-' | '*' | '/' | '$' | '%' ) operator-char* PS : prefix-symbol ::= '!' operator-char* | ('?'|'~') operator-char+ operator-char ::= '!' | '$' | '%' | '&amp;' | '*' | '+' | '-' | '.' | '/' | ':' | '&lt;' | '=' | '&gt;' | '?' | '@' | '^' | '|' | '~' operator-char-not-asterisk ::= '!' | '$' | '%' | '&amp;' | '+' | '-' | '.' | '/' | ':' | '&lt;' | '=' | '&gt;' | '?' | '@' | '^' | '|' | '~' operator-char-not-bar ::= '!' | '$' | '%' | '&amp;' | '*' | '+' | '-' | '.' | '/' | ':' | '&lt;' | '=' | '&gt;' | '?' | '@' | '^' | '~' operator-char-not-ampersand ::= '!' | '$' | '%' | '*' | '+' | '-' | '.' | '/' | ':' | '&lt;' | '=' | '&gt;' | '?' | '@' | '^' | '|' | '~' . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#prefix-and-infix-symbols",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#prefix-and-infix-symbols"
  },"278": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "Keywords",
    "content": "Lexis keyword ::= 'and' | 'as' | 'assert' | 'asr' | 'begin' | 'class' | 'constraint' | 'do' | 'done' | 'downto' | 'else' | 'end' | 'exception' | 'external' | 'false' | 'for' | 'fun' | 'function' | 'functor' | 'if' | 'in' | 'include' | 'inherit' | 'initializer' | 'land' | 'lazy' | 'let' | 'lor' | 'lsl' | 'lsr' | 'lxor' | 'match' | 'method' | 'mod' | 'module' | 'mutable' | 'new' | 'nonrec' | 'object' | 'of' | 'open' | 'or' | 'private' | 'rec' | 'sig' | 'struct' | 'then' | 'to' | 'true' | 'try' | 'type' | 'val' | 'virtual' | 'when' | 'while' | 'with' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#keywords",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html#keywords"
  },"279": {
    "doc": "OC-L-01-Lexical-Conventions",
    "title": "OC-L-01-Lexical-Conventions",
    "content": "Languages-beta : OC-L-01-Lexical-Conventions.cbs | PRETTY | PDF . Outline . | 1 Lexical conventions . | Identifiers | Integer literals | Floating-point literals | Character literals | String literals | Prefix and infix symbols | Keywords | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-01-Lexical-Conventions/index.html"
  },"280": {
    "doc": "OC-L-02-Values",
    "title": "2 Values",
    "content": "The comments below are excerpts from section 7.2 of The OCaml System, release 4.06. // FIX-ME: Allow implementation-dependent variations . Type implemented-values ~&gt; null-type | booleans | implemented-integers | implemented-floats | implemented-characters | implemented-strings | implemented-tuples | implemented-lists | implemented-records | implemented-references | implemented-vectors | implemented-variants | implemented-functions . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#SectionNumber_2",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#SectionNumber_2"
  },"281": {
    "doc": "OC-L-02-Values",
    "title": "Base values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#base-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#base-values"
  },"282": {
    "doc": "OC-L-02-Values",
    "title": "Integer numbers",
    "content": "Integer values are integer numbers from -2^{30} to 2^{30}-1, that is -1073741824 to 1073741823. The implementation may support a wider range of integer values (…). Type implemented-integers // &lt;: integers ~&gt; integers . // FIX-ME . Funcon implemented-integer(I:integers) : =&gt;implemented-integers ~&gt; I // FIX-ME: Two's complement, modulo 2^31 Assert is-equal(null, implemented-integer(N:bounded-integers(-1073741824,1073741823))) == false . Funcon implemented-integers-width : =&gt;natural-numbers ~&gt; 31 . Funcon implemented-integer-literal(IL:strings) : =&gt; implemented-integers ~&gt; implemented-integer decimal-natural(IL) . // FIX-ME: allow negatives . Funcon implemented-bit-vector(I:implemented-integers) : =&gt; bit-vectors(implemented-integers-width) ~&gt; integer-to-bit-vector(I, implemented-integers-width) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#integer-numbers",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#integer-numbers"
  },"283": {
    "doc": "OC-L-02-Values",
    "title": "Floating-point numbers",
    "content": "Floating-point values are numbers in floating-point representation. The current implementation uses double-precision floating-point numbers conforming to the IEEE 754 standard, with 53 bits of mantissa and an exponent ranging from -1022 to 1023. Type implemented-floats // ~&gt; floats(implemented-floats-format) . Funcon implemented-floats-format : =&gt;float-formats ~&gt; binary64 . Funcon implemented-float-literal(FL:strings) : =&gt;implemented-floats . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#floating-point-numbers",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#floating-point-numbers"
  },"284": {
    "doc": "OC-L-02-Values",
    "title": "Characters",
    "content": "Character values are represented as 8-bit integers between 0 and 255. Character codes between 0 and 127 are interpreted following the ASCII standard. The current implementation interprets character codes between 128 and 255 following the ISO 8859-1 standard. Type implemented-characters &lt;: characters . Type implemented-character-points ~&gt; bounded-integers(0,255) . Funcon implemented-character(C:characters) : =&gt;implemented-characters? ~&gt; ascii-character[C] . // FIX-ME: allow ISO-Latin-1 . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#characters",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#characters"
  },"285": {
    "doc": "OC-L-02-Values",
    "title": "Character strings",
    "content": "String values are finite sequences of characters. The current implementation supports strings containing up to 2^24 - 5 characters (16777211 characters); (…) . Type implemented-strings &lt;: lists(implemented-characters) . Funcon implemented-string(L:lists(implemented-characters)) : =&gt;implemented-strings? ~&gt; when-true(is-less-or-equal(length list-elements L, 16777211), L) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#character-strings",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#character-strings"
  },"286": {
    "doc": "OC-L-02-Values",
    "title": "Tuples",
    "content": "Tuples of values are written (v_1, …, v_n), standing for the n-tuple of values v_1 to v_n. The current implementation supports tuples of up to 2^22 - 1 elements (4194303 elements). Type implemented-tuples &lt;: tuples(implemented-values*) ~&gt; tuples(values*) . // FIX-ME: remove . Funcon implemented-tuple(T:tuples(values*)) : =&gt;implemented-tuples? ~&gt; when-true(is-less-or-equal(length tuple-elements T, 4194303), T) . In OCaml Light, the unit value is represented by tuple( ). In OCaml Light, lists are written [v_1; …; v_n], and their values are represented by list values in CBS. Type implemented-lists &lt;: lists(implemented-values) ~&gt; lists(values) . // FIX-ME: remove . Funcon implemented-list(L:lists(values)) : =&gt;implemented-lists? ~&gt; when-true(is-less-or-equal(length list-elements L, 4194303), L) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#tuples",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#tuples"
  },"287": {
    "doc": "OC-L-02-Values",
    "title": "Records",
    "content": "Record values are labeled tuples of values. The record value written { field_1 = v_1; …; field_n = v_n } associates the value v_i to the record field field_i, for i = 1 … n. The current implementation supports records with up to 2^22 - 1 fields (4194303 fields). Type implemented-records &lt;: records(implemented-values) ~&gt; records(values) . // FIX-ME: remove . Funcon implemented-record(R:records(implemented-values)) : =&gt;implemented-records? ~&gt; when-true(is-less-or-equal(length map-elements record-map R, 4194303), R) . In OCaml Light, records are non-mutable, and references are represented by mutable variables. Type implemented-references ~&gt; variables . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#records",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#records"
  },"288": {
    "doc": "OC-L-02-Values",
    "title": "Arrays",
    "content": "Arrays are finite, variable-sized sequences of values of the same type. The current implementation supports arrays containing up to 2^22 - 1 elements (4194303 elements) unless the elements are floating-point numbers (2097151 elements in this case); (…) . Type implemented-vectors &lt;: vectors(implemented-values) ~&gt; vectors(values) . // FIX-ME: remove . Funcon implemented-vector(V:vectors(implemented-values)) : =&gt;implemented-vectors? ~&gt; when-true(is-less-or-equal(length vector-elements V, 4194303),V) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#arrays",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#arrays"
  },"289": {
    "doc": "OC-L-02-Values",
    "title": "Variant values",
    "content": "Variant values are either a constant constructor, or a pair of a non-constant constructor and a value. The former case is written constr; the latter case is written (v1, …, vn), where the vi are said to be the arguments of the non-constant constructor constr. The parentheses may be omitted if there is only one argument. (…) The current implementation limits each variant type to have at most 246 non-constant constructors and 2^30-1 constant constructors. Type implemented-variants &lt;: variants(implemented-values) ~&gt; variants(values) . // FIX-ME: remove . Funcon implemented-variant(V:variants(implemented-values)) : =&gt;implemented-variants ~&gt; V . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#variant-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#variant-values"
  },"290": {
    "doc": "OC-L-02-Values",
    "title": "Functions",
    "content": "Functional values are mappings from values to values. Type implemented-functions &lt;: functions(implemented-values, implemented-values) ~&gt; functions(values, values) . // FIX-ME: remove . Funcon implemented-function(F:functions(implemented-values, implemented-values)) : =&gt;implemented-functions ~&gt; F . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#functions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html#functions"
  },"291": {
    "doc": "OC-L-02-Values",
    "title": "OC-L-02-Values",
    "content": "Languages-beta : OC-L-02-Values.cbs | PRETTY | PDF . Outline . | 2 Values . | Base values . | Integer numbers | Floating-point numbers | Characters | Character strings | . | Tuples | Records | Arrays | Variant values | Functions | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-02-Values/index.html"
  },"292": {
    "doc": "OC-L-03-Names",
    "title": "3 Names",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#SectionNumber_3",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#SectionNumber_3"
  },"293": {
    "doc": "OC-L-03-Names",
    "title": "Naming objects",
    "content": "Syntax VN : value-name ::= lowercase-ident | '(' operator-name ')' ON : operator-name ::= prefix-op | infix-op PO : prefix-op ::= prefix-symbol . // added . // infix-op ::= infix-symbol // | '*' | '+' | '-' | '-.' | '=' | '&lt;' | '&gt;' | '||' | '&amp;' | '&amp;&amp;' // | '!=' | 'or' | ':=' | 'mod' // | 'land' | 'lor' | 'lxor' | 'lsl' | 'lsr' | 'asr' . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#naming-objects",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#naming-objects"
  },"294": {
    "doc": "OC-L-03-Names",
    "title": "Infix operator precedence",
    "content": "Syntax IO : infix-op ::= infix-op-1 | infix-op-2 | infix-op-3 | infix-op-4 | infix-op-5 | infix-op-6 | infix-op-7 | infix-op-8 Lexis IO-1 : infix-op-1 ::= '**' operator-char* | 'lsl' | 'lsr' | 'asr' IO-2 : infix-op-2 ::= '*' | '*' operator-char-not-asterisk operator-char* | ( '/' | '%' ) operator-char* | 'mod' | 'land' | 'lor' | 'lxor' IO-3 : infix-op-3 ::= ( '+' | '-' ) operator-char* IO-4 : infix-op-4 ::= ( '@' | '^' ) operator-char* IO-5 : infix-op-5 ::= ( '=' | '&lt;' | '&gt;' | '$' ) operator-char* | '|' ( operator-char-not-bar operator-char* )? | '||' operator-char+ | '&amp;' operator-char-not-ampersand operator-char* | '&amp;&amp;' operator-char+ | '!=' IO-6 : infix-op-6 ::= '&amp;' | '&amp;&amp;' IO-7 : infix-op-7 ::= 'or' | '||' IO-8 : infix-op-8 ::= ':=' Lexis CN : constr-name ::= capitalized-ident TCN : typeconstr-name ::= lowercase-ident FN : field-name ::= lowercase-ident MN : module-name ::= capitalized-ident . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#infix-operator-precedence",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#infix-operator-precedence"
  },"295": {
    "doc": "OC-L-03-Names",
    "title": "Referring to named objects",
    "content": "Syntax VP : value-path ::= value-name CSTR : constr ::= constr-name TCSTR : typeconstr ::= typeconstr-name F : field ::= field-name . Semantics value-name[[ _:value-path ]] : =&gt;ids Rule value-name[[ LI ]] = \\\"LI\\\" Rule value-name[[ '(' PS ')' ]] = string-append(\"(\", \\\"PS\\\", \")\") Rule value-name[[ '(' IO-1 ')' ]] = string-append(\"(\", \\\"IO-1\\\", \")\") Rule value-name[[ '(' IO-2 ')' ]] = string-append(\"(\", \\\"IO-2\\\", \")\") Rule value-name[[ '(' IO-3 ')' ]] = string-append(\"(\", \\\"IO-3\\\", \")\") Rule value-name[[ '(' IO-4 ')' ]] = string-append(\"(\", \\\"IO-4\\\", \")\") Rule value-name[[ '(' IO-5 ')' ]] = string-append(\"(\", \\\"IO-5\\\", \")\") Rule value-name[[ '(' IO-6 ')' ]] = string-append(\"(\", \\\"IO-6\\\", \")\") Rule value-name[[ '(' IO-7 ')' ]] = string-append(\"(\", \\\"IO-7\\\", \")\") Rule value-name[[ '(' IO-8 ')' ]] = string-append(\"(\", \\\"IO-8\\\", \")\") . Semantics constr-name[[ _:constr ]] : =&gt;ids Rule constr-name[[ CN ]] = \\\"CN\\\" . Semantics typeconstr-name[[ _:typeconstr ]] : =&gt;ids Rule typeconstr-name[[ TCN ]] = \\\"TCN\\\" . Semantics field-name[[ _:field ]] : =&gt;ids Rule field-name[[ FN ]] = \\\"FN\\\" . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#referring-to-named-objects",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html#referring-to-named-objects"
  },"296": {
    "doc": "OC-L-03-Names",
    "title": "OC-L-03-Names",
    "content": "Languages-beta : OC-L-03-Names.cbs | PRETTY | PDF . Outline . | 3 Names . | Naming objects . | Infix operator precedence | . | Referring to named objects | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-03-Names/index.html"
  },"297": {
    "doc": "OC-L-04-Type-Expressions",
    "title": "4 Type expressions",
    "content": "Syntax T : typexpr ::= '\\'' ident | '_' | '(' typexpr ')' | typexpr '-&gt;' typexpr | typexpr star-typexpr+ | typeconstr | typexpr typeconstr | '(' typexpr comma-typexpr+ ')' typeconstr ST : star-typexpr ::= '*' typexpr CT : comma-typexpr ::= ',' typexpr PT : poly-typexpr ::= typexpr | ( '\\'' ident )+ '.' typexpr . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-04-Type-Expressions/index.html#SectionNumber_4",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-04-Type-Expressions/index.html#SectionNumber_4"
  },"298": {
    "doc": "OC-L-04-Type-Expressions",
    "title": "OC-L-04-Type-Expressions",
    "content": "Languages-beta : OC-L-04-Type-Expressions.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-04-Type-Expressions/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-04-Type-Expressions/index.html"
  },"299": {
    "doc": "OC-L-05-Constants",
    "title": "5 Constants",
    "content": "Syntax CNST : constant ::= integer-literal | float-literal | char-literal | string-literal | constr | 'false' | 'true' | '(' ')' | 'begin' 'end' | '[' ']' | '[|' '|]' . Semantics value[[ _:constant ]] : =&gt;implemented-values Rule value[[ IL ]] = integer-value[[ IL ]] Rule value[[ FL ]] = float-value[[ FL ]] Rule value[[ CL ]] = character-value[[ CL ]] Rule value[[ SL ]] = string-value[[ SL ]] Rule value[[ CSTR ]] = bound(constr-name[[ CSTR ]]) Rule value[[ 'false' ]] = false Rule value[[ 'true' ]] = true Rule value[[ '(' ')' ]] = null Rule value[[ 'begin' 'end' ]] = null Rule value[[ '[' ']' ]] = nil Rule value[[ '[|' '|]' ]] = vector( ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-05-Constants/index.html#SectionNumber_5",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-05-Constants/index.html#SectionNumber_5"
  },"300": {
    "doc": "OC-L-05-Constants",
    "title": "OC-L-05-Constants",
    "content": "Languages-beta : OC-L-05-Constants.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-05-Constants/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-05-Constants/index.html"
  },"301": {
    "doc": "OC-L-06-Patterns",
    "title": "6 Patterns",
    "content": "Syntax P : pattern ::= value-name | '_' | constant | pattern 'as' value-name | '(' pattern ')' | '(' pattern ':' typexpr ')' | pattern '|' pattern | constr pattern | pattern comma-pattern+ | '{' field '=' pattern semic-field-pattern* ';'? '}' | '[' pattern semic-pattern* ';'? ']' | pattern '::' pattern CP : comma-pattern ::= ',' pattern SP : semic-pattern ::= ';' pattern SFP : semic-field-pattern ::= ';' field '=' pattern . Rule [[ '(' P ')' ]] : pattern = [[ P ]] Rule [[ '(' P ':' T ')' ]] : pattern = [[ P ]] Rule [[ '{' F '=' P SFP* ';' '}' ]] : pattern = [[ '{' F '=' P SFP* '}' ]] Rule [[ '[' P SP* ';' ']' ]] : pattern = [[ '[' P SP* ']' ]] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#SectionNumber_6",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#SectionNumber_6"
  },"302": {
    "doc": "OC-L-06-Patterns",
    "title": "Pattern evaluation",
    "content": "Semantics evaluate-pattern[[ _:pattern ]] : =&gt;patterns Rule evaluate-pattern[[ VN ]] = pattern-bind(value-name[[ VN ]]) Rule evaluate-pattern[[ '_' ]] = pattern-any Rule evaluate-pattern[[ CNST ]] = value[[ CNST ]] Rule evaluate-pattern[[ P 'as' VN ]] = pattern-unite(evaluate-pattern[[ P ]], pattern-bind(value-name[[ VN ]])) Rule evaluate-pattern[[ P1 '|' P2 ]] = pattern-else(evaluate-pattern[[ P1 ]], evaluate-pattern[[ P2 ]]) Rule evaluate-pattern[[ CSTR P ]] = variant(constr-name[[ CSTR ]], evaluate-pattern[[ P ]]) Rule evaluate-pattern[[ P1 ',' P2 CP* ]] = tuple( evaluate-comma-pattern-sequence[[ P1 ',' P2 CP* ]] ) Rule evaluate-pattern[[ '{' F '=' P SFP* '}' ]] = pattern closure(match-loosely( given, record(map-unite(evaluate-field-pattern-sequence[[ F '=' P SFP* ]])))) Rule evaluate-pattern[[ '[' P SP* ']' ]] = [ evaluate-semic-pattern-sequence[[ P SP* ]] ] Rule evaluate-pattern[[ P1 '::' P2 ]] = pattern closure( if-true-else(is-equal(given,[]), fail, collateral( match(head(given), evaluate-pattern[[ P1 ]]), match(tail(given), evaluate-pattern[[ P2 ]])))) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#pattern-evaluation",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#pattern-evaluation"
  },"303": {
    "doc": "OC-L-06-Patterns",
    "title": "Pattern sequence evaluation",
    "content": "Semantics evaluate-comma-pattern-sequence[[ _:(pattern comma-pattern*) ]] : (=&gt;patterns)+ Rule evaluate-comma-pattern-sequence[[ P1 ',' P2 CP* ]] = evaluate-pattern[[ P1 ]], evaluate-comma-pattern-sequence[[ P2 CP* ]] Rule evaluate-comma-pattern-sequence[[ P ]] = evaluate-pattern[[ P ]] . Semantics evaluate-semic-pattern-sequence[[ _:(pattern semic-pattern*) ]] : (=&gt;patterns)+ Rule evaluate-semic-pattern-sequence[[ P1 ';' P2 SP* ]] = evaluate-pattern[[ P1 ]], evaluate-semic-pattern-sequence[[ P2 SP* ]] Rule evaluate-semic-pattern-sequence[[ P ]] = evaluate-pattern[[ P ]] . Semantics evaluate-field-pattern-sequence[[ _:(field '=' pattern semic-field-pattern*) ]] : =&gt;(maps(ids,patterns))+ Rule evaluate-field-pattern-sequence[[ F1 '=' P1 ';' F2 '=' P2 SFP* ]] = ( { field-name[[ F1 ]] |-&gt; evaluate-pattern[[ P1 ]] }, evaluate-field-pattern-sequence[[ F2 '=' P2 SFP* ]] ) Rule evaluate-field-pattern-sequence[[ F '=' P ]] = { field-name[[ F ]] |-&gt; evaluate-pattern[[ P ]] } . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#pattern-sequence-evaluation",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html#pattern-sequence-evaluation"
  },"304": {
    "doc": "OC-L-06-Patterns",
    "title": "OC-L-06-Patterns",
    "content": "Languages-beta : OC-L-06-Patterns.cbs | PRETTY | PDF . Outline . | 6 Patterns . | Pattern evaluation | Pattern sequence evaluation | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-06-Patterns/index.html"
  },"305": {
    "doc": "OC-L-07-Expressions",
    "title": "7 Expressions",
    "content": "Syntax E : expr ::= value-path | constant | '(' expr ')' | 'begin' expr 'end' | '(' expr ':' typexpr ')' | expr comma-expr+ // | constr expr // ambiguous! | expr '::' expr | '[' expr semic-expr* ']' | '[' expr semic-expr* ';' ']' | '[|' expr semic-expr* '|]' | '[|' expr semic-expr* ';' '|]' | '{' field '=' expr semic-field-expr* '}' | '{' field '=' expr semic-field-expr* ';' '}' | '{' expr 'with' field '=' expr semic-field-expr* '}' | '{' expr 'with' field '=' expr semic-field-expr* ';' '}' | expr argument+ | prefix-symbol expr | '-' expr | '-.' expr | expr infix-op-1 expr | expr infix-op-2 expr | expr infix-op-3 expr | expr infix-op-4 expr | expr infix-op-5 expr | expr infix-op-6 expr | expr infix-op-7 expr | expr infix-op-8 expr | expr '.' field | expr '.(' expr ')' | expr '.(' expr ')' '&lt;-' expr | 'if' expr 'then' expr ( 'else' expr )? | 'while' expr 'do' expr 'done' | 'for' value-name '=' expr ('to'|'downto') expr 'do' expr 'done' | expr ';' expr | 'match' expr 'with' pattern-matching | 'function' pattern-matching | 'fun' pattern+ '-&gt;' expr | 'try' expr 'with' pattern-matching | let-definition 'in' expr | 'assert' expr A : argument ::= expr PM : pattern-matching ::= pattern '-&gt;' expr pattern-expr* | '|' pattern '-&gt;' expr pattern-expr* LD : let-definition ::= 'let' ('rec')? let-binding and-let-binding* LB : let-binding ::= pattern '=' expr | value-name pattern+ '=' expr // using pattern* was ambiguous! | value-name ':' poly-typexpr '=' expr ALB : and-let-binding ::= 'and' let-binding CE : comma-expr ::= ',' expr SE : semic-expr ::= ';' expr SFE : semic-field-expr ::= ';' field '=' expr PE : pattern-expr ::= '|' pattern '-&gt;' expr . Rule [[ '(' E ')' ]] : expr = [[ E ]] Rule [[ 'begin' E 'end' ]] : expr = [[ E ]] Rule [[ '(' E ':' T ')' ]] : expr = [[ E ]] Rule [[ E1 E2 A A* ]] : expr = [[ ( '(' E1 E2 ')' ) A A* ]] // FIX-ME: \"... E+\" not yet supported Rule [[ PS E ]] : expr = [[ ( '(' PS ')' ) E ]] Rule [[ '-' E ]] : expr = [[ ( '(' '~-' ')' ) E ]] Rule [[ '-.' E ]] : expr = [[ ( '(' '~-.' ')' ) E ]] Rule [[ E1 IO-1 E2 ]] : expr = [[ ( '(' IO-1 ')' ) E1 E2 ]] Rule [[ E1 IO-2 E2 ]] : expr = [[ ( '(' IO-2 ')' ) E1 E2 ]] Rule [[ E1 IO-3 E2 ]] : expr = [[ ( '(' IO-3 ')' ) E1 E2 ]] Rule [[ E1 IO-4 E2 ]] : expr = [[ ( '(' IO-4 ')' ) E1 E2 ]] Rule [[ E1 IO-5 E2 ]] : expr = [[ ( '(' IO-5 ')' ) E1 E2 ]] Rule [[ E1 '&amp;' E2 ]] : expr = [[ E1 '&amp;&amp;' E2 ]] Rule [[ E1 'or' E2 ]] : expr = [[ E1 '||' E2 ]] Rule [[ E1 IO-8 E2 ]] : expr = [[ ( '(' IO-8 ')' ) E1 E2 ]] Rule [[ E1 '.(' E2 ')' ]] : expr = [[ 'array_get' E1 E2 ]] Rule [[ E1 '.(' E2 ')' '&lt;-' E3 ]] : expr = [[ 'array_set' E1 E2 E3 ]] Rule [[ 'if' E1 'then' E2 ]] : expr = [[ 'if' E1 'then' E2 'else' ( '(' ')' ) ]] Rule [[ 'fun' P '-&gt;' E ]] : expr = [[ 'function' P '-&gt;' E ]] Rule [[ 'fun' P P+ '-&gt;' E ]] : expr = [[ 'fun' P '-&gt;' ( 'fun' P+ '-&gt;' E ) ]] Rule [[ '[' E SE* ';' ']' ]] : expr = [[ '[' E SE* ']' ]] Rule [[ '[|' E SE* ';' '|]' ]] : expr = [[ '[|' E SE* '|]' ]] Rule [[ '{' F '=' E SFE* ';' '}' ]] : expr = [[ '{' F '=' E SFE* '}' ]] Rule [[ '{' E1 'with' F '=' E2 SFE* ';' '}' ]] : expr = [[ '{' E1 'with' F '=' E2 SFE* '}' ]] Rule [[ '|' P '-&gt;' E PE* ]] : pattern-matching = [[ P '-&gt;' E PE* ]] Rule [[ VN ':' PT '=' E ]] : let-binding = [[ VN '=' E ]] Rule [[ VN P+ '=' E ]] : let-binding = [[ VN '=' ( 'fun' P+ '-&gt;' E ) ]] . Semantics evaluate[[ _:expr ]] : =&gt;implemented-values Rule evaluate[[ VP ]] = bound(value-name[[ VP ]]) Rule evaluate[[ CNST ]] = value[[ CNST ]] Rule evaluate[[ '(' E ':' T ')' ]] = evaluate[[ E ]] Rule evaluate[[ E1 ',' E2 CE* ]] = tuple( evaluate-comma-sequence[[ E1 ',' E2 CE* ]] ) Rule evaluate[[ E1 '::' E2 ]] = cons(evaluate[[ E1 ]], evaluate[[ E2 ]]) Rule evaluate[[ '[' E SE* ']' ]] = [ evaluate-semic-sequence [[ E SE* ]] ] Rule evaluate[[ '[|' E SE* '|]' ]] = vector(left-to-right-map( allocate-initialised-variable(implemented-values, given), evaluate-semic-sequence[[ E SE* ]])) Rule evaluate[[ '[|' '|]' ]] = vector( ) Rule evaluate[[ '{' F '=' E SFE* '}' ]] = record(collateral( evaluate-field-sequence[[ F '=' E SFE* ]] )) Rule evaluate[[ '{' E1 'with' F '=' E2 SFE* '}' ]] = record( map-override( evaluate-field-sequence[[ F '=' E2 SFE* ]], checked record-map(evaluate[[E1]]))) Rule evaluate[[ CSTR E ]] = variant(constr-name[[ CSTR ]], evaluate[[ E ]]) Otherwise evaluate[[ E1 E2 ]] = apply(evaluate[[ E1 ]], evaluate[[ E2 ]]) Rule evaluate[[ E '.' F ]] = record-select(evaluate[[ E ]], field-name[[ F ]]) Rule evaluate[[ E1 '&amp;&amp;' E2 ]] = if-true-else(evaluate[[ E1 ]], evaluate[[ E2 ]], false) Rule evaluate[[ E1 '||' E2 ]] = if-true-else(evaluate[[ E1 ]], true, evaluate[[ E2 ]]) Rule evaluate[[ 'if' E1 'then' E2 'else' E3 ]] = if-true-else(evaluate[[ E1 ]], evaluate[[ E2 ]], evaluate[[ E3 ]]) Rule evaluate[[ 'while' E1 'do' E2 'done' ]] = while(evaluate[[ E1 ]], effect(evaluate[[ E2 ]])) Rule evaluate[[ 'for' VN '=' E1 'to' E2 'do' E3 'done' ]] = effect(left-to-right-map( case-match(pattern-bind(value-name[[ VN ]]), evaluate[[ E3 ]]), integer-sequence(evaluate[[ E1 ]], evaluate[[ E2 ]]))) Rule evaluate[[ 'for' VN '=' E1 'downto' E2 'do' E3 'done' ]] = effect(left-to-right-map( case-match(pattern-bind(value-name[[ VN ]]), evaluate[[ E3 ]]), reverse integer-sequence(evaluate[[ E2 ]], evaluate[[ E1 ]]))) Rule evaluate[[ E1 ';' E2 ]] = sequential(effect(evaluate[[ E1 ]]), evaluate[[ E2 ]]) Rule evaluate[[ 'match' E 'with' PM ]] = give(evaluate[[ E ]], else(match[[ PM ]], throw(ocaml-light-match-failure))) Rule evaluate[[ 'function' PM ]] = function closure( else(match[[ PM ]], throw(ocaml-light-match-failure))) Rule evaluate[[ 'try' E 'with' PM ]] = handle-thrown( evaluate[[ E ]], else(match[[ PM ]], throw(given))) Rule evaluate[[ LD 'in' E ]] = scope(define-values[[ LD ]], evaluate[[ E ]]) Rule evaluate [[ 'assert' E ]] = else(check-true(evaluate[[ E ]]), throw(ocaml-light-assert-failure)) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#SectionNumber_7",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#SectionNumber_7"
  },"306": {
    "doc": "OC-L-07-Expressions",
    "title": "Expression sequences and maps",
    "content": "Semantics evaluate-comma-sequence[[ _:(expr comma-expr*) ]] : (=&gt;implemented-values)+ Rule evaluate-comma-sequence[[ E1 ',' E2 CE* ]] = evaluate[[ E1 ]], evaluate-comma-sequence[[ E2 CE* ]] Rule evaluate-comma-sequence[[ E ]] = evaluate[[ E ]] . Semantics evaluate-semic-sequence[[ _:(expr semic-expr*) ]] : (=&gt;implemented-values)+ Rule evaluate-semic-sequence[[ E1 ';' E2 SE* ]] = evaluate[[ E1 ]], evaluate-semic-sequence[[ E2 SE* ]] Rule evaluate-semic-sequence[[ E ]] = evaluate[[ E ]] . Semantics evaluate-field-sequence[[ _:(field '=' expr semic-field-expr*) ]] : (=&gt;envs)+ Rule evaluate-field-sequence[[ F1 '=' E1 ';' F2 '=' E2 SFE* ]] = { field-name[[ F1 ]] |-&gt; evaluate[[ E1 ]] }, evaluate-field-sequence[[ F2 '=' E2 SFE* ]] Rule evaluate-field-sequence[[ F '=' E ]] = { field-name[[ F ]] |-&gt; evaluate[[ E ]] } . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#expression-sequences-and-maps",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#expression-sequences-and-maps"
  },"307": {
    "doc": "OC-L-07-Expressions",
    "title": "Matching",
    "content": "Semantics match[[ _:pattern-matching ]] : (implemented-values=&gt;implemented-values)+ Rule match[[ P1 '-&gt;' E1 '|' P2 '-&gt;' E2 PE* ]] = match[[ P1 '-&gt;' E1 ]], match[[ P2 '-&gt;' E2 PE* ]] Rule match[[ P '-&gt;' E ]] = case-match(evaluate-pattern[[ P ]], evaluate[[ E ]]) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#matching",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#matching"
  },"308": {
    "doc": "OC-L-07-Expressions",
    "title": "Value definitions",
    "content": "Semantics define-values[[ _:let-definition ]] : =&gt;environments Rule define-values[[ 'let' LB ALB* ]] = define-values-nonrec[[ LB ALB* ]] Rule define-values[[ 'let rec' LB ALB* ]] = recursive( set(bound-ids-sequence[[ LB ALB* ]]), define-values-nonrec[[ LB ALB* ]]) . Semantics define-values-nonrec[[ _:(let-binding and-let-binding*) ]] : =&gt;environments Rule define-values-nonrec[[ LB1 'and' LB2 ALB* ]] = collateral(define-values-nonrec[[ LB1 ]], define-values-nonrec[[ LB2 ALB* ]]) Rule define-values-nonrec[[ P '=' E ]] = else( match(evaluate[[ E ]], evaluate-pattern[[ P ]]), throw(ocaml-light-match-failure)) . Semantics bound-ids-sequence[[ _:(let-binding and-let-binding*) ]] : ids+ Rule bound-ids-sequence[[ LB ]] = bound-id[[ LB ]] Rule bound-ids-sequence[[ LB1 'and' LB2 ALB* ]] = bound-id[[ LB1 ]], bound-ids-sequence[[ LB2 ALB* ]] . Semantics bound-id[[ _:let-binding ]] : ids Rule bound-id[[ VN '=' E ]] = value-name[[ VN ]] Otherwise bound-id[[ LB ]] = fail . // implementation-dependent . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#value-definitions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html#value-definitions"
  },"309": {
    "doc": "OC-L-07-Expressions",
    "title": "OC-L-07-Expressions",
    "content": "Languages-beta : OC-L-07-Expressions.cbs | PRETTY | PDF . Outline . | 7 Expressions . | Expression sequences and maps | Matching | Value definitions | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-07-Expressions/index.html"
  },"310": {
    "doc": "OC-L-08-Type-and-Exception-Definitions",
    "title": "8 Type and exception definitions",
    "content": "Syntax TDS : type-definition ::= 'type' typedef and-typedef* ATD : and-typedef ::= 'and' typedef TD : typedef ::= type-params? typeconstr-name type-information TI : type-information ::= type-equation? type-representation? type-constraint* TE : type-equation ::= '=' typexpr TR : type-representation ::= '=' '|'? constr-decl bar-constr-decl* | '=' record-decl BCD : bar-constr-decl ::= '|' constr-decl TPS : type-params ::= type-param | '(' type-param (',' type-param)* ')' TP : type-param ::= variance? '\\'' ident variance ::= '+' | '-' RD : record-decl ::= '{' field-decl ( ';' field-decl )* ';'? '}' CD : constr-decl ::= ( constr-name | '[' ']' | '(::)' ) ( 'of' constr-args )? CA : constr-args ::= typexpr star-typexpr* FD : field-decl ::= field-name ':' poly-typexpr ED : exception-definition ::= 'exception' constr-decl | 'exception' constr-name '=' constr TC : type-constraint ::= 'constraint' '\\'' ident '=' typexpr . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#SectionNumber_8",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#SectionNumber_8"
  },"311": {
    "doc": "OC-L-08-Type-and-Exception-Definitions",
    "title": "Type definitions",
    "content": "Semantics define-types[[ _:type-definition ]] : =&gt;environments Rule define-types[[ 'type' TD ATD* ]] = collateral( define-typedefs[[ TD ATD* ]] ) . Semantics define-typedefs[[ _:(typedef and-typedef*)]] : (=&gt;environments)+ Rule define-typedefs[[ TD1 'and' TD2 ATD* ]] = define-typedefs[[ TD2 ]], define-typedefs[[ TD2 ATD* ]] Rule define-typedefs[[ TPS? TCN '=' CD BCD* ]] = define-constrs[[ CD BCD* ]] Rule define-typedefs[[ TPS? TCN '=' RD ]] = map( ) Rule define-typedefs[[ TPS? TCN '=' T ]] = map( ) . Semantics define-constrs[[ _:(constr-decl bar-constr-decl*)]] : (=&gt;environments)+ Rule define-constrs[[ CD1 '|' CD2 BCD* ]] = define-constrs[[ CD1 ]], define-constrs[[ CD2 BCD* ]] Rule define-constrs[[ CN ]] = { constr-name[[ CN ]] |-&gt; variant(constr-name[[ CN ]],tuple( )) } Rule define-constrs[[ CN 'of' CA ]] = { constr-name[[ CN ]] |-&gt; function closure(variant(constr-name[[ CN ]], given)) } . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#type-definitions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#type-definitions"
  },"312": {
    "doc": "OC-L-08-Type-and-Exception-Definitions",
    "title": "Exception definitions",
    "content": "Semantics define-exception[[ _:exception-definition ]] : =&gt;environments Rule define-exception[[ 'exception' CD ]] = define-constrs[[ CD ]] Rule define-exception[[ 'exception' CN '=' CSTR ]] = map( ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#exception-definitions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html#exception-definitions"
  },"313": {
    "doc": "OC-L-08-Type-and-Exception-Definitions",
    "title": "OC-L-08-Type-and-Exception-Definitions",
    "content": "Languages-beta : OC-L-08-Type-and-Exception-Definitions.cbs | PRETTY | PDF . Outline . | 8 Type and exception definitions . | Type definitions | Exception definitions | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-08-Type-and-Exception-Definitions/index.html"
  },"314": {
    "doc": "OC-L-09-Classes",
    "title": "9 Classes",
    "content": "Omitted . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-09-Classes/index.html#SectionNumber_9",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-09-Classes/index.html#SectionNumber_9"
  },"315": {
    "doc": "OC-L-09-Classes",
    "title": "OC-L-09-Classes",
    "content": "Languages-beta : OC-L-09-Classes.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-09-Classes/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-09-Classes/index.html"
  },"316": {
    "doc": "OC-L-10-Module-Types",
    "title": "10 Module types",
    "content": "Omitted . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-10-Module-Types/index.html#SectionNumber_10",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-10-Module-Types/index.html#SectionNumber_10"
  },"317": {
    "doc": "OC-L-10-Module-Types",
    "title": "OC-L-10-Module-Types",
    "content": "Languages-beta : OC-L-10-Module-Types.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-10-Module-Types/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-10-Module-Types/index.html"
  },"318": {
    "doc": "OC-L-11-Module-Implementations",
    "title": "11 Module implementations",
    "content": "Syntax UI : unit-implementation ::= (semicolon-pair* module-items semicolon-pair*)? MIS : module-items ::= definition | expr | module-items semicolon-pair* module-item MI : module-item ::= definition | semicolon-pair expr D : definition ::= let-definition | type-definition | exception-definition Lexis SCP : semicolon-pair ::= ';;' . Semantics interpret[[ UI:unit-implementation ]] : =&gt;environments Rule interpret[[ ]] = map( ) Rule interpret[[ SCP1* MIS SCP2* ]] = handle-thrown( scope( ocaml-light-core-library, accumulate(define-or-evaluate-items[[ MIS ]])), sequential( print (\"Uncaught exception: \", ocaml-light-to-string given, \"\\n\"), map())) . Semantics define-or-evaluate-items[[ _:module-items ]] : (=&gt;envs)+ Rule define-or-evaluate-items[[ LD ]] = ocaml-light-define-and-display define-values[[ LD ]] Rule define-or-evaluate-items[[ TDS ]] = define-types[[ TDS ]] Rule define-or-evaluate-items[[ ED ]] = define-exception[[ ED ]] Rule define-or-evaluate-items[[ E ]] = ocaml-light-evaluate-and-display evaluate[[ E ]] Rule define-or-evaluate-items[[ MIS SCP* D ]] = ( define-or-evaluate-items[[ MIS ]], define-or-evaluate-items[[ D ]] ) Rule define-or-evaluate-items[[ MIS SCP* SCP E ]] = ( define-or-evaluate-items[[ MIS ]], define-or-evaluate-items[[ E ]] ) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-11-Module-Implementations/index.html#SectionNumber_11",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-11-Module-Implementations/index.html#SectionNumber_11"
  },"319": {
    "doc": "OC-L-11-Module-Implementations",
    "title": "OC-L-11-Module-Implementations",
    "content": "Languages-beta : OC-L-11-Module-Implementations.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-11-Module-Implementations/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-11-Module-Implementations/index.html"
  },"320": {
    "doc": "OC-L-12-Core-Library",
    "title": "12 Core library",
    "content": "[ Funcon ocaml-light-core-library Funcon ocaml-light-match-failure Funcon ocaml-light-is-structurally-equal Funcon ocaml-light-to-string Funcon ocaml-light-define-and-display Funcon ocaml-light-evaluate-and-display ] . Meta-variables R, S, S1, S2, S3, T, U &lt;: values S* &lt;: values* T+ &lt;: values+ . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#SectionNumber_12",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#SectionNumber_12"
  },"321": {
    "doc": "OC-L-12-Core-Library",
    "title": "Abbreviations",
    "content": "The following funcons take computations X and return (curried) functions. X refers to a single function argument as arg, or to individual arguments of a curried function of several arguments as arg-1, arg-2, arg-3. Auxiliary Funcon op-1(X:S=&gt;T) : =&gt;functions(S,T) ~&gt; function abstraction X . Auxiliary Funcon op-2(X:tuples(S1,S2)=&gt;T) : =&gt;functions(S1, functions(S2,T)) ~&gt; curry function abstraction X . Auxiliary Funcon op-3(X:tuples(S1,S2,S3)=&gt;T) : =&gt;functions(S1, functions(S2, functions(S3, T))) ~&gt; function abstraction( curry partial-apply-first(function abstraction X, given)) . Auxiliary Funcon partial-apply-first(F:functions(tuples(R,S,T+),U), V:R) : =&gt;functions(tuples(S,T+),U) ~&gt; function abstraction(apply(F, tuple(V, tuple-elements given))) . partial-apply-first(F, V) provides V as the first argument to a function expecting a tuple of 3 or more arguments, returning a function expecting a tuple of one fewer arguments. Auxiliary Funcon arg : T=&gt;T ~&gt; given . Auxiliary Funcon arg-1 : tuples(S1,S*)=&gt;S1 ~&gt; checked index(1, tuple-elements given) . Auxiliary Funcon arg-2 : tuples(S1,S2,S*)=&gt;S2 ~&gt; checked index(2, tuple-elements given) . Auxiliary Funcon arg-3 : tuples(S1,S2,S3,S*)=&gt;S3 ~&gt; checked index(3, tuple-elements given) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#abbreviations",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#abbreviations"
  },"322": {
    "doc": "OC-L-12-Core-Library",
    "title": "Library",
    "content": "The ocaml-light-core-library environment maps most of the names defined in OCaml Module Pervasives (the initially opened module) to funcon terms. See https://caml.inria.fr/pub/docs/manual-ocaml-4.06/core.html for further details and comments. It also maps some other names defined in the OCaml Standard Libarary to funcon terms (to support tests using them without opening those modules). Funcon ocaml-light-core-library : =&gt;environments ~&gt; {// Predefined exceptions \"Match_failure\" |-&gt; op-1(variant(\"Match_failure\", arg)), \"Invalid_argument\" |-&gt; op-1(variant(\"Invalid_argument\", arg)), \"Division_by_zero\" |-&gt; variant(\"Division_by_zero\", tuple( )), // Exceptions \"raise\" |-&gt; op-1(throw(arg)), //Comparisons \"(=)\" |-&gt; op-2(ocaml-light-is-structurally-equal(arg-1, arg-2)), \"(&lt;&gt;)\" |-&gt; op-2(not(ocaml-light-is-structurally-equal(arg-1, arg-2))), \"(&lt;)\" |-&gt; op-2(is-less(arg-1, arg-2)), \"(&gt;)\" |-&gt; op-2(is-greater(arg-1, arg-2)), \"(&lt;=)\" |-&gt; op-2(is-less-or-equal(arg-1, arg-2)), \"(&gt;=)\" |-&gt; op-2(is-greater-or-equal(arg-1, arg-2)), \"min\" |-&gt; op-2(if-true-else(is-less(arg-1, arg-2), arg-1, arg-2)), \"max\" |-&gt; op-2(if-true-else(is-greater(arg-1, arg-2), arg-1, arg-2)), \"(==)\" |-&gt; op-2(if-true-else( and(is-in-type(arg-1, ground-values), is-in-type(arg-2, ground-values)), is-equal(arg-1, arg-2), throw(variant(\"Invalid_argument\", \"equal: functional value\")))), \"(!=)\" |-&gt; op-2(if-true-else( and(is-in-type(arg-1, ground-values), is-in-type(arg-2, ground-values)), not is-equal(arg-1, arg-2), throw(variant(\"Invalid_argument\", \"equal: functional value\")))), // Boolean operations (excluding lazy conditionals) \"not\" |-&gt; op-1(not(arg)), // Integer arithmetic \"(~-)\" |-&gt; op-1(implemented-integer integer-negate(arg)), \"(~+)\" |-&gt; op-1(implemented-integer arg), \"succ\" |-&gt; op-1(implemented-integer integer-add(arg, 1)), \"pred\" |-&gt; op-1(implemented-integer integer-subtract(arg, 1)), \"(+)\" |-&gt; op-2(implemented-integer integer-add(arg-1, arg-2)), \"(-)\" |-&gt; op-2(implemented-integer integer-subtract(arg-1, arg-2)), \"(*)\" |-&gt; op-2(implemented-integer integer-multiply(arg-1, arg-2)), \"(/)\" |-&gt; op-2(implemented-integer if-true-else(is-equal(arg-2, 0), throw(variant(\"Division_by_zero\", tuple( ))), checked integer-divide(arg-1, arg-2))), \"(mod)\" |-&gt; op-2(implemented-integer checked integer-modulo(arg-1, arg-2)), \"abs\" |-&gt; op-1(implemented-integer integer-absolute-value(arg)), \"max_int\" |-&gt; op-1(signed-bit-vector-maximum(implemented-integers-width)), \"min_int\" |-&gt; op-1(signed-bit-vector-minimum(implemented-integers-width)), // Bitwise operations \"(land)\" |-&gt; op-2(bit-vector-to-integer bit-vector-and(implemented-bit-vector arg-1, implemented-bit-vector arg-2)), \"(lor)\" |-&gt; op-2(bit-vector-to-integer bit-vector-or(implemented-bit-vector arg-1, implemented-bit-vector arg-2)), \"(lxor)\" |-&gt; op-2(bit-vector-to-integer bit-vector-xor(implemented-bit-vector arg-1, implemented-bit-vector arg-2)), \"lnot\" |-&gt; op-1(bit-vector-to-integer bit-vector-not(implemented-bit-vector arg)), \"(lsl)\" |-&gt; op-2(bit-vector-to-integer bit-vector-shift-left(implemented-bit-vector arg-1, arg-2)), \"(lsr)\" |-&gt; op-2(bit-vector-to-integer bit-vector-logical-shift-right(implemented-bit-vector arg-1, arg-2)), \"(asr)\" |-&gt; op-2(bit-vector-to-integer bit-vector-arithmetic-shift-right(implemented-bit-vector arg-1, arg-2)), // Floating-point arithmetic \"(~-.)\" |-&gt; op-1(float-negate(implemented-floats-format, arg)), \"(~+.)\" |-&gt; op-1(arg), \"(+.)\" |-&gt; op-2(float-add(implemented-floats-format, arg-1, arg-2)), \"(-.)\" |-&gt; op-2(float-subtract(implemented-floats-format, arg-1, arg-2)), \"(*.)\" |-&gt; op-2(float-multiply(implemented-floats-format, arg-1, arg-2)), \"(/.)\" |-&gt; op-2(float-divide(implemented-floats-format, arg-1, arg-2)), \"(**)\" |-&gt; op-2(float-float-power(implemented-floats-format, arg-1, arg-2)), \"sqrt\" |-&gt; op-1(float-sqrt(implemented-floats-format, arg)), \"exp\" |-&gt; op-1(float-exp(implemented-floats-format, arg)), \"log\" |-&gt; op-1(float-log(implemented-floats-format, arg)), \"log10\" |-&gt; op-1(float-log10(implemented-floats-format, arg)), \"cos\" |-&gt; op-1(float-cos(implemented-floats-format, arg)), \"sin\" |-&gt; op-1(float-sin(implemented-floats-format, arg)), \"tan\" |-&gt; op-1(float-tan(implemented-floats-format, arg)), \"acos\" |-&gt; op-1(float-acos(implemented-floats-format, arg)), \"asin\" |-&gt; op-1(float-asin(implemented-floats-format, arg)), \"atan\" |-&gt; op-1(float-atan(implemented-floats-format, arg)), \"atan2\" |-&gt; op-2(float-atan2(implemented-floats-format, arg-1, arg-2)), \"cosh\" |-&gt; op-1(float-cosh(implemented-floats-format, arg)), \"sinh\" |-&gt; op-1(float-sinh(implemented-floats-format, arg)), \"tanh\" |-&gt; op-1(float-tanh(implemented-floats-format, arg)), \"ceil\" |-&gt; op-1(implemented-integer float-ceiling(implemented-floats-format, arg)), \"floor\" |-&gt; op-1(implemented-integer float-floor(implemented-floats-format, arg)), \"abs_float\" |-&gt; op-1(float-absolute-value(implemented-floats-format, arg)), \"mod_float\" |-&gt; op-2(float-remainder(implemented-floats-format, arg-1, arg-2)), \"int_of_float\" |-&gt; op-1(implemented-integer float-truncate(implemented-floats-format, arg)), \"float_of_int\" |-&gt; op-1(implemented-float-literal(string-append(to-string(arg), \".0\"))), // String operations \"(^)\" |-&gt; op-2(string-append(arg-1, arg-2)), // String conversion operations \"string_of_int\" |-&gt; op-1(to-string(arg)), \"int_of_string\" |-&gt; op-1(implemented-integer implemented-integer-literal(arg)), \"string_of_float\" |-&gt; op-1(to-string(arg)), \"float_of_string\" |-&gt; op-1(implemented-float-literal(arg)), // List operations \"(@)\" |-&gt; op-2(list-append(arg-1, arg-2)), // Input/output // Output functions on standard output \"print_char\" |-&gt; op-1(print(to-string(arg))), \"print_string\" |-&gt; op-1(print(arg)), \"print_int\" |-&gt; op-1(print(to-string(arg))), \"print_float\" |-&gt; op-1(print(to-string(arg))), \"print_newline\" |-&gt; op-1(print \"\\n\"), // Input functions on standard input \"read_line\" |-&gt; op-1(read), \"read_int\" |-&gt; op-1(implemented-integer-literal(read)), \"read_float\" |-&gt; op-1(implemented-float-literal(read)), // References (not represented as mutable records) \"ref\" |-&gt; op-1(allocate-initialised-variable(implemented-values, arg)), \"(!)\" |-&gt; op-1(assigned(arg)), \"(:=)\" |-&gt; op-2(assign(arg-1, arg-2)), // Module List \"length\" |-&gt; op-1(implemented-integer list-length(arg)), \"cons\" |-&gt; op-2(cons(arg-1, arg-2)), \"hd\" |-&gt; op-1(else(head(arg), throw(variant(\"Failure\", \"hd\")))), \"tl\" |-&gt; op-1(else(tail(arg), throw(variant(\"Failure\", \"tl\")))), \"rev\" |-&gt; op-1(list(reverse(list-elements(arg)))), // Module Array \"array_length\" |-&gt; op-1(implemented-integer length(vector-elements(arg))), \"array_make\" |-&gt; op-2(if-true-else(is-greater-or-equal(arg-1, 0), vector(interleave-map( allocate-initialised-variable(values, arg), n-of(arg-1, arg-2))), throw(variant(\"Invalid_argument\", \"array_make\")))), \"array_append\" |-&gt; op-2(vector(vector-elements(arg-1), vector-elements(arg-2))), \"array_get\" |-&gt; op-2(else(assigned(checked index(nat-succ arg-2, vector-elements(arg-1))), throw(variant(\"Invalid_argument\", \"array_get\")))), \"array_set\" |-&gt; op-3(else(assign(checked index(nat-succ arg-2, vector-elements(arg-1)), arg-3), throw(variant(\"Invalid_argument\", \"array_set\")))) } . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#library",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#library"
  },"323": {
    "doc": "OC-L-12-Core-Library",
    "title": "Language-specific funcons",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#language-specific-funcons",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#language-specific-funcons"
  },"324": {
    "doc": "OC-L-12-Core-Library",
    "title": "Exception values",
    "content": "Funcon ocaml-light-match-failure : =&gt;variants(tuples(strings, integers, integers)) ~&gt; variant(\"Match_failure\", tuple(\"\", 0, 0)) . ocaml-light-match-failure gives a value to be thrown when a match fails. The variant value should consist of the source program text, line, and column, but these are currently not included in the translation of OCaml Light. Funcon ocaml-light-assert-failure : =&gt;variants(tuples(strings, integers, integers)) ~&gt; variant(\"Assert_failure\", tuple(\"\", 0, 0)) . ocaml-light-assert-failure gives a value to be thrown when an assertion fails. The variant value should consist of the source program text, line, and column, but these are currently not included in the translation of OCaml Light. ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#exception-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#exception-values"
  },"325": {
    "doc": "OC-L-12-Core-Library",
    "title": "Structural equality",
    "content": "Funcon ocaml-light-is-structurally-equal(_:implemented-values, _:implemented-values) : =&gt;booleans . ocaml-light-is-structurally-equal(V1, V2) is false whenever V1 or V2 contains a function. For vectors, it compares all their respective assigned values. It is equality on primitive values, and defined inductively on composite values. Unit Type . Rule ocaml-light-is-structurally-equal(null-value, null-value) ~&gt; true . Booleans . Rule ocaml-light-is-structurally-equal(B1:booleans, B2:booleans) ~&gt; is-equal(B1,B2) . Integers . Rule ocaml-light-is-structurally-equal(I1:implemented-integers, I2:implemented-integers) ~&gt; is-equal(I1,I2) . Floats . Rule ocaml-light-is-structurally-equal(F1:implemented-floats, F2:implemented-floats) ~&gt; is-equal(F1,F2) . Characters . Rule ocaml-light-is-structurally-equal(C1:implemented-characters, C2:implemented-characters) ~&gt; is-equal(C1,C2) . Strings . Rule ocaml-light-is-structurally-equal(S1:implemented-strings, S2:implemented-strings) ~&gt; is-equal(S1,S2) . Tuples . Rule ocaml-light-is-structurally-equal(tuple(), tuple()) ~&gt; true Rule ocaml-light-is-structurally-equal(tuple(), tuple(V+)) ~&gt; false Rule ocaml-light-is-structurally-equal(tuple(V+), tuple()) ~&gt; false Rule ocaml-light-is-structurally-equal(tuple(V, V*), tuple(W, W*)) ~&gt; and(ocaml-light-is-structurally-equal(V, W), ocaml-light-is-structurally-equal(tuple(V*), tuple(W*))) . Lists . Rule ocaml-light-is-structurally-equal([], []) ~&gt; true Rule ocaml-light-is-structurally-equal([], [V+]) ~&gt; false Rule ocaml-light-is-structurally-equal([V+], []) ~&gt; false Rule ocaml-light-is-structurally-equal([V,V*], [W,W*]) ~&gt; and(ocaml-light-is-structurally-equal(V,W), ocaml-light-is-structurally-equal([V*], [W*])) . Records . Rule dom(Map1) == dom(Map2) ---------------------------------------------------------------------- ocaml-light-is-structurally-equal(record(Map1:maps(_,_)), record(Map2:maps(_,_))) ~&gt; not(is-in-set(false, set(interleave-map( ocaml-light-is-structurally-equal( checked lookup(Map1, given), checked lookup(Map2, given)), set-elements(dom(Map1)))))) . References . Rule ocaml-light-is-structurally-equal(V1:variables, V2:variables) ~&gt; ocaml-light-is-structurally-equal(assigned(V1), assigned(V2)) . Vectors . Rule ocaml-light-is-structurally-equal(Vec1:vectors(values), Vec2:vectors(values)) ~&gt; ocaml-light-is-structurally-equal([vector-elements(Vec1)], [vector-elements(Vec2)]) . Variants . Rule ocaml-light-is-structurally-equal(variant(Con1,V1), variant(Con2,V2)) ~&gt; if-true-else( is-equal(Con1, Con2), if-true-else( or(is-equal(tuple( ), V1), is-equal(tuple( ), V2)), and(is-equal(tuple( ), V1), is-equal(tuple( ), V2)), ocaml-light-is-structurally-equal(V1, V2)), false) . Functions . Rule ocaml-light-is-structurally-equal(_:functions(_,_), _:functions(_,_)) ~&gt; throw(variant(\"Invalid_argument\", \"equal: functional value\")) . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#structural-equality",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#structural-equality"
  },"326": {
    "doc": "OC-L-12-Core-Library",
    "title": "Console display",
    "content": "Funcon ocaml-light-to-string(_:values) : =&gt;strings . ocaml-light-to-string(V) gives the string represention of OCaml Light values as implemented by the ocaml interpreter. Rule // Unit ocaml-light-to-string(null-value) ~&gt; \"()\" Rule // Booleans ocaml-light-to-string(B:booleans) ~&gt; to-string(B) Rule // Integers ocaml-light-to-string(I:integers) ~&gt; to-string(I) Rule // Floats ocaml-light-to-string(F:implemented-floats) ~&gt; to-string(F) Rule // Characters ocaml-light-to-string(C:implemented-characters) ~&gt; string-append(\"'\", to-string(C), \"'\") Rule // Strings S =/= [] ---------------------------------------------------------------- ocaml-light-to-string(S:implemented-strings) ~&gt; string-append(\"\\\"\", S, \"\\\"\") Rule // Functions ocaml-light-to-string(_:functions(_,_)) ~&gt; \"&lt;fun&gt;\" Rule // References ocaml-light-to-string(V:variables) ~&gt; string-append(\"ref \", ocaml-light-to-string(assigned(V))) Rule // Variants ocaml-light-to-string(variant(Con,Arg)) ~&gt; if-true-else(is-equal(tuple( ),Arg), Con, string-append(Con, \" \", ocaml-light-to-string(Arg))) Rule // Tuples ocaml-light-to-string(tuple(V:values, V+:values+)) ~&gt; string-append( \"(\", intersperse(\", \", interleave-map(ocaml-light-to-string(given), V, V+)), \")\") Rule // Lists ocaml-light-to-string([V*:values*]) ~&gt; string-append( \"[\", intersperse(\"; \", interleave-map(ocaml-light-to-string(given), V*)), \"]\") Rule // Vectors ocaml-light-to-string(V:implemented-vectors) ~&gt; string-append( \"[|\", intersperse(\"; \", interleave-map( ocaml-light-to-string(assigned(given)), vector-elements(V))), \"|]\") Rule // Records ocaml-light-to-string(record(M:maps(_,_))) ~&gt; string-append( \"{\", intersperse(\"; \", interleave-map( string-append(arg-1,\" = \",ocaml-light-to-string(arg-2)), map-elements(M))), \"}\") . Funcon ocaml-light-define-and-display(Env:envs) : =&gt;envs ~&gt; sequential( effect left-to-right-map( print(arg-1, \" = \", ocaml-light-to-string arg-2, \"\\n\"), map-elements Env), Env) . Funcon ocaml-light-evaluate-and-display(V:implemented-values) : =&gt;envs ~&gt; sequential( print(\"- = \", ocaml-light-to-string V, \"\\n\"), map()) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#console-display",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html#console-display"
  },"327": {
    "doc": "OC-L-12-Core-Library",
    "title": "OC-L-12-Core-Library",
    "content": "Languages-beta : OC-L-12-Core-Library.cbs | PRETTY | PDF . Outline . | 12 Core library . | Abbreviations | Library | Language-specific funcons . | Exception values | Structural equality | Console display | . | . | . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-12-Core-Library/index.html"
  },"328": {
    "doc": "OC-L-A-Disambiguation",
    "title": "A Disambiguation",
    "content": "Lexis SDF // 1 Lexical conventions // Comments lexical syntax LAYOUT = LEX-block-comment LEX-block-comment = \"(*\" LEX-comment-part* \"*)\" LEX-comment-part = ~[\\(\\)\\*] LEX-comment-part = LEX-asterisk LEX-comment-part = LEX-left-paren LEX-comment-part = LEX-right-paren LEX-comment-part = LEX-block-comment LEX-asterisk = [\\*] LEX-left-paren = [\\(] LEX-right-paren = [\\)] lexical restrictions LEX-asterisk -/- [\\)] LEX-left-paren -/- [\\*] context-free restrictions LAYOUT? -/- [\\(].[\\*] // Identifiers lexical syntax ident = keyword {reject} lowercase-ident = keyword {reject} lexical restrictions ident lowercase-ident capitalized-ident -/- [A-Za-z0-9\\_\\'] Syntax SDF // Integer literals context-free restrictions integer-literal -/- [0-9eE] Syntax SDF // Floating-point literals context-free restrictions float-literal -/- [0-9eE] // String literals syntax string-character-star ::= string-character _ string-character-star {avoid} Lexis SDF // Keywords lexical restrictions \"and\" \"as\" \"assert\" \"asr\" \"begin\" \"class\" \"constraint\" \"do\" \"done\" \"downto\" \"else\" \"end\" \"exception\" \"external\" \"false\" \"for\" \"fun\" \"function\" \"functor\" \"if\" \"in\" \"include\" \"inherit\" \"initializer\" \"land\" \"lazy\" \"let\" \"lor\" \"lsl\" \"lsr\" \"lxor\" \"match\" \"method\" \"mod\" \"module\" \"mutable\" \"new\" \"nonrec\" \"object\" \"of\" \"open\" \"or\" \"private\" \"rec\" \"sig\" \"struct\" \"then\" \"to\" \"true\" \"try\" \"type\" \"val\" \"virtual\" \"when\" \"while\" \"with\" -/- [A-Za-z0-9\\_] // Key symbols infix-op-1 infix-op-2 infix-op-3 infix-op-4 infix-op-5 infix-op-6 infix-op-7 infix-op-8 -/- [\\!\\$\\%\\&amp;\\*\\+\\-\\.\\/\\:\\&lt;\\=\\&gt;\\?\\@\\^\\|\\~] \"[\" -/- [\\|] \"|\" -/- [\\]] \":\" -/- [\\:] \";\" -/- [\\;] lexical syntax infix-op-3 = \"-&gt;\" {reject} infix-op-5 = \"&lt;-\" {reject} Syntax SDF // 4 Type expressions context-free syntax typexpr ::= typexpr '-&gt;' typexpr {right} typexpr ::= typexpr star-typexpr+ {non-assoc} context-free priorities typexpr ::= typexpr typeconstr &gt; constr-args ::= typexpr star-typexpr* &gt; typexpr ::= typexpr star-typexpr+ &gt; typexpr ::= typexpr '-&gt;' typexpr context-free priorities star-typexpr ::= '*' typexpr &gt; typexpr ::= typexpr star-typexpr+ // 6 Patterns context-free syntax pattern ::= pattern '|' pattern {left} pattern ::= pattern comma-pattern+ {non-assoc} pattern ::= pattern '::' pattern {right} context-free priorities pattern ::= constr pattern &gt; pattern ::= pattern '::' pattern &gt; pattern ::= pattern comma-pattern+ &gt; pattern ::= pattern '|' pattern &gt; pattern ::= pattern 'as' value-name context-free priorities { comma-pattern ::= ',' pattern (pattern comma-pattern*) } &gt; pattern ::= pattern comma-pattern+ // 7 Expressions context-free syntax expr ::= expr argument+ {non-assoc,avoid} expr ::= '-' expr {avoid} expr ::= expr infix-op-1 expr {right} expr ::= expr infix-op-2 expr {left} expr ::= expr infix-op-3 expr {left,prefer} expr ::= expr '::' expr {right} expr ::= expr infix-op-4 expr {right} expr ::= expr infix-op-5 expr {left} expr ::= expr infix-op-6 expr {right} expr ::= expr infix-op-7 expr {right} expr ::= expr comma-expr+ {non-assoc} expr ::= expr infix-op-8 expr {right} expr ::= expr '.' field '&lt;-' expr{right} expr ::= expr '.(' expr ')' '&lt;-' expr{right} expr ::= expr ';' expr {right} context-free priorities argument ::= expr &gt; expr ::= prefix-symbol expr &gt; expr ::= expr '.' field &gt; { expr ::= expr argument+ expr ::= 'assert' expr } &gt; { expr ::= '-' expr expr ::= '-.' expr } &gt; expr ::= expr infix-op-1 expr &gt; expr ::= expr infix-op-2 expr &gt; expr ::= expr infix-op-3 expr &gt; expr ::= expr '::' expr &gt; expr ::= expr infix-op-4 expr &gt; expr ::= expr infix-op-5 expr &gt; expr ::= expr infix-op-6 expr &gt; expr ::= expr infix-op-7 expr &gt; expr ::= expr comma-expr+ &gt; { expr ::= expr '.' field '&lt;-' expr expr ::= expr '.(' expr ')' '&lt;-' expr expr ::= expr infix-op-8 expr } &gt; expr ::= expr ';' expr context-free priorities expr ::= prefix-symbol expr &gt; expr ::= expr '.(' expr ')' &lt;0&gt; &gt; expr ::= expr argument+ context-free priorities { argument ::= expr expr ::= expr '.' field expr ::= expr '.(' expr ')' expr ::= expr argument+ expr ::= 'assert' expr expr ::= expr infix-op-1 expr expr ::= expr infix-op-2 expr expr ::= expr infix-op-3 expr expr ::= expr '::' expr expr ::= expr infix-op-4 expr expr ::= expr infix-op-5 expr expr ::= expr infix-op-6 expr expr ::= expr infix-op-7 expr expr ::= expr comma-expr+ expr ::= expr '.' field '&lt;-' expr expr ::= expr '.(' expr ')' '&lt;-' expr expr ::= expr infix-op-8 expr expr ::= expr ';' expr } &lt;0&gt;. &gt; { expr ::= 'if' expr 'then' expr ('else' expr)? expr ::= 'match' expr 'with' pattern-matching expr ::= 'function' pattern-matching expr ::= 'fun' pattern+ '-&gt;' expr expr ::= 'try' expr 'with' pattern-matching expr ::= let-definition 'in' expr } context-free priorities { comma-expr ::= ',' expr (expr comma-expr*) } &gt; expr ::= expr comma-expr+ context-free priorities { expr ::= '[' expr semic-expr* ']' expr ::= '[' expr semic-expr* ';' ']' expr ::= '[|' expr semic-expr* '|]' expr ::= '[|' expr semic-expr* ';' '|]' semic-expr ::= ';' expr (expr semic-expr*) expr ::= '{' field '=' expr semic-field-expr* '}' expr ::= '{' field '=' expr semic-field-expr* ';' '}' expr ::= '{' expr 'with' field '=' expr semic-field-expr* '}' expr ::= '{' expr 'with' field '=' expr semic-field-expr* ';' '}' semic-field-expr ::= ';' field '=' expr } &gt; expr ::= expr ';' expr . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-A-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-A-Disambiguation/index.html#SectionNumber_A"
  },"329": {
    "doc": "OC-L-A-Disambiguation",
    "title": "OC-L-A-Disambiguation",
    "content": "Languages-beta : OC-L-A-Disambiguation.cbs | PRETTY | PDF . Language \"OCaml Light\" . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-A-Disambiguation/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-A-Disambiguation/index.html"
  },"330": {
    "doc": "OC-L-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#computations"
  },"331": {
    "doc": "OC-L-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#normal-computation"
  },"332": {
    "doc": "OC-L-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#flowing"
  },"333": {
    "doc": "OC-L-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon initialise-giving Funcon give Funcon given Funcon left-to-right-map Funcon interleave-map ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#giving"
  },"334": {
    "doc": "OC-L-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bound-value Alias bound Funcon scope Funcon accumulate Funcon collateral Funcon recursive ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#binding"
  },"335": {
    "doc": "OC-L-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Datatype variables Alias vars Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#storing"
  },"336": {
    "doc": "OC-L-Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Funcon read ] . Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#interacting"
  },"337": {
    "doc": "OC-L-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#abnormal-computation"
  },"338": {
    "doc": "OC-L-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon fail Funcon else Funcon checked Funcon check-true ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#failing"
  },"339": {
    "doc": "OC-L-Funcons-Index",
    "title": "Throwing",
    "content": "[ Funcon finalise-throwing Funcon throw Funcon handle-thrown ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#throwing",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#throwing"
  },"340": {
    "doc": "OC-L-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#values"
  },"341": {
    "doc": "OC-L-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Funcon is-in-type Alias is Funcon when-true Alias when Type ground-values Alias ground-vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#value-types"
  },"342": {
    "doc": "OC-L-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#primitive-values"
  },"343": {
    "doc": "OC-L-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not Funcon and Funcon or ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#booleans"
  },"344": {
    "doc": "OC-L-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Type bounded-integers Alias bounded-ints Type natural-numbers Alias nats Funcon natural-successor Alias nat-succ Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-modulo Alias int-mod Funcon integer-absolute-value Alias int-abs Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon decimal-natural Alias decimal Funcon integer-sequence ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#integers"
  },"345": {
    "doc": "OC-L-Funcons-Index",
    "title": "Floats",
    "content": "[ Datatype float-formats Funcon binary64 Type floats Funcon float-negate Funcon float-absolute-value Funcon float-add Funcon float-subtract Funcon float-multiply Funcon float-divide Funcon float-remainder Funcon float-sqrt Funcon float-float-power Funcon float-floor Funcon float-ceiling Funcon float-truncate Funcon float-log Funcon float-log10 Funcon float-exp Funcon float-sin Funcon float-cos Funcon float-tan Funcon float-asin Funcon float-acos Funcon float-atan Funcon float-sinh Funcon float-cosh Funcon float-tanh Funcon float-atan2 ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#floats",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#floats"
  },"346": {
    "doc": "OC-L-Funcons-Index",
    "title": "Characters",
    "content": "[ Type characters Alias chars Funcon unicode-character Alias unicode-char Funcon ascii-character Alias ascii-char Funcon backspace Funcon horizontal-tab Funcon line-feed Funcon carriage-return Funcon backslash ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#characters",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#characters"
  },"347": {
    "doc": "OC-L-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#the-null-value"
  },"348": {
    "doc": "OC-L-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#composite-values"
  },"349": {
    "doc": "OC-L-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon reverse Funcon n-of Funcon intersperse ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#sequences-of-values"
  },"350": {
    "doc": "OC-L-Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#tuples"
  },"351": {
    "doc": "OC-L-Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list Funcon list-elements Funcon list-nil Alias nil Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail Funcon list-length Funcon list-append ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#lists",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#lists"
  },"352": {
    "doc": "OC-L-Funcons-Index",
    "title": "Strings",
    "content": "[ Type strings Funcon string-append Funcon to-string ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#strings",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#strings"
  },"353": {
    "doc": "OC-L-Funcons-Index",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#vectors",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#vectors"
  },"354": {
    "doc": "OC-L-Funcons-Index",
    "title": "Bits and bit vectors",
    "content": "[ Datatype bit-vectors Funcon bit-vector-not Funcon bit-vector-and Funcon bit-vector-or Funcon bit-vector-xor Funcon bit-vector-shift-left Funcon bit-vector-logical-shift-right Funcon bit-vector-arithmetic-shift-right Funcon integer-to-bit-vector Funcon bit-vector-to-integer Funcon signed-bit-vector-maximum Funcon signed-bit-vector-minimum ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#bits-and-bit-vectors",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#bits-and-bit-vectors"
  },"355": {
    "doc": "OC-L-Funcons-Index",
    "title": "Sets",
    "content": "[ Funcon set Funcon set-elements Funcon is-in-set ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#sets",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#sets"
  },"356": {
    "doc": "OC-L-Funcons-Index",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-elements Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#maps"
  },"357": {
    "doc": "OC-L-Funcons-Index",
    "title": "Records",
    "content": "[ Datatype records Funcon record Funcon record-map Funcon record-select ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#records",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#records"
  },"358": {
    "doc": "OC-L-Funcons-Index",
    "title": "Variants",
    "content": "[ Datatype variants Funcon variant ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#variants",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#variants"
  },"359": {
    "doc": "OC-L-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#abstraction-values"
  },"360": {
    "doc": "OC-L-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Funcon abstraction Funcon closure ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#generic-abstractions"
  },"361": {
    "doc": "OC-L-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply Funcon curry ] . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#functions"
  },"362": {
    "doc": "OC-L-Funcons-Index",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon pattern-any Funcon pattern-bind Funcon pattern-else Funcon pattern-unite Funcon match Funcon match-loosely Funcon case-match ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#patterns",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html#patterns"
  },"363": {
    "doc": "OC-L-Funcons-Index",
    "title": "OC-L-Funcons-Index",
    "content": "Languages-beta : OC-L-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Storing | Interacting . | Input | Output | . | . | Abnormal computation . | Failing | Throwing | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | Floats | Characters | The null value | . | Composite values . | Sequences of values | Tuples | Lists | Strings | Vectors | Bits and bit vectors | Sets | Maps | Records | Variants | . | Abstraction values . | Generic abstractions | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Funcons-Index/index.html"
  },"364": {
    "doc": "OC-L-Start",
    "title": "OC-L-Start",
    "content": "Languages-beta : OC-L-Start.cbs | PRETTY | PDF . Language \"OCaml Light\" . Syntax START: start ::= unit-implementation . Semantics start[[ _:start ]] : =&gt;environments|null-type Rule start[[ UI ]] = initialise-binding initialise-storing initialise-giving finalise-failing finalise-throwing interpret[[ UI ]] . [ # 1 Lexical conventions # 2 Values # 3 Names # 4 Type expressions # 5 Constants # 6 Patterns # 7 Expressions # 8 Type and exception definitions # 9 Classes # 10 Module interfaces # 11 Module implementations # 12 Core library # A Disambiguation ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Start/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/OC-L-cbs/OC-L/OC-L-Start/index.html"
  },"365": {
    "doc": "OC-L",
    "title": "OCaml-Light",
    "content": "OCaml-Light is a core sublanguage of OCaml, corresponding closely to Caml-Light (an obsolete pedagogical functional programming language). Its CBS illustrates scaling up to a medium-sized language. The start of the specification of OCaml-Light in CBS is at OCaml-Light. The specification is divided into sections corresponding to Chapter 7 of the OCaml Manual. The OCaml-Light language corresponds closely to the language whose static and dynamic semantics have been specified by Scott Owens in the Ott framework. The correctness of the CBS semantics (in relation to the implementation provided by the OCaml developers) has been partially tested by generating a parser, translator, and interpreter from the specifications, and checking that the results of running a suite of about 150 small programs using the generated implementation correspond to the results of running them directly. ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/index.html#ocaml-light",
    "relUrl": "/docs/Languages-beta/OCaml-Light/index.html#ocaml-light"
  },"366": {
    "doc": "OC-L",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete, derived from OCaml Manual | dynamic semantics: complete | static semantics: not specified | disambiguation: incomplete, derived from OCaml Manual | . Tests: . | 177 small programs | high coverage (to be verified) | . Evolution: . | supersedes Reusable Components of Semantic Specifications | . Reuse of funcons: . | OCaml-Light-Funcons-Index | . References: . | OCaml Implementation | OCaml Manual | A formal specification for OCaml: the Core Language | Reusable Components of Semantic Specifications | . Keywords: . | OCaml, higher-order, functional, imperative, patterns, disambiguation | . Main contributors: . | recent: Peter Mosses, Neil Sculthorpe | previous: Martin Churchill, Paolo Torrini | . ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/index.html#colophon",
    "relUrl": "/docs/Languages-beta/OCaml-Light/index.html#colophon"
  },"367": {
    "doc": "OC-L",
    "title": "OC-L",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/OCaml-Light/index.html",
    "relUrl": "/docs/Languages-beta/OCaml-Light/index.html"
  },"368": {
    "doc": "Funcon reuse",
    "title": "Funcon Reuse in Languages-beta",
    "content": "Currently, Funcons-beta includes 387 funcons (including types, datatypes, and entities, but not aliases). Of these, 192 are used in language specifications in Languages-beta. The number of funcons used for each language is as follows: . | IMP | SMP | MiniJ | SL | OC-L | . | 29 | 62 | 70 | 71 | 160 | . The definitions of some of the used funcons reference other funcons, which are not counted. The remaining funcons have either been used in previous language specifications, or are expected to be useful in future specifications. The following tables show which language specifications directly use each funcon, thereby exhibiting the degree of funcon reuse in Languages-beta. CONTENTS . | Computations . | Types of computation | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Linking | Interacting . | Input | Output | . | . | Abnormal computation . | Terminating abruptly | Failing | Throwing | Returning | Breaking | Continuing | Controlling | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | Floats | Characters | The null value | . | Composite values . | Sequences of values | Datatypes | Tuples | Lists | Strings | Vectors | Bits and bit vectors | Sets | Maps | Multisets (bags) | Trees | Graphs | References and pointers | Records | Variants | Classes | Objects | . | Abstraction values . | Generic abstractions | Thunks | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#funcon-reuse-in-languages-beta",
    "relUrl": "/docs/Languages-beta/Reuse.html#funcon-reuse-in-languages-beta"
  },"369": {
    "doc": "Funcon reuse",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#computations",
    "relUrl": "/docs/Languages-beta/Reuse.html#computations"
  },"370": {
    "doc": "Funcon reuse",
    "title": "Types of computation",
    "content": "| Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Funcon | computation-types |   |   |   |   |   |   | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#types-of-computation",
    "relUrl": "/docs/Languages-beta/Reuse.html#types-of-computation"
  },"371": {
    "doc": "Funcon reuse",
    "title": "Normal computation",
    "content": "Flowing . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Funcon | left-to-right | l-to-r |   |   |   |   |   | . | Funcon | right-to-left | r-to-l |   |   |   |   |   | . | Funcon | sequential | seq | X | X | X | X | X | . | Funcon | effect |   |   | X |   | X | X | . | Funcon | choice |   |   |   |   |   |   | . | Funcon | if-true-else | if-else | X | X | X | X | X | . | Funcon | while-true | while | X | X | X | X | X | . | Funcon | do-while-true | do-while |   |   |   |   |   | . | Funcon | interleave |   |   |   |   |   |   | . | Datatype | yielding |   |   |   |   |   |   | . | Funcon | signal |   |   |   |   |   |   | . | Funcon | yielded |   |   |   |   |   |   | . | Funcon | yield |   |   |   |   |   |   | . | Funcon | yield-on-value |   |   |   |   |   |   | . | Funcon | yield-on-abrupt |   |   |   |   |   |   | . | Funcon | atomic |   |   |   |   |   |   | . Giving . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Entity | given-value |   |   |   |   |   |   | . | Funcon | initialise-giving |   | X | X | X | X | X | . | Funcon | give |   |   | X | X | X | X | . | Funcon | given |   |   | X | X | X | X | . | Funcon | no-given |   |   |   |   |   |   | . | Funcon | left-to-right-map |   |   |   |   |   |   | . | Funcon | interleave-map |   |   |   |   |   |   | . | Funcon | left-to-right-repeat |   |   | X |   |   |   | . | Funcon | interleave-repeat |   |   |   | X |   |   | . | Funcon | left-to-right-filter |   |   |   |   |   |   | . | Funcon | interleave-filter |   |   |   |   |   |   | . | Funcon | fold-left |   |   |   |   |   |   | . | Funcon | fold-right |   |   |   |   |   |   | . Binding . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | environments | envs | X | X | X | X | X | . | Datatype | identifiers | ids | X | X | X | X | X | . | Funcon | identifier-tagged | id-tagged |   |   |   |   |   | . | Funcon | fresh-identifier |   |   |   |   |   |   | . | Entity | environment | env |   |   |   |   |   | . | Funcon | initialise-binding |   | X | X | X | X | X | . | Funcon | bind-value | bind | X | X |   | X |   | . | Funcon | unbind |   |   |   |   |   |   | . | Funcon | bound-directly |   |   |   |   |   |   | . | Funcon | bound-value | bound | X | X | X | X | X | . | Funcon | closed |   |   |   |   | X |   | . | Funcon | scope |   | X | X | X | X | X | . | Funcon | accumulate |   |   |   |   |   | X | . | Funcon | collateral |   | X | X | X | X | X | . | Funcon | bind-recursively |   |   |   |   |   |   | . | Funcon | recursive |   |   |   | X |   | X | . Generating . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | atoms |   |   |   |   |   |   | . | Entity | used-atom-set |   |   |   |   |   |   | . | Funcon | initialise-generating |   |   |   |   |   |   | . | Funcon | fresh-atom |   |   |   | X | X |   | . | Funcon | use-atom-not-in |   |   |   |   |   |   | . Storing . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | locations | locs |   |   |   |   |   | . | Type | stores |   |   |   |   |   |   | . | Entity | store |   |   |   |   |   |   | . | Funcon | initialise-storing |   | X | X | X | X | X | . | Funcon | store-clear |   |   |   |   |   |   | . | Datatype | variables | vars |   | X | X | X | X | . | Funcon | variable | var |   |   |   |   |   | . | Funcon | allocate-variable | alloc |   | X |   |   |   | . | Funcon | recycle-variables | recycle |   |   |   |   |   | . | Funcon | initialise-variable | init |   |   |   |   |   | . | Funcon | allocate-initialised-variable | alloc-init | X | X | X | X | X | . | Funcon | assign |   | X | X | X | X | X | . | Funcon | assigned |   | X | X | X | X | X | . | Funcon | current-value |   |   |   |   |   |   | . | Funcon | un-assign |   |   |   |   |   |   | . | Funcon | structural-assign |   |   |   |   |   |   | . | Funcon | structural-assigned |   |   |   |   |   |   | . Linking . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | links |   |   |   |   |   |   | . | Funcon | initialise-linking |   |   |   |   |   |   | . | Funcon | link |   |   |   |   |   |   | . | Funcon | fresh-link |   |   |   |   |   |   | . | Funcon | fresh-initialised-link | fresh-init-link |   |   |   |   |   | . | Funcon | set-link |   |   |   |   |   |   | . | Funcon | follow-if-link |   |   |   |   |   |   | . Interacting . Input . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Entity | standard-in |   |   |   |   |   |   | . | Funcon | read |   |   | X |   | X | X | . Output . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Entity | standard-out |   |   |   |   |   |   | . | Funcon | print |   |   | X | X | X | X | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#normal-computation",
    "relUrl": "/docs/Languages-beta/Reuse.html#normal-computation"
  },"372": {
    "doc": "Funcon reuse",
    "title": "Abnormal computation",
    "content": "Terminating abruptly . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Funcon | stuck |   |   |   |   |   |   | . | Entity | abrupted |   |   |   |   |   |   | . | Funcon | finalise-abrupting |   |   |   |   | X |   | . | Funcon | abrupt |   |   |   |   |   |   | . | Funcon | handle-abrupt |   |   |   |   |   |   | . | Funcon | finally |   |   |   |   |   |   | . Failing . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | failing |   |   |   |   |   |   | . | Funcon | failed |   |   |   |   |   |   | . | Funcon | finalise-failing |   | X | X | X |   | X | . | Funcon | fail |   |   |   |   | X | X | . | Funcon | else |   |   |   |   | X | X | . | Funcon | else-choice |   |   |   |   |   |   | . | Funcon | checked |   | X | X | X | X | X | . | Funcon | check-true |   |   |   |   |   | X | . Throwing . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | throwing |   |   |   |   |   |   | . | Funcon | thrown |   |   |   |   |   |   | . | Funcon | finalise-throwing |   |   | X |   |   | X | . | Funcon | throw |   |   | X |   |   | X | . | Funcon | handle-thrown |   |   | X |   |   | X | . | Funcon | handle-recursively |   |   |   |   |   |   | . | Funcon | catch-else-throw |   |   |   |   |   |   | . Returning . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | returning |   |   |   |   |   |   | . | Funcon | returned |   |   |   |   |   |   | . | Funcon | finalise-returning |   |   |   |   |   |   | . | Funcon | return |   |   | X |   | X |   | . | Funcon | handle-return |   |   | X |   | X |   | . Breaking . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | breaking |   |   |   |   |   |   | . | Funcon | broken |   |   |   |   |   |   | . | Funcon | finalise-breaking |   |   |   |   |   |   | . | Funcon | break |   |   |   |   | X |   | . | Funcon | handle-break |   |   |   |   | X |   | . Continuing . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | continuing |   |   |   |   |   |   | . | Funcon | continued |   |   |   |   |   |   | . | Funcon | finalise-continuing |   |   |   |   |   |   | . | Funcon | continue |   |   |   |   | X |   | . | Funcon | handle-continue |   |   |   |   | X |   | . Controlling . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | continuations |   |   |   |   |   |   | . | Funcon | continuation |   |   |   |   |   |   | . | Entity | plug-signal |   |   |   |   |   |   | . | Funcon | hole |   |   |   |   |   |   | . | Funcon | resume-continuation |   |   |   |   |   |   | . | Entity | control-signal |   |   |   |   |   |   | . | Funcon | control |   |   |   |   |   |   | . | Funcon | delimit-current-continuation | delimit-cc |   |   |   |   |   | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/Reuse.html#abnormal-computation"
  },"373": {
    "doc": "Funcon reuse",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#values",
    "relUrl": "/docs/Languages-beta/Reuse.html#values"
  },"374": {
    "doc": "Funcon reuse",
    "title": "Value Types",
    "content": "| Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | values | vals |   | X |   | X | X | . | Type | value-types | types |   |   | X |   |   | . | Type | empty-type |   |   |   |   |   |   | . | Funcon | is-in-type | is |   |   |   |   | X | . | Funcon | is-value | is-val |   |   |   |   |   | . | Funcon | when-true | when |   |   |   |   | X | . | Type | cast-to-type | cast |   |   |   | X |   | . | Type | ground-values | ground-vals |   |   |   |   | X | . | Funcon | is-equal | is-eq |   | X |   | X | X | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#value-types",
    "relUrl": "/docs/Languages-beta/Reuse.html#value-types"
  },"375": {
    "doc": "Funcon reuse",
    "title": "Primitive values",
    "content": "Booleans . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | booleans | bools | X |   | X | X | X | . | Funcon | true |   | X | X | X | X | X | . | Funcon | false |   | X | X | X | X | X | . | Funcon | not |   | X | X | X | X | X | . | Funcon | implies |   |   |   |   |   |   | . | Funcon | and |   |   |   |   |   | X | . | Funcon | or |   |   |   |   |   | X | . | Funcon | exclusive-or | xor |   |   |   |   |   | . Integers . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | integers | ints | X |   | X | X | X | . | Type | integers-from | from |   |   |   |   |   | . | Type | integers-up-to | up-to |   |   |   |   |   | . | Type | bounded-integers | bounded-ints |   |   |   |   | X | . | Type | positive-integers | pos-ints |   |   |   |   |   | . | Type | negative-integers | neg-ints |   |   |   |   |   | . | Type | natural-numbers | nats |   | X |   |   | X | . | Funcon | natural-successor | nat-succ |   |   |   |   | X | . | Funcon | natural-predecessor | nat-pred |   |   |   |   |   | . | Funcon | integer-add | int-add | X | X | X | X | X | . | Funcon | integer-subtract | int-sub |   | X | X | X | X | . | Funcon | integer-multiply | int-mul |   | X | X | X | X | . | Funcon | integer-divide | int-div | X | X |   | X | X | . | Funcon | integer-modulo | int-mod |   | X |   |   | X | . | Funcon | integer-power | int-pow |   |   |   |   |   | . | Funcon | integer-absolute-value | int-abs |   |   |   |   | X | . | Funcon | integer-negate | int-neg | X | X |   | X | X | . | Funcon | integer-is-less | is-less |   | X | X | X | X | . | Funcon | integer-is-less-or-equal | is-less-or-equal | X | X |   | X | X | . | Funcon | integer-is-greater | is-greater |   | X |   | X | X | . | Funcon | integer-is-greater-or-equal | is-greater-or-equal |   | X |   | X | X | . | Funcon | binary-natural | binary |   |   |   |   |   | . | Funcon | octal-natural | octal |   |   |   |   |   | . | Funcon | decimal-natural | decimal | X | X | X | X | X | . | Funcon | hexadecimal-natural | hexadecimal |   |   |   |   |   | . | Funcon | integer-sequence |   |   |   |   |   | X | . Floats . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | float-formats |   |   |   |   |   | X | . | Funcon | binary32 |   |   |   |   |   |   | . | Funcon | binary64 |   |   |   |   |   | X | . | Funcon | binary128 |   |   |   |   |   |   | . | Funcon | decimal64 |   |   |   |   |   |   | . | Funcon | decimal128 |   |   |   |   |   |   | . | Type | floats |   |   |   |   |   | X | . | Funcon | float |   |   |   |   |   |   | . | Funcon | quiet-not-a-number | qNaN |   |   |   |   |   | . | Funcon | signaling-not-a-number | sNaN |   |   |   |   |   | . | Funcon | positive-infinity | pos-inf |   |   |   |   |   | . | Funcon | negative-infinity | neg-inf |   |   |   |   |   | . | Funcon | float-convert |   |   |   |   |   |   | . | Funcon | float-equal |   |   |   |   |   |   | . | Funcon | float-is-less |   |   |   |   |   |   | . | Funcon | float-is-less-or-equal |   |   |   |   |   |   | . | Funcon | float-is-greater |   |   |   |   |   |   | . | Funcon | float-is-greater-or-equal |   |   |   |   |   |   | . | Funcon | float-negate |   |   |   |   |   | X | . | Funcon | float-absolute-value |   |   |   |   |   | X | . | Funcon | float-add |   |   |   |   |   | X | . | Funcon | float-subtract |   |   |   |   |   | X | . | Funcon | float-multiply |   |   |   |   |   | X | . | Funcon | float-multiply-add |   |   |   |   |   |   | . | Funcon | float-divide |   |   |   |   |   | X | . | Funcon | float-remainder |   |   |   |   |   | X | . | Funcon | float-sqrt |   |   |   |   |   | X | . | Funcon | float-integer-power |   |   |   |   |   |   | . | Funcon | float-float-power |   |   |   |   |   | X | . | Funcon | float-round-ties-to-even |   |   |   |   |   |   | . | Funcon | float-round-ties-to-infinity |   |   |   |   |   |   | . | Funcon | float-floor |   |   |   |   |   | X | . | Funcon | float-ceiling |   |   |   |   |   | X | . | Funcon | float-truncate |   |   |   |   |   | X | . | Funcon | float-pi |   |   |   |   |   |   | . | Funcon | float-e |   |   |   |   |   |   | . | Funcon | float-log |   |   |   |   |   | X | . | Funcon | float-log10 |   |   |   |   |   | X | . | Funcon | float-exp |   |   |   |   |   | X | . | Funcon | float-sin |   |   |   |   |   | X | . | Funcon | float-cos |   |   |   |   |   | X | . | Funcon | float-tan |   |   |   |   |   | X | . | Funcon | float-asin |   |   |   |   |   | X | . | Funcon | float-acos |   |   |   |   |   | X | . | Funcon | float-atan |   |   |   |   |   | X | . | Funcon | float-sinh |   |   |   |   |   | X | . | Funcon | float-cosh |   |   |   |   |   | X | . | Funcon | float-tanh |   |   |   |   |   | X | . | Funcon | float-asinh |   |   |   |   |   |   | . | Funcon | float-acosh |   |   |   |   |   |   | . | Funcon | float-atanh |   |   |   |   |   |   | . | Funcon | float-atan2 |   |   |   |   |   | X | . Characters . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | characters | chars |   |   |   |   | X | . | Datatype | unicode-characters | unicode-chars |   |   |   |   |   | . | Type | unicode-points |   |   |   |   |   |   | . | Funcon | unicode-character | unicode-char |   |   |   |   | X | . | Funcon | unicode-point | unicode |   |   |   |   |   | . | Type | basic-multilingual-plane-characters | bmp-chars |   |   |   |   |   | . | Type | basic-multilingual-plane-points |   |   |   |   |   |   | . | Type | iso-latin-1-characters | latin-1-chars |   |   |   |   |   | . | Type | iso-latin-1-points |   |   |   |   |   |   | . | Type | ascii-characters | ascii-chars |   |   |   |   |   | . | Type | ascii-points |   |   |   |   |   |   | . | Type | ascii-character | ascii-char |   |   |   |   | X | . | Funcon | utf-8 |   |   |   |   |   |   | . | Funcon | utf-16 |   |   |   |   |   |   | . | Funcon | utf-32 |   |   |   |   |   |   | . | Funcon | backspace |   |   |   |   |   | X | . | Funcon | horizontal-tab |   |   |   |   |   | X | . | Funcon | line-feed |   |   |   |   |   | X | . | Funcon | form-feed |   |   |   |   |   |   | . | Funcon | carriage-return |   |   |   |   |   | X | . | Funcon | double-quote |   |   |   |   |   |   | . | Funcon | single-quote |   |   |   |   |   |   | . | Funcon | backslash |   |   |   |   |   | X | . The null value . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | null-type |   | X | X | X | X | X | . | Funcon | null-value | null | X | X | X | X | X | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#primitive-values",
    "relUrl": "/docs/Languages-beta/Reuse.html#primitive-values"
  },"376": {
    "doc": "Funcon reuse",
    "title": "Composite values",
    "content": "Sequences of values . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Funcon | length |   |   | X | X |   | X | . | Funcon | index |   |   | X | X |   | X | . | Funcon | is-in |   |   |   |   |   |   | . | Funcon | first |   |   |   | X |   |   | . | Funcon | second |   |   |   |   |   |   | . | Funcon | third |   |   |   |   |   |   | . | Funcon | first-n |   |   |   |   |   |   | . | Funcon | drop-first-n |   |   |   |   |   |   | . | Funcon | reverse |   |   |   |   |   | X | . | Funcon | n-of |   |   |   |   |   | X | . | Funcon | intersperse |   |   |   |   |   | X | . Datatypes . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Funcon | datatype-value |   |   |   |   |   |   | . | Funcon | datatype-value-id |   |   |   |   |   |   | . | Funcon | datatype-value-elements |   |   |   |   |   |   | . Tuples . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | tuples |   |   | X | X |   | X | . | Funcon | tuple-elements |   |   |   | X |   | X | . | Funcon | tuple-zip |   |   |   |   |   |   | . Lists . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | lists |   |   |   |   | X | X | . | Funcon | list |   |   |   |   |   | X | . | Funcon | list-elements |   |   |   |   |   | X | . | Funcon | list-nil | nil |   |   |   | X | X | . | Funcon | list-cons | cons |   |   |   | X | X | . | Funcon | list-head | head |   |   |   | X | X | . | Funcon | list-tail | tail |   |   |   | X | X | . | Funcon | list-length |   |   |   |   |   | X | . | Funcon | list-append |   |   |   |   |   | X | . Strings . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | strings |   |   |   |   | X | X | . | Funcon | string |   |   |   |   |   |   | . | Funcon | string-append |   |   |   |   | X | X | . | Funcon | to-string |   |   |   | X | X | X | . Vectors . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | vectors |   |   | X | X |   | X | . | Funcon | vector |   |   | X | X |   | X | . | Funcon | vector-elements |   |   | X | X |   | X | . Bits and bit vectors . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | bits |   |   |   |   |   |   | . | Datatype | bit-vectors |   |   |   |   |   | X | . | Funcon | bit-vector |   |   |   |   |   |   | . | Type | bytes | octets |   |   |   |   |   | . | Funcon | bit-vector-not |   |   |   |   |   | X | . | Funcon | bit-vector-and |   |   |   |   |   | X | . | Funcon | bit-vector-or |   |   |   |   |   | X | . | Funcon | bit-vector-xor |   |   |   |   |   | X | . | Funcon | bit-vector-shift-left |   |   |   |   |   | X | . | Funcon | bit-vector-logical-shift-right |   |   |   |   |   | X | . | Funcon | bit-vector-arithmetic-shift-right |   |   |   |   |   | X | . | Funcon | integer-to-bit-vector |   |   |   |   |   | X | . | Funcon | bit-vector-to-integer |   |   |   |   |   | X | . | Funcon | bit-vector-to-natural |   |   |   |   |   |   | . | Funcon | unsigned-bit-vector-maximum |   |   |   |   |   |   | . | Funcon | signed-bit-vector-maximum |   |   |   |   |   | X | . | Funcon | signed-bit-vector-minimum |   |   |   |   |   | X | . | Funcon | is-in-signed-bit-vector |   |   |   |   |   |   | . | Funcon | is-in-unsigned-bit-vector |   |   |   |   |   |   | . Sets . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | sets |   |   |   | X |   |   | . | Funcon | set |   |   |   |   |   | X | . | Funcon | set-elements |   |   |   |   |   | X | . | Funcon | is-in-set |   |   |   |   |   | X | . | Funcon | is-subset |   |   |   |   |   |   | . | Funcon | set-insert |   |   |   |   |   |   | . | Funcon | set-unite |   |   |   | X |   |   | . | Funcon | set-intersect |   |   |   |   |   |   | . | Funcon | set-difference |   |   |   |   |   |   | . | Funcon | set-size |   |   |   |   |   |   | . | Funcon | some-element |   |   |   |   |   |   | . | Funcon | element-not-in |   |   |   |   |   |   | . Maps . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | maps |   |   |   |   |   | X | . | Funcon | map |   |   |   | X | X | X | . | Funcon | map-elements |   |   |   |   |   | X | . | Funcon | map-lookup | lookup |   |   | X | X | X | . | Funcon | map-domain | dom |   |   |   |   | X | . | Funcon | map-override |   |   |   |   | X | X | . | Funcon | map-unite |   |   |   |   |   | X | . | Funcon | map-delete |   |   |   |   |   |   | . Multisets (bags) . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | multisets |   |   |   |   |   |   | . | Funcon | multiset |   |   |   |   |   |   | . | Funcon | multiset-elements |   |   |   |   |   |   | . | Funcon | multiset-occurrences |   |   |   |   |   |   | . | Funcon | multiset-insert |   |   |   |   |   |   | . | Funcon | multiset-delete |   |   |   |   |   |   | . | Funcon | is-submultiset |   |   |   |   |   |   | . Trees . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | trees |   |   |   |   |   |   | . | Funcon | tree |   |   |   |   |   |   | . | Funcon | tree-root-value |   |   |   |   |   |   | . | Funcon | tree-branch-sequence |   |   |   |   |   |   | . | Funcon | single-branching-sequence |   |   |   |   |   |   | . | Funcon | forest-root-value-sequence |   |   |   |   |   |   | . | Funcon | forest-branch-sequence |   |   |   |   |   |   | . | Funcon | forest-value-sequence |   |   |   |   |   |   | . Graphs . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | directed-graphs |   |   |   |   |   |   | . | Funcon | is-cyclic |   |   |   |   |   |   | . | Funcon | topological-sort |   |   |   |   |   |   | . References and pointers . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | references |   |   |   | X |   |   | . | Funcon | reference |   |   |   | X |   |   | . | Type | pointers |   |   |   | X |   |   | . | Funcon | dereference |   |   |   | X |   |   | . Records . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | records |   |   |   |   |   | X | . | Funcon | record |   |   |   |   |   | X | . | Funcon | record-map |   |   |   |   |   | X | . | Funcon | record-select |   |   |   |   |   | X | . Variants . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | variants |   |   |   |   |   | X | . | Funcon | variant |   |   |   |   |   | X | . | Funcon | variant-id |   |   |   |   |   |   | . | Funcon | variant-value |   |   |   |   |   |   | . Classes . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | classes |   |   |   |   |   |   | . | Funcon | class |   |   |   | X |   |   | . | Funcon | class-instantiator |   |   |   | X |   |   | . | Funcon | class-feature-map |   |   |   |   |   |   | . | Funcon | class-superclass-name-sequence |   |   |   |   |   |   | . | Funcon | class-name-tree |   |   |   |   |   |   | . | Funcon | is-subclass-name |   |   |   |   |   |   | . | Funcon | class-name-single-inheritance-feature-map |   |   |   | X |   |   | . Objects . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | objects |   |   |   | X | X |   | . | Funcon | object |   |   |   | X | X |   | . | Funcon | object-identity |   |   |   |   |   |   | . | Funcon | object-class-name |   |   |   | X |   |   | . | Funcon | object-feature-map |   |   |   |   | X |   | . | Funcon | object-subobject-sequence |   |   |   |   |   |   | . | Funcon | object-tree |   |   |   |   |   |   | . | Funcon | object-single-inheritance-feature-map |   |   |   | X |   |   | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#composite-values",
    "relUrl": "/docs/Languages-beta/Reuse.html#composite-values"
  },"377": {
    "doc": "Funcon reuse",
    "title": "Abstraction values",
    "content": "Generic abstractions . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Type | abstractions |   |   |   |   |   |   | . | Funcon | abstraction |   |   |   | X |   | X | . | Funcon | closure |   |   | X | X | X | X | . | Funcon | enact |   |   |   |   |   |   | . Thunks . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | thunks |   |   |   |   |   |   | . | Funcon | thunk |   |   |   | X |   |   | . | Funcon | force |   |   |   | X |   |   | . Functions . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | functions |   |   | X | X | X | X | . | Funcon | function |   |   | X | X | X | X | . | Funcon | apply |   |   | X | X | X | X | . | Funcon | supply |   |   |   |   |   |   | . | Funcon | compose |   |   |   |   |   |   | . | Funcon | uncurry |   |   |   |   |   |   | . | Funcon | curry |   |   |   |   |   | X | . | Funcon | partial-apply |   |   |   |   |   |   | . Patterns . | Kind | Name | Alias | IMP | SMP | MiniJ | SL | OC-L | . | Datatype | patterns |   |   | X | X |   | X | . | Funcon | pattern |   |   | X | X |   | X | . | Funcon | pattern-any |   |   |   |   |   | X | . | Funcon | pattern-bind |   |   |   |   |   | X | . | Funcon | pattern-type |   |   |   |   |   |   | . | Funcon | pattern-else |   |   |   |   |   | X | . | Funcon | pattern-unite |   |   |   |   |   | X | . | Funcon | match |   |   | X | X |   | X | . | Funcon | match-loosely |   |   |   |   |   | X | . | Funcon | case-match |   |   |   |   |   | X | . | Funcon | case-match-loosely |   |   |   |   |   |   | . | Funcon | case-variant-value |   |   |   |   |   |   | . ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html#abstraction-values",
    "relUrl": "/docs/Languages-beta/Reuse.html#abstraction-values"
  },"378": {
    "doc": "Funcon reuse",
    "title": "Funcon reuse",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/Reuse.html",
    "relUrl": "/docs/Languages-beta/Reuse.html"
  },"379": {
    "doc": "SIMPLE-1-Lexical",
    "title": "1 Lexical Syntax",
    "content": "Syntax V : value ::= bool | int | string bool ::= 'false' | 'true' Lexis Z : int ::= ('0'-'9')+ Syntax string ::= '\"'_string-chars_'\"' Lexis S : string-chars ::= (~'\"')* . Semantics val[[ _:value ]] : =&gt;values . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1"
  },"380": {
    "doc": "SIMPLE-1-Lexical",
    "title": "1.1 Booleans",
    "content": "Rule val[[ 'false' ]] = false Rule val[[ 'true' ]] = true . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.1",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.1"
  },"381": {
    "doc": "SIMPLE-1-Lexical",
    "title": "1.2 Integers",
    "content": "Rule val[[ Z ]] = decimal-natural(\\\"Z\\\") . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.2",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.2"
  },"382": {
    "doc": "SIMPLE-1-Lexical",
    "title": "1.3 Strings",
    "content": "Rule val[[ '\"' S '\"' ]] = \\\"S\\\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.3",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.3"
  },"383": {
    "doc": "SIMPLE-1-Lexical",
    "title": "1.4 Identifiers",
    "content": "Lexis Id : id ::= ('A'-'Z'|'a'-'z'|'_') ('0'-'9'|'A'-'Z'|'a'-'z'|'_')* . Semantics id[[ _:id ]] : =&gt;ids Rule id[[ Id ]] = \\\"Id\\\" . Lexis keyword ::= 'false' | 'true' | 'var' | 'function' | 'sizeOf' | 'read' | 'spawn' | 'if' | 'else' | 'while' | 'for' | 'print' | 'return' | 'try' | 'catch' | 'throw' | 'join' | 'acquire' | 'release' | 'rendezvous' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.4",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html#SectionNumber_1.4"
  },"384": {
    "doc": "SIMPLE-1-Lexical",
    "title": "SIMPLE-1-Lexical",
    "content": "Languages-beta : SIMPLE-1-Lexical.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-1-Lexical/index.html"
  },"385": {
    "doc": "SIMPLE-2-Expressions",
    "title": "2 Expressions",
    "content": "Syntax Exp : exp ::= '(' exp ')' | value | lexp | lexp '=' exp | '++' lexp | '-' exp | exp '(' exps? ')' | 'sizeOf' '(' exp ')' | 'read' '(' ')' | exp '+' exp | exp '-' exp | exp '*' exp | exp '/' exp | exp '%' exp | exp '&lt;' exp | exp '&lt;=' exp | exp '&gt;' exp | exp '&gt;=' exp | exp '==' exp | exp '!=' exp | '!' exp | exp '&amp;&amp;' exp | exp '||' exp . Rule [[ '(' Exp ')' ]] : exp = [[ Exp ]] . Semantics rval[[ _:exp ]] : =&gt;values Rule rval[[ V ]] = val[[ V ]] Rule rval[[ LExp ]] = assigned(lval[[ LExp ]]) Rule rval[[ LExp '=' Exp ]] = give( rval[[ Exp ]], sequential( assign(lval[[ LExp ]], given), given)) Rule rval[[ '++' LExp ]] = give( lval[[ LExp ]], sequential( assign(given, integer-add(assigned(given), 1)), assigned(given))) Rule rval[[ '-' Exp ]] = integer-negate(rval[[ Exp ]]) Rule rval[[ Exp '(' Exps? ')' ]] = apply(rval[[ Exp ]], tuple(rvals[[ Exps? ]]) ) Rule rval[[ 'sizeOf' '(' Exp ')' ]] = length(vector-elements(rval[[ Exp ]])) Rule rval[[ 'read' '(' ')' ]] = read Rule rval[[ Exp1 '+' Exp2 ]] = integer-add(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '-' Exp2 ]] = integer-subtract(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '*' Exp2 ]] = integer-multiply(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '/' Exp2 ]] = checked integer-divide(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '%' Exp2 ]] = checked integer-modulo(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&lt;' Exp2 ]] = is-less(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&lt;=' Exp2 ]] = is-less-or-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&gt;' Exp2 ]] = is-greater(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&gt;=' Exp2 ]] = is-greater-or-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '==' Exp2 ]] = is-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '!=' Exp2 ]] = not(is-equal(rval[[ Exp1 ]],rval[[ Exp2 ]])) Rule rval[[ '!' Exp ]] = not(rval[[ Exp ]]) Rule rval[[ Exp1 '&amp;&amp;' Exp2 ]] = if-else(rval[[ Exp1 ]],rval[[ Exp2 ]],false) Rule rval[[ Exp1 '||' Exp2 ]] = if-else(rval[[ Exp1 ]],true,rval[[ Exp2 ]]) . Syntax Exps : exps ::= exp (',' exps)? . Semantics rvals[[ _:exps? ]] : (=&gt;values)* Rule rvals[[ ]] = ( ) Rule rvals[[ Exp ]] = rval[[ Exp ]] Rule rvals[[ Exp ',' Exps ]] = rval[[ Exp ]] , rvals[[ Exps ]] . Syntax LExp : lexp ::= id | lexp '[' exps ']' . Rule [[ LExp '[' Exp ',' Exps ']' ]] : lexp = [[ LExp '[' Exp ']' '[' Exps ']' ]] . Semantics lval[[ _:lexp ]] : =&gt;variables Rule lval[[ Id ]] = bound(id[[ Id ]]) Rule lval[[ LExp '[' Exp ']' ]] = checked index(integer-add(1,rval[[ Exp ]]),vector-elements(rval[[ LExp ]])) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-2-Expressions/index.html#SectionNumber_2",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-2-Expressions/index.html#SectionNumber_2"
  },"386": {
    "doc": "SIMPLE-2-Expressions",
    "title": "SIMPLE-2-Expressions",
    "content": "Languages-beta : SIMPLE-2-Expressions.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-2-Expressions/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-2-Expressions/index.html"
  },"387": {
    "doc": "SIMPLE-3-Statements",
    "title": "3 Statements",
    "content": "Syntax Block : block ::= '{' stmts? '}' Stmts : stmts ::= stmt stmts? Stmt : stmt ::= imp-stmt | vars-decl ImpStmt : imp-stmt ::= block | exp ';' | 'if' '(' exp ')' block ('else' block)? | 'while' '(' exp ')' block | 'for' '(' stmt exp ';' exp ')' block | 'print' '(' exps ')' ';' | 'return' exp? ';' | 'try' block 'catch' '(' id ')' block | 'throw' exp ';' . Rule [[ 'if' '(' Exp ')' Block ]] : stmt = [[ 'if' '(' Exp ')' Block 'else' '{' '}' ]] Rule [[ 'for' '(' Stmt Exp1 ';' Exp2 ')' '{' Stmts '}' ]] : stmt = [[ '{' Stmt 'while' '(' Exp1 ')' '{' '{' Stmts '}' Exp2 ';' '}' '}' ]] . Semantics exec[[ _:stmts ]] : =&gt;null-type Rule exec[[ '{' '}' ]] = null Rule exec[[ '{' Stmts '}' ]] = exec[[ Stmts ]] Rule exec[[ ImpStmt Stmts ]] = sequential(exec[[ ImpStmt ]], exec[[ Stmts ]]) Rule exec[[ VarsDecl Stmts ]] = scope(declare[[ VarsDecl ]], exec[[ Stmts ]]) Rule exec[[ VarsDecl ]] = effect(declare[[ VarsDecl]]) Rule exec[[ Exp ';' ]] = effect(rval[[ Exp ]]) Rule exec[[ 'if' '(' Exp ')' Block1 'else' Block2 ]] = if-else(rval[[ Exp ]], exec[[ Block1 ]], exec[[ Block2 ]]) Rule exec[[ 'while' '(' Exp ')' Block ]] = while(rval[[ Exp ]], exec[[ Block ]]) Rule exec[[ 'print' '(' Exps ')' ';' ]] = print(rvals[[ Exps ]]) Rule exec[[ 'return' Exp ';' ]] = return(rval[[ Exp ]]) Rule exec[[ 'return' ';' ]] = return(null) Rule exec[[ 'try' Block1 'catch' '(' Id ')' Block2 ]] = handle-thrown( exec[[ Block1 ]], scope( bind(id[[ Id ]], allocate-initialised-variable(values,given)), exec[[ Block2 ]])) Rule exec[[ 'throw' Exp ';' ]] = throw(rval[[ Exp ]]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-3-Statements/index.html#SectionNumber_3",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-3-Statements/index.html#SectionNumber_3"
  },"388": {
    "doc": "SIMPLE-3-Statements",
    "title": "SIMPLE-3-Statements",
    "content": "Languages-beta : SIMPLE-3-Statements.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-3-Statements/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-3-Statements/index.html"
  },"389": {
    "doc": "SIMPLE-4-Declarations",
    "title": "4 Declarations",
    "content": "Syntax Decl : decl ::= vars-decl | func-decl . Semantics declare[[ _:decl ]] : =&gt;environments . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4"
  },"390": {
    "doc": "SIMPLE-4-Declarations",
    "title": "4.1 Variable Declarations",
    "content": "Syntax VarsDecl : vars-decl ::= 'var' declarators ';' Declarators : declarators ::= declarator (',' declarators)? . Rule [[ 'var' Declarator ',' Declarators ';' Stmts? ]] : stmts = [[ 'var' Declarator ';' 'var' Declarators ';' Stmts? ]] Rule [[ 'var' Declarator ',' Declarators ';' Decls? ]] : decls = [[ 'var' Declarator ';' 'var' Declarators ';' Decls? ]] Rule declare[[ 'var' Declarator ';' ]] = var-declare[[ Declarator ]] . Syntax Declarator : declarator ::= id | id '=' exp | id ranks . Semantics var-declare[[ _:declarator ]] : =&gt;environments Rule var-declare[[ Id ]] = bind(id[[ Id ]], allocate-variable(values)) Rule var-declare[[ Id '=' Exp ]] = bind(id[[ Id ]], allocate-initialised-variable(values, rval[[ Exp ]])) Rule var-declare[[ Id Ranks ]] = bind(id[[ Id ]], allocate-nested-vectors(ranks[[ Ranks ]])) . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.1",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.1"
  },"391": {
    "doc": "SIMPLE-4-Declarations",
    "title": "4.2 Arrays",
    "content": "Syntax Ranks : ranks ::= '[' exps ']' ranks? . Rule [[ '[' Exp ',' Exps ']' Ranks? ]] : ranks = [[ '[' Exp ']' '[' Exps ']' Ranks? ]] . Compare this with p28 of the K version. Semantics ranks[[ _:ranks ]] : (=&gt;nats)+ Rule ranks[[ '[' Exp ']' ]] = rval[[ Exp ]] Rule ranks[[ '[' Exp ']' Ranks ]] = rval[[ Exp ]] , ranks[[ Ranks ]] . Funcon allocate-nested-vectors(_:nats+) : =&gt;variables Rule allocate-nested-vectors(N:nats) ~&gt; allocate-initialised-variable(vectors(variables), vector(left-to-right-repeat(allocate-variable(values),1,N))) Rule allocate-nested-vectors(N:nats,N+:nats+) ~&gt; allocate-initialised-variable(vectors(variables), vector(left-to-right-repeat(allocate-nested-vectors(N+),1,N))) . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.2",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.2"
  },"392": {
    "doc": "SIMPLE-4-Declarations",
    "title": "4.3 Function Declarations",
    "content": "Syntax FuncDecl : func-decl ::= 'function' id '(' ids? ')' block . Rule declare[[ 'function' Id '(' Ids? ')' Block ]] = bind(id[[ Id ]], allocate-variable(functions(tuples(values*),values))) . Semantics initialise[[ _:decl ]] : =&gt;null-type Rule initialise[[ 'var' Declarators ';' ]] = null Rule initialise[[ 'function' Id '(' Ids? ')' Block ]] = assign( bound(id[[ Id ]]), function closure( scope( match(given,tuple(patts[[ Ids? ]])), handle-return(exec[[ Block ]])))) . Syntax Ids : ids ::= id (',' ids)? . Semantics patts[[ _:ids? ]] : patterns* Rule patts[[ ]] = ( ) Rule patts[[ Id ]] = pattern closure(bind(id[[ Id ]], allocate-initialised-variable(values, given))) Rule patts[[ Id ',' Ids ]] = patts[[ Id ]] , patts[[ Ids ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.3",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html#SectionNumber_4.3"
  },"393": {
    "doc": "SIMPLE-4-Declarations",
    "title": "SIMPLE-4-Declarations",
    "content": "Languages-beta : SIMPLE-4-Declarations.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-4-Declarations/index.html"
  },"394": {
    "doc": "SIMPLE-5-Programs",
    "title": "5 Programs",
    "content": "Syntax Pgm : pgm ::= decls . Semantics run[[ Decls:pgm ]] : =&gt;values = scope( collateral(declarations[[ Decls ]]), sequential( initialisations[[ Decls ]], apply(assigned(bound(\"main\")), tuple( )))) . Syntax Decls : decls ::= decl decls? . Semantics declarations[[ _:decls ]] : (=&gt;environments)+ Rule declarations[[ Decl ]] = declare[[ Decl ]] Rule declarations[[ Decl Decls ]] = declare[[ Decl ]], declarations[[ Decls ]] . Semantics initialisations[[ _:decls ]] : (=&gt;null-type)+ Rule initialisations[[ Decl ]] = initialise[[ Decl ]] Rule initialisations[[ Decl Decls ]] = initialise[[ Decl ]], initialisations[[ Decls ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-5-Programs/index.html#SectionNumber_5",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-5-Programs/index.html#SectionNumber_5"
  },"395": {
    "doc": "SIMPLE-5-Programs",
    "title": "SIMPLE-5-Programs",
    "content": "Languages-beta : SIMPLE-5-Programs.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-5-Programs/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-5-Programs/index.html"
  },"396": {
    "doc": "SIMPLE-A-Disambiguation",
    "title": "A Disambiguation",
    "content": "Lexis SDF lexical syntax id = keyword {reject} lexical restrictions id -/- [A-Za-z0-9] Syntax SDF context-free syntax exp ::= exp '*' exp {left} exp ::= exp '/' exp {left} exp ::= exp '%' exp {left} exp ::= exp '+' exp {left} exp ::= exp '-' exp {left} exp ::= exp '&amp;&amp;' exp {left} exp ::= exp '||' exp {left} context-free priorities { exp ::= exp '(' exps? ')' } &gt; { exp ::= '-' exp exp ::= '++' lexp exp ::= '!' exp } &gt; {left: exp ::= exp '*' exp exp ::= exp '/' exp exp ::= exp '%' exp } &gt; {left: exp ::= exp '+' exp exp ::= exp '-' exp } &gt; {non-assoc: exp ::= exp '&lt;' exp exp ::= exp '&lt;=' exp exp ::= exp '&gt;' exp exp ::= exp '&gt;=' exp exp ::= exp '==' exp exp ::= exp '!=' exp } &gt; {assoc: exp ::= exp '&amp;&amp;' exp } &gt; {assoc: exp ::= exp '||' exp } &gt; { exp ::= lexp '=' exp } . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-A-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-A-Disambiguation/index.html#SectionNumber_A"
  },"397": {
    "doc": "SIMPLE-A-Disambiguation",
    "title": "SIMPLE-A-Disambiguation",
    "content": "Languages-beta : SIMPLE-A-Disambiguation.cbs | PRETTY | PDF . Language \"SIMPLE\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-A-Disambiguation/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-A-Disambiguation/index.html"
  },"398": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#computations"
  },"399": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#normal-computation"
  },"400": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#flowing"
  },"401": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon initialise-giving Funcon give Funcon given Funcon left-to-right-repeat ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#giving"
  },"402": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon scope Funcon collateral ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#binding"
  },"403": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Datatype variables Alias vars Funcon allocate-variable Alias alloc Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#storing"
  },"404": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Funcon read ] . Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#interacting"
  },"405": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#abnormal-computation"
  },"406": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon checked ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#failing"
  },"407": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Throwing",
    "content": "[ Funcon finalise-throwing Funcon throw Funcon handle-thrown ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#throwing",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#throwing"
  },"408": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Returning",
    "content": "[ Funcon return Funcon handle-return ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#returning",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#returning"
  },"409": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#values",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#values"
  },"410": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#value-types"
  },"411": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#primitive-values"
  },"412": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Booleans",
    "content": "[ Funcon true Funcon false Funcon not ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#booleans"
  },"413": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Integers",
    "content": "[ Type natural-numbers Alias nats Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-modulo Alias int-mod Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#integers"
  },"414": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#the-null-value"
  },"415": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#composite-values"
  },"416": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#sequences-of-values"
  },"417": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#tuples"
  },"418": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#vectors",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#vectors"
  },"419": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#abstraction-values"
  },"420": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Funcon closure ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#generic-abstractions"
  },"421": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#functions"
  },"422": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon match ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#patterns",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html#patterns"
  },"423": {
    "doc": "SIMPLE-Funcons-Index",
    "title": "SIMPLE-Funcons-Index",
    "content": "Languages-beta : SIMPLE-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Storing | Interacting . | Input | Output | . | . | Abnormal computation . | Failing | Throwing | Returning | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Sequences of values | Tuples | Vectors | . | Abstraction values . | Generic abstractions | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Funcons-Index/index.html"
  },"424": {
    "doc": "SIMPLE-Start",
    "title": "SIMPLE-Start",
    "content": "Languages-beta : SIMPLE-Start.cbs | PRETTY | PDF . Language \"SIMPLE\" . Syntax START : start ::= pgm . Semantics start[[_:start]] : =&gt;values Rule start[[ Pgm ]] = initialise-binding initialise-storing initialise-giving finalise-failing finalise-throwing run[[ Pgm ]] . [ # 1 Lexical Syntax # 2 Expressions # 3 Statements # 4 Declarations # 5 Programs # A Disambiguation ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Start/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/SIMPLE-cbs/SIMPLE/SIMPLE-Start/index.html"
  },"425": {
    "doc": "SIMPLE",
    "title": "SIMPLE",
    "content": "Grigore Rosu and Traian Florin Serbanuta gave a definition of SIMPLE in the K framework. They wrote: . SIMPLE is intended to be a pedagogical and research language that captures the essence of the imperative programming paradigm, extended with several features often encountered in imperative languages. SIMPLE is a somewhat larger imperative language than IMP. Its CBS illustrates further features of the framework. The start of the specification of SIMPLE in CBS is at SIMPLE. Note that this CBS specification of SIMPLE does not yet include threads, since funcons for threads were not yet available when it was created. See SIMPLE-Threads for a CBS of the full SIMPLE language. ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/index.html",
    "relUrl": "/docs/Languages-beta/SIMPLE/index.html"
  },"426": {
    "doc": "SIMPLE",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete, derived from K Overview and SIMPLE Case Study | dynamic semantics: complete except for concurrency constructs | static semantics: not specified | disambiguation: incomplete | . Tests: . | 53 small programs | high coverage (to be verified) | . Evolution: . | initial version | . Reuse of funcons: . | SIMPLE-Funcons-Index | . References: . | K Overview and SIMPLE Case Study | . Keywords: . | imperative, illustrative, simple, disambiguation, K framework | . Main contributors: . | Thomas van Binsbergen, Peter Mosses, Neil Sculthorpe | . ",
    "url": "/CBS-beta/docs/Languages-beta/SIMPLE/index.html#colophon",
    "relUrl": "/docs/Languages-beta/SIMPLE/index.html#colophon"
  },"427": {
    "doc": "SL-1-Lexemes",
    "title": "1 Lexemes",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#SectionNumber_1",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#SectionNumber_1"
  },"428": {
    "doc": "SL-1-Lexemes",
    "title": "Identifiers",
    "content": "Lexis Id : id ::= ('a'-'z'|'A'-'Z') ('a'-'z'|'A'-'Z'|'0'-'9')* . Semantics id[[ Id:id ]] : =&gt; ids Rule id[[ Id ]] = \\\"Id\\\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#identifiers",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#identifiers"
  },"429": {
    "doc": "SL-1-Lexemes",
    "title": "Numerals",
    "content": "Syntax Int : int ::= '-'? _ nat Lexis Nat : nat ::= ('0'-'9')+ . Semantics int-val[[ Int:int ]] : =&gt; integers Rule int-val[[ '-' Nat ]] = integer-negate int-val[[Nat]] Rule int-val[[ Nat ]] = decimal-natural \\\"Nat\\\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#numerals",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#numerals"
  },"430": {
    "doc": "SL-1-Lexemes",
    "title": "Strings",
    "content": "Syntax String : string ::= '\"' _ string-chars _ '\"' Lexis StringChars : string-chars ::= string-char* string-char ::= ~( '\"' | '\\n' ) . Semantics string-val[[ String:string ]] : =&gt; strings Rule string-val[[ '\"' StringChars '\"' ]] = \\\"StringChars\\\" . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#strings",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html#strings"
  },"431": {
    "doc": "SL-1-Lexemes",
    "title": "SL-1-Lexemes",
    "content": "Languages-beta : SL-1-Lexemes.cbs | PRETTY | PDF . Outline . | 1 Lexemes . | Identifiers | Numerals | Strings | . | . Language \"SL\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-1-Lexemes/index.html"
  },"432": {
    "doc": "SL-2-Expressions",
    "title": "2 Expressions",
    "content": "Syntax Expr : expr ::= int | string | 'true' | 'false' | expr '+' expr | expr '/' expr | expr '*' expr | expr '-' expr | expr '==' expr | expr '&lt;=' expr | expr '&lt;' expr | expr '!=' expr | expr '&gt;=' expr | expr '&gt;' expr | expr '&amp;&amp;' expr | expr '||' expr | '!' expr | id '(' expr-list? ')' | id | id '=' expr | expr '.' id | expr '.' id '=' expr | expr '.' id '(' expr-list? ')' | '(' expr ')' . Rule [[ '(' Expr ')' ]] : expr = [[ Expr ]] . Type sl-values ~&gt; booleans | integers | strings | objects | null-type . Semantics eval[[ Expr:expr ]] : =&gt; sl-values Rule eval[[ Int ]] = int-val[[Int]] Rule eval[[ String ]] = string-val[[String]] Rule eval[[ 'true' ]] = true Rule eval[[ 'false' ]] = false Rule eval[[ Expr1 '+' Expr2 ]] = integer-add-else-string-append(eval[[Expr1]], eval[[Expr2]]) Rule eval[[ Expr1 '/' Expr2 ]] = checked integer-divide(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '*' Expr2 ]] = integer-multiply(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '-' Expr2 ]] = integer-subtract(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '==' Expr2 ]] = is-equal(eval[[Expr1]], eval[[Expr2]]) Rule eval[[ Expr1 '&lt;=' Expr2 ]] = is-less-or-equal(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '&lt;' Expr2 ]] = is-less(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '!=' Expr2 ]] = not is-equal(eval[[Expr1]], eval[[Expr2]]) Rule eval[[ Expr1 '&gt;=' Expr2 ]] = is-greater-or-equal(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '&gt;' Expr2 ]] = is-greater(int eval[[Expr1]], int eval[[Expr2]]) Rule eval[[ Expr1 '&amp;&amp;' Expr2 ]] = if-true-else(bool eval[[Expr1]], bool eval[[Expr2]], false) Rule eval[[ Expr1 '||' Expr2 ]] = if-true-else(bool eval[[Expr1]], true, bool eval[[Expr2]]) Rule eval[[ '!' Expr ]] = not(bool eval[[Expr]]) Rule eval[[ 'new' '(' ')' ]] = object(fresh-atom, \"Object\", initialise-local-variables) Rule eval[[ 'println' '(' Expr ')' ]] = print-line sl-to-string eval[[Expr]] Rule eval[[ 'readln' '(' ')' ]] = [ read-line ] Rule eval[[ 'defineFunction' '(' Expr ')' ]] = fail// // give(str eval[[Expr]], // override-global-bindings(declare[[given]])) // // Dynamic parsing and translation to funcons not yet implemented Rule eval[[ 'nanoTime' '(' ')' ]] = fail Rule eval[[ 'stacktrace' '(' ')' ]] = fail Otherwise eval[[ Id '(' ExprList? ')' ]] = apply(fun global-bound eval[[Id]], eval-list[[ExprList?]]) Rule eval[[ Id ]] = else(assigned local-variable id[[Id]], str id[[Id]]) Rule eval[[ Id '=' Expr ]] = give(eval[[Expr]], sequential(local-variable-assign(id[[Id]], given), given)) Rule eval[[ Expr '.' Id ]] = scope-closed(object-feature-map obj eval[[Expr]], else(assigned local-variable id[[Id]], null-value)) Rule eval[[ Expr1 '.' Id '=' Expr2 ]] = give(eval[[Expr2]], scope-closed( object-feature-map obj eval[[Expr1]], sequential(local-variable-assign(id[[Id]], given), given))) Rule eval[[ Expr '.' Id '(' ExprList? ')' ]] = apply(fun global-bound eval[[Expr '.' Id]], eval-list[[ExprList?]]) . Syntax ExprList : expr-list ::= expr (',' expr-list)? . Semantics eval-list[[ _:expr-list? ]] : =&gt; lists(sl-values) Rule eval-list[[ ]] = nil Rule eval-list[[ Expr ]] = cons(eval[[Expr]], nil) Rule eval-list[[ Expr ',' ExprList ]] = cons(eval[[Expr]], eval-list[[ExprList]]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-2-Expressions/index.html#SectionNumber_2",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-2-Expressions/index.html#SectionNumber_2"
  },"433": {
    "doc": "SL-2-Expressions",
    "title": "SL-2-Expressions",
    "content": "Languages-beta : SL-2-Expressions.cbs | PRETTY | PDF . Language \"SL\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-2-Expressions/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-2-Expressions/index.html"
  },"434": {
    "doc": "SL-3-Statements",
    "title": "3 Statements",
    "content": "Syntax Stmt : stmt ::= expr ';' | 'return' expr ';' | 'return' ';' | 'if' '(' expr ')' block | 'if' '(' expr ')' block 'else' block | 'while' '(' expr ')' block | 'break' ';' | 'continue' ';' | block Block : block ::= '{' stmt* '}' . Rule [[ 'if' '(' Expr ')' Block ]] : stmt = [[ 'if' '(' Expr ')' Block 'else' '{' '}' ]] . Semantics exec[[ Stmt*:stmt* ]] : =&gt; null-type Rule exec[[ Expr ';' ]] = effect(eval[[Expr]]) Rule exec[[ 'return' Expr ';' ]] = return(eval[[Expr]]) Rule exec[[ 'return' ';' ]] = return(null-value) Rule exec[[ 'if' '(' Expr ')' Block1 'else' Block2 ]] = if-true-else(bool eval[[Expr]], exec[[Block1]], exec[[Block2]]) Rule exec[[ 'while' '(' Expr ')' Block ]] = handle-break( while-true(bool eval[[Expr]], handle-continue(exec[[Block]]))) Rule exec[[ 'break' ';' ]] = break Rule exec[[ 'continue' ';' ]] = continue Rule exec[[ '{' Stmt* '}' ]] = exec[[Stmt*]] Rule exec[[ ]] = null-value Rule exec[[ Stmt Stmt+ ]] = sequential(exec[[Stmt]], exec[[Stmt+]]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-3-Statements/index.html#SectionNumber_3",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-3-Statements/index.html#SectionNumber_3"
  },"435": {
    "doc": "SL-3-Statements",
    "title": "SL-3-Statements",
    "content": "Languages-beta : SL-3-Statements.cbs | PRETTY | PDF . Language \"SL\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-3-Statements/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-3-Statements/index.html"
  },"436": {
    "doc": "SL-4-Definitions",
    "title": "4 Function definitions",
    "content": "Syntax FunDef : fun-def ::= 'function' id '(' id-list? ')' block . Semantics declare[[ FunDef*:fun-def* ]] : =&gt; environments Rule declare[[ 'function' Id '(' IdList? ')' Block ]] = { id[[Id]] |-&gt; function closure scope(initialise-local-variables, sequential( pass-list[[IdList?]], handle-return(exec[[Block]]))) } Rule declare[[ ]] = map( ) Rule declare[[ FunDef FunDef+ ]] = collateral(declare[[FunDef]], declare[[FunDef+]]) . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html#SectionNumber_4",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html#SectionNumber_4"
  },"437": {
    "doc": "SL-4-Definitions",
    "title": "Parameter lists",
    "content": "Syntax IdList : id-list ::= id (',' id-list)? . Semantics pass-list[[ IdList:id-list? ]] : lists(values) =&gt; null-type Rule pass-list[[ ]] = null-value Rule pass-list[[ Id ]] = local-variable-initialise(id[[Id]], checked head given) Rule pass-list[[ Id ',' IdList ]] = sequential( local-variable-initialise(id[[Id]], checked head given), give(checked tail given, pass-list[[IdList]])) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html#parameter-lists",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html#parameter-lists"
  },"438": {
    "doc": "SL-4-Definitions",
    "title": "SL-4-Definitions",
    "content": "Languages-beta : SL-4-Definitions.cbs | PRETTY | PDF . Language \"SL\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-4-Definitions/index.html"
  },"439": {
    "doc": "SL-Disambiguation",
    "title": "A Disambiguation",
    "content": "Specification of disambiguation for parsing currently requires direct use of the corresponding SDF3 notation in comments, along with embedded productions in CBS notation. The well-formedness of the SDF3 notation is not checked. A future version of CBS is to include appropriate constructs for specifying disambiguation. Syntax SDF context-free syntax expr ::= expr '+' expr {left} expr ::= expr '/' expr {left} expr ::= expr '*' expr {left} expr ::= expr '-' expr {left} expr ::= expr '==' expr {non-assoc} expr ::= expr '&lt;=' expr {non-assoc} expr ::= expr '&lt;' expr {non-assoc} expr ::= expr '!=' expr {non-assoc} expr ::= expr '&gt;=' expr {non-assoc} expr ::= expr '&gt;' expr {non-assoc} expr ::= expr '&amp;&amp;' expr {left} expr ::= expr '||' expr {left} expr ::= id '=' expr {right} expr ::= expr '.' id '=' expr {right} context-free priorities {left: expr ::= expr '.' id '(' expr-list? ')' } &gt; {right: expr ::= '!' expr } &gt; {left: expr ::= expr '*' expr expr ::= expr '&amp;&amp;' expr } &gt; {non-assoc: expr ::= expr '==' expr expr ::= expr '&lt;=' expr expr ::= expr '&lt;' expr expr ::= expr '!=' expr expr ::= expr '&gt;=' expr expr ::= expr '&gt;' expr } &gt; {left: expr ::= expr '+' expr expr ::= expr '-' expr expr ::= expr '||' expr } &gt; {right: expr ::= id '=' expr expr ::= expr '.' id '=' expr } Lexis SDF lexical syntax id = \"function\" {reject} id = \"true\" {reject} id = \"false\" {reject} id = \"return\" {reject} id = \"break\" {reject} id = \"continue\" {reject} id = \"while\" {reject} id = \"if\" {reject} id = \"else\" {reject} lexical restrictions // Ensure greedy matching for lexicals nat -/- [0-9] id -/- [a-zA-Z0-9\\_] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Disambiguation/index.html#SectionNumber_A"
  },"440": {
    "doc": "SL-Disambiguation",
    "title": "SL-Disambiguation",
    "content": "Languages-beta : SL-Disambiguation.cbs | PRETTY | PDF . Language \"SL\" . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Disambiguation/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Disambiguation/index.html"
  },"441": {
    "doc": "SL-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#computations"
  },"442": {
    "doc": "SL-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#normal-computation"
  },"443": {
    "doc": "SL-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#flowing"
  },"444": {
    "doc": "SL-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon initialise-giving Funcon give Funcon given ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#giving"
  },"445": {
    "doc": "SL-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon closed Funcon scope Funcon collateral ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#binding"
  },"446": {
    "doc": "SL-Funcons-Index",
    "title": "Generating",
    "content": "[ Funcon fresh-atom ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#generating",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#generating"
  },"447": {
    "doc": "SL-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Datatype variables Alias vars Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#storing"
  },"448": {
    "doc": "SL-Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Funcon read ] . Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#interacting"
  },"449": {
    "doc": "SL-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#abnormal-computation"
  },"450": {
    "doc": "SL-Funcons-Index",
    "title": "Terminating abruptly",
    "content": "[ Funcon finalise-abrupting ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#terminating-abruptly",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#terminating-abruptly"
  },"451": {
    "doc": "SL-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon fail Funcon else Funcon checked ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#failing"
  },"452": {
    "doc": "SL-Funcons-Index",
    "title": "Returning",
    "content": "[ Funcon return Funcon handle-return ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#returning",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#returning"
  },"453": {
    "doc": "SL-Funcons-Index",
    "title": "Breaking",
    "content": "[ Funcon break Funcon handle-break ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#breaking",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#breaking"
  },"454": {
    "doc": "SL-Funcons-Index",
    "title": "Continuing",
    "content": "[ Funcon continue Funcon handle-continue ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#continuing",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#continuing"
  },"455": {
    "doc": "SL-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#values",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#values"
  },"456": {
    "doc": "SL-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Type cast-to-type Alias cast Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#value-types"
  },"457": {
    "doc": "SL-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#primitive-values"
  },"458": {
    "doc": "SL-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#booleans"
  },"459": {
    "doc": "SL-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#integers"
  },"460": {
    "doc": "SL-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#the-null-value"
  },"461": {
    "doc": "SL-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#composite-values"
  },"462": {
    "doc": "SL-Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list-nil Alias nil Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#lists",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#lists"
  },"463": {
    "doc": "SL-Funcons-Index",
    "title": "Strings",
    "content": "[ Type strings Funcon string-append Funcon to-string ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#strings",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#strings"
  },"464": {
    "doc": "SL-Funcons-Index",
    "title": "Maps",
    "content": "[ Funcon map Funcon map-lookup Alias lookup Funcon map-override ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#maps"
  },"465": {
    "doc": "SL-Funcons-Index",
    "title": "Objects",
    "content": "[ Datatype objects Funcon object Funcon object-feature-map ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#objects",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#objects"
  },"466": {
    "doc": "SL-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#abstraction-values"
  },"467": {
    "doc": "SL-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Funcon closure ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#generic-abstractions"
  },"468": {
    "doc": "SL-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html#functions"
  },"469": {
    "doc": "SL-Funcons-Index",
    "title": "SL-Funcons-Index",
    "content": "Languages-beta : SL-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Interacting . | Input | Output | . | . | Abnormal computation . | Terminating abruptly | Failing | Returning | Breaking | Continuing | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Lists | Strings | Maps | Objects | . | Abstraction values . | Generic abstractions | Functions | . | . | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons-Index/index.html"
  },"470": {
    "doc": "SL-Funcons",
    "title": "SL-specific funcons",
    "content": "Funcon sl-to-string(V:sl-values) : =&gt; strings Rule sl-to-string(null-value) ~&gt; \"null\" Rule sl-to-string(V:~null-type) ~&gt; to-string(V) . Funcon integer-add-else-string-append(V1:sl-values, V2:sl-values) : =&gt; sl-values ~&gt; else( integer-add(int V1, int V2), string-append(sl-to-string V1, sl-to-string V2)) . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#sl-specific-funcons",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#sl-specific-funcons"
  },"471": {
    "doc": "SL-Funcons",
    "title": "Abbreviations",
    "content": "Funcon int(V:sl-values) : =&gt; integers ~&gt; checked cast-to-type(V, integers) . Funcon bool(V:sl-values) : =&gt; booleans ~&gt; checked cast-to-type(V, booleans) . Funcon str(V:sl-values) : =&gt; strings ~&gt; checked cast-to-type(V, strings) . Funcon obj(V:sl-values) : =&gt; objects ~&gt; checked cast-to-type(V, objects) . Funcon fun(V:values) : =&gt; functions(_, _) ~&gt; checked cast-to-type(V, functions(_, _)) . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#abbreviations",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#abbreviations"
  },"472": {
    "doc": "SL-Funcons",
    "title": "Further funcons",
    "content": "Some of the funcons defined below might be sufficiently reuseful for inclusion in Funcons-beta. ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#further-funcons",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#further-funcons"
  },"473": {
    "doc": "SL-Funcons",
    "title": "Binding",
    "content": "Funcon scope-closed(Env:envs, X:=&gt;T) : =&gt; T ~&gt; closed scope(Env, X) . scope-closed(D, X) evaluates D in the current environment, then evaluates X in the resulting environment. Note the difference between scope-closed(D, X) and closed(scope(D, X)): the latter is equivalent to closed(scope(closed D, X)), where D cannot reference any bindings. ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#binding",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#binding"
  },"474": {
    "doc": "SL-Funcons",
    "title": "Local variables",
    "content": "The local variable map is stored in a variable bound to “local-variables”. Initialising a local variable updates the stored local variable map. Subsequent assignments to a local variable do not change the stored map. Funcon initialise-local-variables : =&gt; environments ~&gt; bind(\"local-variables\", allocate-initialised-variable(environments, map( ))) . Funcon local-variable(I:ids) : =&gt; variables ~&gt; checked lookup(assigned bound \"local-variables\", I) . Funcon local-variable-initialise(I:ids, V:values) : =&gt; null-type ~&gt; assign(bound \"local-variables\", map-override( { I |-&gt; allocate-initialised-variable(values, V) }, assigned bound \"local-variables\")) . Funcon local-variable-assign(I:ids, V:values) : =&gt; null-type ~&gt; else( assign(local-variable I, V), local-variable-initialise(I, V)) . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#local-variables",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#local-variables"
  },"475": {
    "doc": "SL-Funcons",
    "title": "Global bindings",
    "content": "The global bindings map is stored in a variable bound to “global-bindings”. Global declaration or redeclaration of an identifier involves updating the stored global environment. Funcon initialise-global-bindings : =&gt; environments ~&gt; bind(\"global-bindings\", allocate-initialised-variable(environments, map( ))) . Funcon override-global-bindings(E:environments) : =&gt; null-type ~&gt; assign(bound \"global-bindings\", map-override(E, assigned bound \"global-bindings\")) . Funcon global-bound(I:ids) : =&gt; values ~&gt; checked lookup(assigned bound \"global-bindings\", I) . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#global-bindings",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#global-bindings"
  },"476": {
    "doc": "SL-Funcons",
    "title": "Composite input and output",
    "content": "Funcon read-line : =&gt; strings ~&gt; give(read, if-true-else(is-eq(given, '\\n'), nil, cons(given, read-line))) . read-line reads characters from the standard input until a linefeed character, giving the string formed from the sequence of characters excluding the newline. If the input ends before the end of the line, it fails. Funcon print-line(S:strings) : =&gt; null-type ~&gt; print(S, \"\\n\") . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#composite-input-and-output",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html#composite-input-and-output"
  },"477": {
    "doc": "SL-Funcons",
    "title": "SL-Funcons",
    "content": "Languages-beta : SL-Funcons.cbs | PRETTY | PDF . Outline . | SL-specific funcons | Abbreviations | Further funcons . | Binding | Local variables | Global bindings | Composite input and output | . | . Language \"SL\" . [ // SL-specific funcons Funcon sl-to-string Funcon integer-add-else-string-append // Abbreviations Funcon int Funcon bool Funcon str Funcon obj Funcon fun // Further funcons // Binding Funcon scope-closed // Local variables Funcon initialise-local-variables Funcon local-variable Funcon local-variable-initialise Funcon local-variable-assign // Global bindings Funcon initialise-global-bindings Funcon override-global-bindings Funcon global-bound // Composite input and output Funcon read-line Funcon print-line ] . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Funcons/index.html"
  },"478": {
    "doc": "SL-Start",
    "title": "SL-Start",
    "content": "Languages-beta : SL-Start.cbs | PRETTY | PDF . Language \"SL\" . [ # 1 Lexemes # 2 Expressions # 3 Statements # 4 Function definitions # A Disambiguation ] . Syntax START : start ::= program . Semantics start[[ START:start ]] : =&gt; null-type Rule start[[ Program ]] = initialise-binding initialise-storing initialise-giving finalise-abrupting run[[Program]] . Syntax Program : program ::= fun-def* . Semantics run[[ Program:program ]] : =&gt; null-type Rule run[[ FunDef* ]] = scope( initialise-global-bindings, sequential( override-global-bindings(declare[[FunDef*]]), apply(fun global-bound \"main\", nil))) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/SL-cbs/SL/SL-Start/index.html",
    "relUrl": "/docs/Languages-beta/SL/SL-cbs/SL/SL-Start/index.html"
  },"479": {
    "doc": "SL",
    "title": "SL",
    "content": "The SimpleLanguage, abbreviated “SL”, is a dynamic demonstration language. It was built using Truffle for the GraalVM at Oracle Labs. A specification of SL in DynSem has been given by Vlad Vergu. Its CBS illustrates how dynamic bindings can be translated to funcons. The start of the specification of SL in CBS is at SL. This CBS specification of SL has been prototyped using a funcon interpreter generated using the Haskell package Funcons Tools. ",
    "url": "/CBS-beta/docs/Languages-beta/SL/index.html",
    "relUrl": "/docs/Languages-beta/SL/index.html"
  },"480": {
    "doc": "SL",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete, derived from [SL in SD3] | dynamic semantics: complete except for ‘defineFunction’, ‘stackTrace’, ‘nanoTime’ | static semantics: not relevant | disambiguation: complete, derived from SL in SDF3 | . Tests: . | 15 small programs | medium coverage (to be verified) | . Evolution: . | first version | . Reuse of funcons: . | SL-Funcons-Index | . References: . | SL in DynSem | . Keywords: . | dynamic language, dynamic binding, imperative, disambiguation | . Main contributors: . | Peter Mosses | previous: Vlad Vergu | . ",
    "url": "/CBS-beta/docs/Languages-beta/SL/index.html#colophon",
    "relUrl": "/docs/Languages-beta/SL/index.html#colophon"
  },"481": {
    "doc": "Languages-beta",
    "title": "Languages-beta",
    "content": "This page provides access to the beta-release of five examples of language specifications in CBS, based on an initial collection of so-called ‘funcons’ (fundamental programming constructs). Funcons are reusable components of programming language specifications: in the CBS framework, a language is specified by defining a translation from its constructs to funcon terms, reusing (by reference) the definitions of the required funcons. Before proceeding, take a look at the navigation and language definition sections of the Browsing guide. See Funcons-beta for the beta-release of an initial collection of funcons. Those funcons used in the CBS of a particular language are listed in an index, accessed from the dropdown menu shown when browsing its specification. The specification of each funcon has been validated by basic unit tests that exercise all its rules. Moreover, funcons that are reused in two or more of the illustrative language specifications have been exercised in different contexts. The current level of validation of the illustrative language specifications varies considerably, and the coverage of the test suites has not yet been analysed. The colophon on the start page of each language specification includes the size of the current test suite and an indication of its expected coverage. Further tests are to be made during the beta-release review period; the test suites will subsequently be added to this website. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html",
    "relUrl": "/docs/Languages-beta/index.html"
  },"482": {
    "doc": "Languages-beta",
    "title": "IMP",
    "content": "IMP is a very small imperative language. Its CBS specification illustrates the basic features of the framework. See IMP in CBS for further details. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#imp",
    "relUrl": "/docs/Languages-beta/index.html#imp"
  },"483": {
    "doc": "Languages-beta",
    "title": "SIMPLE",
    "content": "SIMPLE is a somewhat larger imperative language than IMP. Its CBS illustrates further features of the framework. See SIMPLE in CBS for further details. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#simple",
    "relUrl": "/docs/Languages-beta/index.html#simple"
  },"484": {
    "doc": "Languages-beta",
    "title": "MiniJava",
    "content": "MiniJava is a very simple subset of Java. Its CBS illustrates the funcons for classes and objects. See MiniJava in CBS for further details. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#minijava",
    "relUrl": "/docs/Languages-beta/index.html#minijava"
  },"485": {
    "doc": "Languages-beta",
    "title": "SL",
    "content": "The SimpleLanguage, abbreviated “SL”, is a dynamic language. Its CBS illustrates how dynamic bindings can be translated to funcons. See SL in CBS for further details. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#sl",
    "relUrl": "/docs/Languages-beta/index.html#sl"
  },"486": {
    "doc": "Languages-beta",
    "title": "OCaml Light",
    "content": "OCaml Light is a core sublanguage of OCaml, corresponding closely to Caml Light (an obsolete pedagogical functional programming language). Its CBS illustrates scaling up to a medium-sized language. See OCaml Light in CBS for further details. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#ocaml-light",
    "relUrl": "/docs/Languages-beta/index.html#ocaml-light"
  },"487": {
    "doc": "Languages-beta",
    "title": "Funcon reuse",
    "content": "The reuse page shows how may funcons are directly reused in the different language specifications. ",
    "url": "/CBS-beta/docs/Languages-beta/index.html#funcon-reuse",
    "relUrl": "/docs/Languages-beta/index.html#funcon-reuse"
  },"488": {
    "doc": "Postponing",
    "title": "Postponing",
    "content": "[ Entity postponing Funcon postpone Funcon postpone-after-effect Funcon after-effect ] . A funcon term can extend itself (e.g., with code to release the resources allocated to it) using general funcons for postponed execution. When a step from X to X&prime; executes postpone(Y) (which computes null), the corresponding step of postpone-after-effect(X) gives postpone-after-effect(after-effect(X&prime;, Y)), so that normal termination of X&prime; is followed by the effect of Y. The control entity postponing(A) signals that the execution of the body of the abstraction A is postponed: . Entity _ --postponing(_:(abstractions(=&gt;null-type))?)-&gt; _ . The funcon postpone(X) forms a closure from X and signals that its execution is postponed: . Funcon postpone(_:=&gt;values) : =&gt;null-type Rule given-value(V) |- closure give(V, X) --postponing( )-&gt; A ---------------------------------------------------------- given-value(V) |- postpone(X) --postponing(A)-&gt; null-value Rule given-value( ) |- closure no-given X --postponing( )-&gt; A ---------------------------------------------------------- given-value( ) |- postpone(X) --postponing(A)-&gt; null-value . The funcon postpone-after-effect(X) handles each signal postponing(A) by adding it as an after-effect of X: . Funcon postpone-after-effect(_:=&gt;T) : =&gt;T Rule X --postponing( )-&gt; X&prime; ------------------------------------------ postpone-after-effect(X) --postponing( )-&gt; postpone-after-effect(X&prime;) Rule X --postponing(A)-&gt; X&prime; A ~&gt; abstraction Y -------------------------------------------- postpone-after-effect(X) --postponing( )-&gt; postpone-after-effect(after-effect(X&prime;, Y)) Rule postpone-after-effect(V:values) ~&gt; V . The funcon after-effect(X, Y) first executes X. If X computes a value V, it then executes Y, and computes V: . Funcon after-effect(X:=&gt;T, Y:=&gt;null-type) : =&gt;T ~&gt; give(X, sequential(Y, given)) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Abnormal/Postponing/index.html#postponing",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Abnormal/Postponing/index.html#postponing"
  },"489": {
    "doc": "Postponing",
    "title": "Postponing",
    "content": "Unstable-Funcons-beta : Postponing.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Abnormal/Postponing/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Abnormal/Postponing/index.html"
  },"490": {
    "doc": "Abnormal",
    "title": "Abnormal computation",
    "content": "These funcons are potentially of general use, but first defined for use in connection with languages that include threads. | Postponing: adding after-effects to an enclosing term | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Abnormal/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Abnormal/index.html#abnormal-computation"
  },"491": {
    "doc": "Abnormal",
    "title": "Abnormal",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Abnormal/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Abnormal/index.html"
  },"492": {
    "doc": "Indexing",
    "title": "Value indexing",
    "content": "[ Entity value-index Funcon initialise-index Funcon allocate-index Funcon lookup-index ] . The following funcons support indexing of values by natural numbers. They could be enhanced to ensure that each value has at most one index, and to allow finding the index of a value. Entity &lt; _ , value-index(_:ground-values*) &gt; ---&gt; &lt; _ , value-index(_:ground-values*) &gt; . Funcon initialise-index : =&gt;null-type Rule &lt; initialise-index, value-index(_) &gt; ---&gt; &lt; null-value, value-index( ) &gt; . Funcon allocate-index(_:ground-values) : =&gt;natural-numbers Rule &lt; allocate-index(V:ground-values), value-index(V*) &gt; ---&gt; &lt; length(V*, V), value-index(V*, V) &gt; . Funcon lookup-index(_:natural-numbers) : =&gt;ground-values Rule &lt; lookup-index(N:natural-numbers), value-index(V*) &gt; ---&gt; &lt; index(N, V*), value-index(V*) &gt; Assert lookup-index(allocate-index(V:ground-values)) ---&gt; V . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/Indexing/index.html#value-indexing",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/Indexing/index.html#value-indexing"
  },"493": {
    "doc": "Indexing",
    "title": "Indexing",
    "content": "Unstable-Funcons-beta : Indexing.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/Indexing/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/Indexing/index.html"
  },"494": {
    "doc": "Memos",
    "title": "Memos",
    "content": "[ Entity memo-map Funcon initialise-memos Funcon memo-value Funcon initialise-memo-value Funcon memo-value-recall ] . A memo is like a mutable variable, except that the memo is updated and accessed by a specified key, rather than by an allocated location. The collection of memos is represented by a mutable entity that maps keys to values. Entity &lt; _ , memo-map(_:maps(ground-values, values)) &gt; ---&gt; &lt; _ , memo-map(_:maps(ground-values, values)) &gt; . Funcon initialise-memos(_:=&gt;values) : =&gt;values Rule &lt; initialise-memos(X) , memo-map(_) &gt; ---&gt; &lt; X , memo-map(map( )) &gt; . When key K is associated with value V, the funcon memo-value(K, X) simply gives V, without evaluating X. When K is not currently associated with any value, it associates K with the value computed by X. Funcon memo-value(K:ground-values, X:=&gt;values) : =&gt;values ~&gt; else(memo-value-recall(K), give(X, sequential( else(initialise-memo-value(K, given), null-value), memo-value-recall(K)))) . The initialisation could fail due to memoisation of a (potentially different) value for K during the computation X. In that case, the value computed by X is simply discarded; a resource-safe funcon would take an extra argument to roll back the effects of X. Funcon initialise-memo-value(_:ground-values, _:values) : =&gt;null-type Rule map-unite(M, {K |-&gt; V}) ~&gt; M&prime; ----------------------------------------------------------------- &lt; initialise-memo-value(K:ground-values, V:values), memo-map(M) &gt; ---&gt; &lt; null-value , memo-map(M&prime;) &gt; Rule map-unite(M, {K |-&gt; V}) ~&gt; ( ) ----------------------------------------------------------------- &lt; initialise-memo-value(K:ground-values, V:values), memo-map(M) &gt; ---&gt; &lt; fail , memo-map(M) &gt; . Funcon memo-value-recall(_:ground-values) : =&gt;values Rule lookup(M, K) ~&gt; V ---------------------------------------------------------------------------- &lt; memo-value-recall(K:ground-values), memo-map(M) &gt; ---&gt; &lt; V , memo-map(M) &gt; Rule lookup(M, K) ~&gt; ( ) ------------------------------------------------------------------------------- &lt; memo-value-recall(K:ground-values), memo-map(M) &gt; ---&gt; &lt; fail , memo-map(M) &gt; . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/Memos/index.html#memos",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/Memos/index.html#memos"
  },"495": {
    "doc": "Memos",
    "title": "Memos",
    "content": "Unstable-Funcons-beta : Memos.cbs | PRETTY | PDF . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/Memos/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/Memos/index.html"
  },"496": {
    "doc": "Normal",
    "title": "Normal computation",
    "content": "These unstable funcons are potentially of general use, but are first defined for use in connection with languages that include threads. | Indexing: allocating indexes for values | Memos: associating keys with fixed values | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/index.html#normal-computation"
  },"497": {
    "doc": "Normal",
    "title": "Normal",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Normal/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Normal/index.html"
  },"498": {
    "doc": "Multithreading",
    "title": "Multithreading",
    "content": "[ Datatype thread-ids Datatype threads Funcon thread-joinable Funcon thread-detached ] . Initialisation . [ Funcon initialise-multithreading ] . Activation . [ Funcon multithread Funcon thread-activate Funcon thread-detach ] . Execution . [ Funcon current-thread Funcon thread-atomic Funcon thread-yield Funcon thread-spin Funcon thread-suspend Funcon thread-resume ] . Termination . [ Funcon thread-terminate Funcon is-thread-terminated Funcon thread-value Funcon thread-join Funcon thread-exterminate ] . Scheduling . [ Funcon update-thread-stepping Funcon update-thread-schedule Funcon current-thread-schedule Funcon is-thread-preemptible Funcon thread-preemptible Funcon thread-cooperative ] . A thread consists of code that can be executed concurrently with code of other threads. The progress of the execution of the threads may be determined cooperatively by threads themselves, or by a preemptive scheduler (or by both). Threads can be activated by the initial program or by other threads, and share access to the same entities (in contrast to processes). Synchronisation between threads can avoid interference (e.g., data races) arising from concurrent shared access. Synchronisation can also ensure sequential consistency of threads, where any concurrent execution corresponds to some (possibly unfair) interleaving of their separate execution steps. Synchronisation can be achieved by various kinds of locks and notifications. A thread is a value containing a thunk. When a thread has been activated, execution of the body of the thunk can be interleaved with that of other activated threads, possibly subject to scheduling and synchronisation. Activation of a thread generates a fresh thread-id for referring to it: . Auxiliary Datatype thread-ids ::= thread-id(_:atoms) . A thread is called joinable when other threads can wait for its termination. A joinable thread contains a list of the threads that are currently waiting to join it. A non-joinable thread is called detached: . Auxiliary Datatype threads ::= thread(_:thunks(values), _:(lists thread-ids)?) . Funcon thread-joinable(TH:thunks(values)) : =&gt; threads ~&gt; thread(TH, [ ]) . Funcon thread-detached(TH:thunks(values)) : =&gt; threads ~&gt; thread(TH) . In names of funcons and entities, and in informal explanations, a reference to a ‘thread’ generally concerns a thread-id, rather than a value of type threads. The only funcons that compute threads are thread-joinable(TH) and thread-detached(TH); thread-activate(THR) is the only funcon that takes an argument of type threads. The thunk contained in a thread can be formed directly from a computation X by thunk closure X. Alternatively, supply(F, V) forms a thunk by supplying an argument value V to a function F without executing F (in contrast to apply(F, V), which forces the evaluation of the body of F). The current state of a thread is either active, suspended, terminated, or deleted. | Activation makes a thread active. | An active thread can be suspended, and subsequently resumed. | An active or suspended thread can be terminated. | A thread can be deleted. | . The following mutable entities represent the states of all activated threads. Entities . The thread-map contains all active and suspended threads: . Entity &lt; _ , thread-map(_:maps(thread-ids, threads)) &gt; ---&gt; &lt; _ , thread-map(_:maps(thread-ids, threads)) &gt; . The active-thread-set distinguishes between active and suspended threads: . Entity &lt; _ , active-thread-set(_:sets(thread-ids)) &gt; ---&gt; &lt; _ , active-thread-set(_:sets(thread-ids)) &gt; . Funcon is-some-thread-active : =&gt;booleans Rule &lt; is-some-thread-active, active-thread-set(ATS) &gt; ---&gt; not is-equal(ATS, {}) . Funcon is-some-thread-suspended : =&gt;booleans Rule &lt; is-some-thread-suspended, active-thread-set(ATS), thread-map(TM) &gt; ---&gt; not is-equal(ATS, dom TM) . The thread-stepping entity identifies the thread whose step is currently being executed. When defined, it identifies an active thread: . Entity &lt; _ , thread-stepping(_:thread-ids?) &gt; ---&gt; &lt; _ , thread-stepping(_:thread-ids?) &gt; . The terminated-thread-map contains the values computed by terminated joinable threads: . Entity &lt; _ , terminated-thread-map(_:maps(thread-ids, values)) &gt; ---&gt; &lt; _ , terminated-thread-map(_:maps(thread-ids, values)) &gt; . Deleted threads are not contained in any of the above entities. Terminated detached threads are always deleted. Scheduling information for each thread may affect the interleaving of thread steps: . Entity // thread-scheduling &lt; _ , thread-schedule(_:sets(ground-values)) &gt; ---&gt; &lt; _ , thread-schedule(_:sets(ground-values)) &gt; . Scheduling can change dynamically between preemptive and cooperative. Initialisation . The entities used to model multithreading need initialising: . Funcon initialise-multithreading : =&gt;null-type ~&gt; sequential( initialise-thread-map, initialise-active-thread-set, initialise-thread-stepping, initialise-terminated-thread-map, initialise-thread-schedule) . The initial values are generally quite obvious: . Auxiliary Funcon initialise-thread-map : =&gt;null-type . Rule initialise-thread-map ---&gt; &lt; null-value, thread-map(map()) &gt; . Auxiliary Funcon initialise-active-thread-set : =&gt;null-type . Rule initialise-active-thread-set ---&gt; &lt; null-value, active-thread-set{ } &gt; . Auxiliary Funcon initialise-thread-stepping : =&gt;null-type . Rule initialise-thread-stepping ---&gt; &lt; null-value, thread-stepping( ) &gt; . Auxiliary Funcon initialise-terminated-thread-map : =&gt;null-type . Rule initialise-terminated-thread-map ---&gt; &lt; null-value, terminated-thread-map(map()) &gt; . Auxiliary Funcon initialise-thread-schedule : =&gt;null-type . Rule initialise-thread-schedule ---&gt; &lt; null-value, thread-schedule{ } &gt; . Activation . Multithreading can start by activating a single thread, which can then activate further threads: . Funcon multithread(_:=&gt;values) : =&gt;values . multithread X forms a joinable thread from thunk closure X and activates it. On normal termination of all threads, it gives the value computed by X. On abrupt termination (caused by a thread step, or by the failure of the check that all threads have terminated) the reason for it: . Rule multithread X ~&gt; sequential( initialise-multithreading, give( thread-activate thread-joinable thunk closure X, // gives TI handle-abrupt( sequential( while-true(is-some-thread-active, sequential(update-thread-stepping, thread-step)), check not is-some-thread-suspended, // deadlock thread-value given), // given is TI given) // given is the reason for abruption )) . The update-thread-stepping funcon determines the thread-id for the next step, which may depend on whether the previous step has yielded, on its preemptibility, and on the current scheduling. A thread can activate the execution of thread-activates: . Funcon thread-activate(_:threads) : =&gt;thread-ids . When a thread is activated, a fresh thread-id is generated, and the thread is included in the thread-map and the active-thread-set: . Rule thread-id(fresh-atom) ---&gt; TI map-unite({TI |-&gt; THR}, TM) ~&gt; TM&prime; set-unite({TI}, ATS) ~&gt; ATS&prime; ------------------------------------------------------------------------ &lt; thread-activate(THR:threads), thread-map(TM), active-thread-set(ATS) &gt; ---&gt; &lt; TI, thread-map(TM&prime;), active-thread-set(ATS&prime;) &gt; . A joinable thread can be detached after its activation, discarding its list of joining threads: . Funcon thread-detach(_:thread-ids) : =&gt;null-type . When the thread has not yet terminated, it remains in the thread-map: . Rule map-lookup(TM, TI) ~&gt; thread(TH, _) map-override({TI |-&gt; thread(TH)}, TM) ~&gt; TM&prime; ------------------------------------------------ &lt; thread-detach(TI:thread-ids), thread-map(TM) &gt; ---&gt; &lt; null-value, thread-map(TM&prime;) &gt; . When the thread has already terminated, detaching it deletes it from the terminated-thread-map: . Rule is-in-set(TI, dom TMV) == (true) map-delete(TMV, {TI}) ~&gt; TMV&prime; ------------------------------------------------------------ &lt; thread-detach(TI:thread-ids), terminated-thread-map(TMV) &gt; ---&gt; &lt; null-value, terminated-thread-map(TMV&prime;) &gt; . (A funcon for making a detached thread joinable could be defined similarly.) . Execution . The thread-stepping is undefined only before multithreading starts, and when all non-terminated threads are suspended. Funcon current-thread : =&gt;thread-ids Rule &lt; current-thread, thread-stepping(TI) &gt; ---&gt; TI . current-thread is only intended for use in threads: . Rule &lt; current-thread, thread-stepping( ) &gt; ---&gt; fail . Stepping . The funcon thread-step executes a single step of the thread identified by thread-stepping: . Auxiliary Funcon thread-step : =&gt;null-type . Whenever THR executes a step and THR&prime; represents the remaining steps, the thread-map is updated to map TI to THR&prime;. If the body of the thread can make a step, so can thread-step: . Rule lookup(TM, TI) ~&gt; thread(thunk abstraction(X), L?) &lt; X, thread-stepping(TI), thread-map(TM) &gt; ---&gt; &lt; X&prime;, thread-stepping(TI?), thread-map(TM&prime;) &gt; if-true-else( is-in-set(TI, dom TM&prime;), map-override({TI |-&gt; thread(thunk abstraction(X&prime;), L?)}, TM&prime;), TM&prime;) ~&gt; TM&prime;&prime; ---------------------------------------------------------------- &lt; thread-step, thread-stepping(TI), thread-map(TM) &gt; ---&gt; &lt; null-value, thread-stepping(TI?), thread-map(TM&prime;&prime;) &gt; . The only other case for a next step is when a thread has terminated normally, and is to be removed from the executing thread map. If it is detached, its computed value is discarded: . Rule lookup(TM, TI) ~&gt; thread(thunk abstraction(X)) X ~&gt; (V:values) map-delete(TM, {TI}) ~&gt; TM&prime; set-difference(ATS, {TI}) ~&gt; ATS&prime; ---------------------------------------------------------------------------- &lt; thread-step, active-thread-set(ATS), thread-stepping(TI), thread-map(TM) &gt; ---&gt; &lt; null-value, active-thread-set(ATS&prime;), thread-stepping( ), thread-map(TM&prime;) &gt; . If the thread is joinable, all its joining threads are resumed, and its computed value is made available in the terminated-thread-map: . Rule lookup(TM, TI) ~&gt; thread(thunk abstraction(X), [TI*]) X ~&gt; (V:values) map-delete(TM, {TI}) ~&gt; TM&prime; set-unite(set-difference(ATS, {TI}), {TI*}) ~&gt; ATS&prime; map-unite(TVM, {TI |-&gt; V}) ~&gt; TVM&prime; ----------------------------------------------------------- &lt; thread-step, active-thread-set(ATS), thread-stepping(TI), thread-map(TM), terminated-thread-map(TVM) &gt; ---&gt; &lt; null-value, active-thread-set(ATS&prime;), thread-stepping( ), thread-map(TM&prime;), terminated-thread-map(TVM&prime;) &gt; . Sync atomicity . thread-atomic(X) computes X in a single transition. Assuming that the potentially interfering effects of X may only be updates on the store, thread suspension and/or resumption, and abrupt termination, and that X always terminates, the outcome of thread-atomic(X) is the same as that of computing X without preemption. (The funcon atomic(X) generalises thread-atomic(X) to allow X with arbitrary effects. When the CBS notation “—&gt;1 ; —&gt;2” for composing transitions has been implemented by the interpreter generation tools, uses of thread-atomic(X) are to be replaced by atomic(X).) . Auxiliary Funcon thread-atomic(_:=&gt;values) : =&gt;values . Rule &lt; X, store(Sigma), active-thread-set(ATS), thread-stepping(TI) &gt; --abrupted( )-&gt; &lt; X&prime;, store(Sigma&prime;), active-thread-set(ATS&prime;), thread-stepping(TI&prime;) &gt; &lt; thread-atomic(X&prime;), store(Sigma&prime;), active-thread-set(ATS&prime;), thread-stepping(TI&prime;) &gt; --abrupted( )-&gt; &lt; V, store(Sigma&prime;&prime;), active-thread-set(ATS&prime;&prime;), thread-stepping(TI&prime;&prime;?) &gt; --------------------------------------------------------------------------------- &lt; thread-atomic(X), store(Sigma), active-thread-set(ATS), thread-stepping(TI) &gt; --abrupted( )-&gt; &lt; V, store(Sigma&prime;&prime;), active-thread-set(ATS&prime;&prime;), thread-stepping(TI&prime;&prime;?) &gt; Rule &lt; X, store(Sigma), active-thread-set(ATS), thread-stepping(TI) &gt; --abrupted( )-&gt; &lt; X&prime;, store(Sigma&prime;), active-thread-set(ATS&prime;), thread-stepping(TI&prime;) &gt; &lt; thread-atomic(X&prime;), store(Sigma&prime;), active-thread-set(ATS&prime;), thread-stepping(TI&prime;) &gt; --abrupted(A)-&gt; &lt; V, store(Sigma&prime;&prime;), active-thread-set(ATS&prime;&prime;), thread-stepping(TI&prime;&prime;?) &gt; --------------------------------------------------------------------------------- &lt; thread-atomic(X), store(Sigma), active-thread-set(ATS), thread-stepping(TI) &gt; --abrupted(A)-&gt; &lt; V, store(Sigma&prime;&prime;), active-thread-set(ATS&prime;&prime;), thread-stepping(TI&prime;&prime;?) &gt; Rule X --abrupted(A)-&gt; X&prime; ---------------------------------------------- thread-atomic(X) --abrupted(A)-&gt; thread-atomic(X&prime;) Rule X --abrupted( )-&gt; (V:values) -------------------------------- thread-atomic(X) --abrupted( )-&gt; V Rule X --abrupted(A)-&gt; (V:values) --------------------------------------------- thread-atomic(X) --abrupted(A)-&gt; thread-atomic(V) Rule thread-atomic(V:values) ---&gt; V . Note that if the execution of thread-atomic(X) involves thread-yield( ) or thread-suspend( ), this makes thread-stepping undefined, so it has to be the final step of X. Yielding . A thread can yield execution: . Funcon thread-yield(_:thread-ids?) : =&gt;null-type . When the argument thread-id is omitted, the next thread to be executed is left undefined, to be determined by the scheduler: . Rule thread-yield( ) ---&gt; &lt; null-value, thread-stepping( ) &gt; . When the argument thread-id is TI, it has to be an active thread: . Rule is-in-set(TI, ATS) == (true) ------------------------------------------------------- &lt; thread-yield(TI:thread-ids), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI) &gt; Rule is-in-set(TI, ATS) == (false) ------------------------------------------------------- &lt; thread-yield(TI:thread-ids), active-thread-set(ATS) &gt; ---&gt; fail . thread-spin(X) repeatedly executes X while it fails, allowing interleaving with other threads. Funcon thread-spin(X:=&gt;values) : =&gt;values ~&gt; else(X, sequential(thread-yield( ), thread-spin(X))) . Suspension and resumption . A thread may suspend one or more threads that are currently being executed: . Funcon thread-suspend(_:thread-ids+) : =&gt;null-type Rule is-in-set(TI, {TI+}) == (false) is-subset({TI+}, ATS) == (true) set-difference(ATS, {TI+}) ~&gt; ATS&prime; -------------------------------------------------------------------------------- &lt; thread-suspend(TI+:thread-ids+), thread-stepping(TI), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI), active-thread-set(ATS&prime;) &gt; . If TI+ includes the current thread, suspension is accompanied by yielding: . Rule is-in-set(TI, {TI+}) == (true) is-subset({TI+}, ATS) == (true) set-difference(ATS, {TI+}) ~&gt; ATS&prime; -------------------------------------------------------------------------------- &lt; thread-suspend(TI+:thread-ids+), thread-stepping(TI), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping( ), active-thread-set(ATS&prime;) &gt; . (Deadlock occurs if the last non-suspended thread suspends itself.) . A thread may resume any number of suspended threads: . Funcon thread-resume(_:thread-ids*) : =&gt;null-type Rule is-in-set(TI, {TI*}) == (false) set-intersect(ATS, {TI*}) == { } set-unite(ATS, {TI*}) ~&gt; ATS&prime; ------------------------------------------------------------------------------- &lt; thread-resume(TI*:thread-ids*), thread-stepping(TI), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI), active-thread-set(ATS&prime;) &gt; . Termination . If the thread-map becomes empty, and there are no suspended threads, the entire multithread computation terminates normally. If it becomes empty while suspended threads remain to be executed, this is regarded as deadlock, and the computation fails. If the execution of an individual thread terminates normally, the body of its thunk gives its computed value. The thread is removed from the thread-map, and the computed value is added to the terminated-thread-map. Abrupt termination of a thread body causes immediate abrupt termination of the entire multithread computation. This can be avoided by wrapping the bodies of all threads in appropriate handlers for abrupt termination. A thread can terminate itself or another thread, optionally specifying its computed value: . Funcon thread-terminate(_:thread-ids, _:values?) : =&gt;null-type . When the thread is detached, no value is specified: . Rule lookup(TM, TI&prime;) ~&gt; thread(thunk abstraction X) map-delete(TM, {TI&prime;}) ~&gt; TM&prime; set-difference(ATS, {TI&prime;}) ~&gt; ATS&prime; when-true(not is-equal(TI, TI&prime;), TI) ~&gt; TI? -------------------------------------------------------- &lt; thread-terminate(TI&prime;:thread-ids), thread-stepping(TI), thread-map(TM), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI?), thread-map(TM&prime;), active-thread-set(ATS&prime;) &gt; . When the thread is joinable, its value has to be specified: . Rule lookup(TM, TI&prime;) ~&gt; thread((thunk abstraction X), [TI*]) map-delete(TM, {TI&prime;}) ~&gt; TM&prime; set-unite(set-difference(ATS, {TI&prime;}), {TI*}) ~&gt; ATS&prime; map-unite(TVM, {TI&prime; |-&gt; V}) ~&gt; TVM&prime; when-true(not is-equal(TI, TI&prime;), TI) ~&gt; TI? ---------------------------------------------------------------------------- &lt; thread-terminate(TI&prime;:thread-ids, V:values), thread-stepping(TI), thread-map(TM), terminated-thread-map(TVM), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI?), thread-map(TM&prime;), terminated-thread-map(TVM&prime;), active-thread-set(ATS&prime;) &gt; . A thread can test whether a joinable thread has terminated: . Funcon is-thread-terminated(_:thread-ids) : =&gt;booleans Rule &lt; is-thread-terminated(TI:thread-ids), terminated-thread-map(TVM) &gt; ---&gt; is-value(map-lookup(TVM, TI)) . If so, it can get the computed value: . Funcon thread-value(_:thread-ids) : =&gt;values Rule &lt; thread-value(TI:thread-ids), terminated-thread-map(TVM) &gt; ---&gt; checked map-lookup(TVM, TI) . Joining a thread may cause suspension: . Funcon thread-join(_:thread-ids) : =&gt;null-type Rule lookup(TM, TI&prime;) ~&gt; thread(TH, [TI*]) map-override({TI&prime; |-&gt; thread(TH, [TI*, TI])}, TM) ~&gt; TM&prime; set-difference(ATS, {TI}) ~&gt; ATS&prime; ------------------------------------------------------------------- &lt; thread-join(TI&prime;:thread-ids), thread-map(TM), thread-stepping(TI), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-map(TM&prime;), thread-stepping( ), active-thread-set(ATS&prime;) &gt; . If a joinable thread has already terminated, the terminated-thread-map holds its value: . Rule is-value(lookup(TVM, TI&prime;)) == true ----------------------------------------------------------- &lt; thread-join(TI&prime;:thread-ids), terminated-thread-map(TVM) &gt; ---&gt; null-value . Trying to join a detached thread fails: . Rule lookup(TM, TI&prime;) ~&gt; thread(TH) ----------------------------------------------- &lt; thread-join(TI&prime;:thread-ids), thread-map(TM) &gt; ---&gt; fail Rule lookup(TM, TI&prime;) == ( ) lookup(TVM, TI&prime;) == ( ) --------------------------------------------------------------------------- &lt; thread-join(TI&prime;:thread-ids), thread-map(TM), terminated-thread-map(TVM) &gt; ---&gt; fail . Extermination of a thread both terminates it and prevents its subsequent inspection. Funcon thread-exterminate(_:thread-ids) : =&gt;null-type Rule TI&prime; =/= TI map-delete(TM, {TI&prime;}) ~&gt; TM&prime; map-delete(TVM, {TI&prime;}) ~&gt; TVM&prime; set-difference(ATS, {TI&prime;}) ~&gt; ATS&prime; -------------------------------------------------------------------------- &lt; thread-exterminate(TI&prime;:thread-ids), thread-map(TM), thread-stepping(TI), terminated-thread-map(TVM), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-map(TM&prime;), thread-stepping(TI), terminated-thread-map(TVM&prime;), active-thread-set(ATS&prime;) &gt; . Scheduling . A scheduler determines the interleaving of thread execution, based on mutable information regarding features such as preemptibility, priority, and time-sharing. The next thread scheduled for execution is an active thread, or undefined when there are no active threads. It may be the same thread that last made a step. (The following definitions allow update-thread-stepping to update thread-stepping to any valid thread. They are to be replaced by declarations of built-in funcons, allowing exploration of different interleavings using oracles.) . Funcon update-thread-stepping : =&gt;null-type . When thread-stepping is TI and that thread is not preemptible, update-thread-stepping has no effect: . Rule is-thread-preemptible(TI) ---&gt; false --------------------------------------------------------------- &lt; update-thread-stepping, thread-stepping(TI) &gt; ---&gt; null-value . When thread-stepping is TI and that thread is preemptible, or when thread-stepping is undefined, update-thread-stepping may set it to any active TI&prime;: . Rule is-thread-preemptible(TI) ---&gt; (true) some-element(ATS) ~&gt; TI&prime; ----------------------------------------------------------------------- &lt; update-thread-stepping, thread-stepping(TI), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI&prime;) &gt; Rule some-element(ATS) ~&gt; TI&prime; ---------------------------------------------------------------------- &lt; update-thread-stepping, thread-stepping( ), active-thread-set(ATS) &gt; ---&gt; &lt; null-value, thread-stepping(TI&prime;) &gt; . When there are no active threads, update-thread-stepping ensures that thread-stepping is undefined: . Rule &lt; update-thread-stepping, thread-stepping(TI?), active-thread-set{ } &gt; ---&gt; &lt; null-value, thread-stepping( ) &gt; . Scheduling information for each thread can be inspected and updated: . Funcon update-thread-schedule(_:sets(ground-values)) : =&gt;null-type Rule update-thread-schedule(VS:sets(ground-values)) ---&gt; &lt; null-value, thread-schedule(VS) &gt; . Funcon current-thread-schedule : =&gt;sets(ground-values) Rule &lt; current-thread-schedule, thread-schedule(VS) &gt; ---&gt; VS . Datatype thread-preemtibilities ::= thread-preemptible | thread-cooperative . Funcon is-thread-preemptible(_:thread-ids) : =&gt;booleans ~&gt; not is-in-set(thread-cooperative, current-thread-schedule) . For now, all threads are preemptible unless the scheduling includes cooperative. The representation of scheduling information is left open here, together with the details of how it affects the result of update-thread-stepping. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Multithreading/index.html#multithreading",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Multithreading/index.html#multithreading"
  },"499": {
    "doc": "Multithreading",
    "title": "Multithreading",
    "content": "Unstable-Funcons-beta : Multithreading.cbs | PRETTY | PDF . Outline . | Multithreading . | Initialisation | Activation | Execution | Termination | Scheduling | Entities | Initialisation | Activation | Execution . | Stepping | Sync atomicity | Yielding | Suspension and resumption | . | Termination | Scheduling | . | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Multithreading/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Multithreading/index.html"
  },"500": {
    "doc": "Locks",
    "title": "Locks",
    "content": "Unstable-Funcons-beta : Locks.cbs | PRETTY | PDF . Outline . | Locks . | Spin locks | Exclusive locks | Rentrant locks | Semaphores | Shared-exclusive locks | . | . Locks . [ Funcon is-exclusive-lock-holder ##### Spin locks Funcon spin-lock-create Funcon spin-lock-sync Funcon spin-lock-release ##### Exclusive locks Funcon exclusive-lock-create Funcon exclusive-lock-sync Funcon exclusive-lock-sync-else-wait Funcon exclusive-lock-release ##### Reentrant locks Funcon reentrant-lock-create Funcon reentrant-lock-sync Funcon reentrant-lock-sync-else-wait Funcon reentrant-lock-release Funcon reentrant-lock-exit ##### Semaphores Funcon semaphore-create Funcon semaphore-sync Funcon semaphore-sync-else-wait Funcon semaphore-release ##### Shared-exclusive locks Funcon rw-lock-create Funcon rw-lock-sync-exclusive Funcon rw-lock-sync-shared Funcon rw-lock-sync-exclusive-else-wait Funcon rw-lock-sync-shared-else-wait Funcon rw-lock-release-exclusive Funcon rw-lock-release-shared ] . A thread may request locks, and release locks (held by itself or by another thread). A reentrant lock may be held more than once by the same thread. A shared lock may be held by multiple threads at the same time, whereas an exclusive lock can be held by only one thread at the same time. A request for a spinlock that is held by another thread involves busy waiting instead of suspension, and assumes interleaving of the execution of a waiting thread and the holding thread. Funcon is-exclusive-lock-holder(SY:syncs) : =&gt;booleans ~&gt; is-equal(current-thread, assigned sync-feature(SY, sync-holder)) . Spin locks . Spin locks support mutual exclusion, but not suspension of blocked requests. thread-spin spin-lock-sync SY repeatedly executes the request for the lock until the request is granted, which is called busy waiting. Interleaving of different threads waiting for the same spin lock may result in granting requests out of order. Funcon spin-lock-create : =&gt;syncs ~&gt; sync-create( sync-feature-create sync-held, sync-feature-create sync-holder) . When the lock is not currently held, granting a request for it sets the holder to the current thread; otherwise the request fails. Funcon spin-lock-sync(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true not(assigned sync-feature(SY, sync-held)), assign(sync-feature(SY, sync-held), true), assign(sync-feature(SY, sync-holder), current-thread)) . Releasing the lock leaves the lock free. Only the thread that holds the lock can release it. Releasing cannot be blocked by other threads, so it is not a request. Funcon spin-lock-release(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true is-exclusive-lock-holder(SY), assign(sync-feature(SY, sync-held), false), un-assign(sync-feature(SY, sync-holder))) . Exclusive locks . Exclusive locks support mutual exclusion and suspension of blocked requests. An exclusive lock – also called a mutex – can be held by only one thread at the same time. It can be used to ensure mutual exclusion of so-called critical regions of thread bodies, and to avoid potential interference due to thread interleaving. Funcon exclusive-lock-create : =&gt;syncs ~&gt; sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-held, sync-feature-create sync-holder) . When the lock is not currently held, granting a request for it sets the holder to the current thread; otherwise the request fails. Funcon exclusive-lock-sync(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true not(assigned sync-feature(SY, sync-held)), assign(sync-feature(SY, sync-held), true), assign(sync-feature(SY, sync-holder), current-thread)) . When the request fails, the current thread is added to the waiting list, and suspended until the request can be granted: . Funcon exclusive-lock-sync-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( exclusive-lock-sync(SY), sequential( sync-waiting-list-add(SY, current-thread), thread-suspend current-thread)) . When the waiting list is non-empty, releasing the lock grants it to the thread that made the first request in the list, and resumes that thread; otherwise it leaves the lock free. Only the thread that holds the lock can release it. Releasing a lock cannot be blocked by other threads, so it is not a request. Funcon exclusive-lock-release(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true is-exclusive-lock-holder(SY), if-true-else(is-equal(assigned sync-feature(SY, sync-waiting-list), [ ]), sequential( assign(sync-feature(SY, sync-held), false), un-assign(sync-feature(SY, sync-holder))), give(sync-waiting-list-head-remove(SY), sequential( assign(sync-feature(SY, sync-holder), given), thread-resume given)))) . Rentrant locks . Reentrant exclusive locks support mutual exclusion, suspension of blocked requests, and reentry. A reentrant exclusive lock can be held (and subsequently released) multiple times by the same thread. Funcon reentrant-lock-create : =&gt;syncs ~&gt; sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-held, sync-feature-create sync-holder, sync-feature-create sync-count) . When the lock is not currently held, granting a request for it sets the holder to the current thread; if it is already held by the current thread, it merely increments the counter; otherwise the request fails. Funcon reentrant-lock-sync(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( sequential( check-true not(assigned sync-feature(SY, sync-held)), assign(sync-feature(SY, sync-held), true), assign(sync-feature(SY, sync-holder), current-thread), assign(sync-feature(SY, sync-count), 0)), sequential( check-true assigned sync-feature(SY, sync-held), check-true is-exclusive-lock-holder(SY), assign(sync-feature(SY, sync-count), nat-succ assigned sync-feature(SY, sync-count)))) . When the request fails, the current thread is added to the waiting list, and suspended until the request can be granted: . Funcon reentrant-lock-sync-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( reentrant-lock-sync(SY), sequential( sync-waiting-list-add(SY, current-thread), thread-suspend current-thread)) . When the waiting list is non-empty, releasing the lock grants it to the thread that made the first request in the list, and resumes that thread; otherwise it leaves the lock free. Only the thread that holds the lock can release it. Releasing a lock cannot be blocked by other threads, so it is not a request. Funcon reentrant-lock-release(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true is-exclusive-lock-holder(SY), if-true-else(is-equal(assigned sync-feature(SY, sync-waiting-list), [ ]), sequential( assign(sync-feature(SY, sync-held), false), un-assign(sync-feature(SY, sync-holder)), assign(sync-feature(SY, sync-count), 0)), give(sync-waiting-list-head-remove(SY), sequential( assign(sync-feature(SY, sync-holder), given), assign(sync-feature(SY, sync-count), 0), thread-resume given)))) . When the reentered count is positive, an exit merely decrements it. Otherwise it is 0, and the exit releases the lock. Funcon reentrant-lock-exit(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true is-exclusive-lock-holder(SY), give(sync-feature(SY, sync-count), if-true-else(is-greater(assigned given, 0), assign(given, checked nat-pred assigned given), reentrant-lock-release(SY)))) . Semaphores . A semaphore is a shared lock with a specified limit on the number of threads that can hold it at the same time. A semaphore can be released by any thread. Funcon semaphore-create(N:pos-ints) : =&gt;syncs ~&gt; give( sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-count), sequential( assign(sync-feature(given, sync-count), N), given)) . When the semaphore is available, granting a request for it decrements the number of further threads that can hold it; otherwise the request fails. Funcon semaphore-sync(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true is-greater(assigned sync-feature(SY, sync-count), 0), assign(sync-feature(SY, sync-count), checked nat-pred assigned sync-feature(SY, sync-count))) . When the request fails, the current thread is added to the waiting list, and suspended until the request can be granted: . Funcon semaphore-sync-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( semaphore-sync(SY), sequential( sync-waiting-list-add(SY, current-thread), thread-suspend current-thread)) . When the waiting list is empty, releasing the semaphore increments the counter; otherwise it grants the semaphore to the thread that made the first request in the list, and resumes that thread. Releasing a semaphore cannot be blocked, so it is not a request. Funcon semaphore-release(SY:syncs) : =&gt;null-type ~&gt; thread-atomic if-true-else(is-equal(assigned sync-feature(SY, sync-waiting-list), [ ]), assign(sync-feature(SY, sync-count), nat-succ assigned sync-feature(SY, sync-count)), give(sync-waiting-list-head-remove(SY), thread-resume given)) . Shared-exclusive locks . A shared-exclusive lock – also called a readers-writer (rw) lock – can be held exclusively by a single thread, or shared by any number of threads at the same time. It can be released by any thread. Funcon rw-lock-create : =&gt;syncs ~&gt; give( sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-held, sync-feature-create sync-count), sequential( assign(sync-feature(given, sync-count), 0), given)) . When the lock is not currently held at all, it can be granted exclusively: . Funcon rw-lock-sync-exclusive(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true and( not(assigned sync-feature(SY, sync-held)), is-equal(assigned sync-feature(SY, sync-count), 0)), assign(sync-feature(SY, sync-held), true)) . When the lock is not currently held exclusively, a request to share it is always granted immediately (regardless of any waiting exclusive requests): . Funcon rw-lock-sync-shared(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true not(assigned sync-feature(SY, sync-held)), assign(sync-feature(SY, sync-count), nat-succ assigned sync-feature(SY, sync-count))) . If the request fails, the current thread is added to the waiting list, and suspended until the request can be granted. The waiting list of a shared-exclusive lock records not only the thread but also whether the request is for sharing: . Funcon rw-lock-sync-exclusive-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( rw-lock-sync-exclusive(SY), sequential( sync-waiting-list-add(SY, tuple(current-thread, false)), thread-suspend current-thread)) . Funcon rw-lock-sync-shared-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( rw-lock-sync-shared(SY), sequential( sync-waiting-list-add(SY, tuple(current-thread, true)), thread-suspend current-thread)) . When the waiting list is non-empty, releasing the lock may grant either the first waiting exclusive request, or all waiting shared requests. A scheduler may defer granting one kind of request when there are waiting requests of the other kind, irrespective of the order in which those requests were made. Releasing a lock cannot be blocked by other threads, so it is not a request. Funcon rw-lock-release-exclusive(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( check-true assigned sync-feature(SY, sync-held), assign(sync-feature(SY, sync-held), false), rw-lock-sync(SY)) . Funcon rw-lock-release-shared(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( assign(sync-feature(SY, sync-count), checked nat-pred assigned sync-feature(SY, sync-count)), if-true-else(is-equal(0, assigned sync-feature(SY, sync-count)), rw-lock-sync(SY), null-value)) . rw-lock-sync(SY) assumes that SY is not held (either exclusively or shared). If the first waiting request is for sharing, any further sharing requests are granted, . Auxiliary Funcon rw-lock-sync(SY:syncs) : =&gt;null-type ~&gt; if-true-else(is-equal(assigned sync-feature(SY, sync-waiting-list), [ ]), null-value, give(sync-waiting-list-head-remove(SY), sequential( thread-resume first tuple-elements given, if-true-else(second tuple-elements given, sequential( assign(sync-feature(SY, sync-count), nat-succ assigned sync-feature(SY, sync-count)), rw-lock-sync-all-shared(SY)), assign(sync-feature(SY, sync-held), true))))) . rw-lock-sync-all-shared(SY) updates the waiting list by removing and resuming all its sharing requests: . Auxiliary Funcon rw-lock-sync-all-shared(SY:syncs) : =&gt;null-value ~&gt; assign(sync-feature(SY, sync-waiting-list), [ left-to-right-filter( if-true-else(second tuple-elements given, sequential( thread-resume first tuple-elements given, assign(sync-feature(SY, sync-count), nat-succ assigned sync-feature(SY, sync-count)), false), true), list-elements assigned sync-feature(SY, sync-waiting-list)) ]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/Locks/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/Locks/index.html"
  },"501": {
    "doc": "Notifications",
    "title": "Notifications",
    "content": "Unstable-Funcons-beta : Notifications.cbs | PRETTY | PDF . Outline . | Notifications . | Barriers | Conditions | Rendezvous | . | . Notifications . [ ##### Barriers Funcon barrier-create Funcon barrier-sync Funcon barrier-sync-else-wait ##### Conditions Funcon condition-create Funcon condition-wait Funcon condition-wait-with-lock Funcon condition-notify-all Funcon condition-notify-first ##### Rendezvous Funcon rendezvous-create Funcon rendezvous-sync Funcon rendezvous-sync-else-wait ] . Threads may synchronise by waiting for notifications. In contrast to locks, notifications are ephemeral, and do not get held and released. Barriers . A barrier notifies all requesting threads when a specified number of requests for it have been made. Subsequent requests give immediate notification. Funcon barrier-create(N:pos-ints) : =&gt;syncs ~&gt; give( sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-count), sequential( assign(sync-feature(given, sync-count), N), given)) . When the barrier is already open, requests to pass it are granted immediately. When the barrier is closed, and only one more thread needs to arrive, granting a request for it opens the barrier and resumes all the threads wiating for it; otherwise the request fails. Funcon barrier-sync(SY:syncs) : =&gt;null-type ~&gt; thread-atomic give(sync-feature(SY, sync-count), else( check-true is-equal(assigned given, 0), sequential( check-true is-equal(assigned given, 1), assign(given, 0), thread-resume list-elements assigned sync-feature(SY, sync-waiting-list), assign(sync-feature(SY, sync-waiting-list), [])))) . When the request fails, the current thread is added to the waiting list, and suspended until the request can be granted: . Funcon barrier-sync-else-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic else( barrier-sync(SY), sequential( sync-waiting-list-add(SY, current-thread), assign(sync-feature(SY, sync-count), checked nat-pred assigned sync-feature(SY, sync-count)), thread-suspend current-thread)) . Conditions . A condition is used to represent whether some property holds or not. Threads may request to be notified when another thread makes the property hold. A condition may notify either one or all of its requesting threads. When it has to notify one thread but more than one request for notification has been made, the choice of thread may be determined by the scheduler. When it has to notify more than one thread, the property associated with the condition may have been invalidated by the time the executions of some of them are resumed, and threads may need to iterate requests for notifications. In practice, a condition is generally associated with an exclusive lock. When a thread awaiting the condition is notified, it requests the exclusive lock and tests whether the required property holds; if it does not, the thread releases the exclusive lock, and atomically reverts to requesting the notification. Funcon condition-create : =&gt;syncs ~&gt; sync-create( sync-feature-create sync-waiting-list) . A condition request always adds the current thread to the waiting list, and suspends it until the request can be granted. (In practice, it takes also an associated exclusive lock as a further argument, assumed to be held by the current thread, and releases it at the same time as suspending the thread.) . Funcon condition-wait(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( sync-waiting-list-add(SY, current-thread), thread-suspend current-thread) . In practice, a condition request usually takes also an associated exclusive lock as a further argument, assumed to be held by the current thread, releases it together with suspending the thread, and waits for the lock when resumed: . Funcon condition-wait-with-lock(SY:syncs, L:syncs) : =&gt;null-type ~&gt; sequential( thread-atomic sequential( exclusive-lock-release(L), sync-waiting-list-add(SY, current-thread), thread-suspend current-thread), exclusive-lock-sync-else-wait(L)) . Threads that are waiting for the condition are notified simply by resuming them. To notify them all: . Funcon condition-notify-all(SY:syncs) : =&gt;null-type ~&gt; thread-atomic sequential( thread-resume list-elements assigned sync-feature(SY, sync-waiting-list), assign(sync-feature(SY, sync-waiting-list), [])) . To notify just one of the waiting threads: . Funcon condition-notify-first(SY:syncs) : =&gt;null-type ~&gt; thread-atomic give(sync-waiting-list-head-remove(SY), thread-resume given) . Rendezvous . A rendezvous notifies all requesting threads as soon as a specified number N of them have made matching requests for it. The rendezvous can store any number of non-matching requests. If a request that completes a rendezvous matches different sets of N-1 pending requests, the ‘lexicographically’ earliest set of requests is selected; for a binary rendezvous, this is the first matching request in the stored list. Funcon rendezvous-create(N:pos-ints) : =&gt;syncs ~&gt; give(sync-create( sync-feature-create sync-waiting-list, sync-feature-create sync-count), sequential( assign(sync-feature(given, sync-count), N), given)) . Each rendezvous request includes a pattern, and the corresponding notifications give environments obtained by matching the patterns against the same unified value. When the pattern in each request is simply a value, a rendezvous notifies all the requesting threads as soon as the specified number of requests with the same value have been made. When the pattern in one request is a value, a pattern in another request may bind an identifier to that value, giving one-way data flow. A rendezvous request may also include a set of additional threads which are all required to participate in the rendezvous. When a pair of matching binary rendezvous requests each specify the other thread as the only required participant, the rendezvous is restricted to that pair of threads. When one of the sets is empty, the rendezvous may involve any other thread. In this simplified version, rendezvous are always binary, patterns in requests are ground values, and sets of required threads are omitted. When a rendezvous is available, granting a request for it removes the first matching element from the waiting list, and resumes its thread; otherwise the request fails. Funcon rendezvous-sync(SY:syncs, V:ground-values) : =&gt;null-type ~&gt; give(assigned sync-feature(SY, sync-waiting-list), sequential( check-true is-rendezvous-match(given, V), assign(sync-feature(SY, sync-waiting-list), rendezvous-first-match-drop(given, V)), thread-resume rendezvous-first-match-thread(given, V))) . When the request fails, a tuple of the value and the current thread is added to the waiting list, and the thread suspended until the request can be granted: . Funcon rendezvous-sync-else-wait(SY:syncs, V:ground-values) : =&gt;null-type ~&gt; thread-atomic else( rendezvous-sync(SY, V), sequential( sync-waiting-list-add(SY, tuple(V, current-thread)), thread-suspend current-thread)) . The remaining rendezvous funcons are all auxiliary: . Auxiliary Type rendezvous-waits ~&gt; tuples(ground-values, thread-ids) . The funcon is-rendezvous-match(L, V) returns whether the list L contains tuple(V, TI) for some TI: . Auxiliary Funcon is-rendezvous-match(_:lists(rendezvous-waits), _:ground-values) : =&gt;booleans . Rule is-rendezvous-match([tuple(V&prime;, TI), P*], V:values) ~&gt; if-true-else(is-equal(V&prime;, V), true, is-rendezvous-match([P*], V)) Rule is-rendezvous-match([], V:values) ~&gt; false . The funcon rendezvous-first-match-thread(L, V) returns the thread-id of the first element of L with value V: . Auxiliary Funcon rendezvous-first-match-thread(_:lists(rendezvous-waits), _:values) : =&gt;thread-ids . Rule rendezvous-first-match-thread([tuple(V&prime;, TI), P*], V:values) ~&gt; if-true-else(is-equal(V&prime;, V), TI, rendezvous-first-match-thread([P*], V)) Rule rendezvous-first-match-thread([], V:values) ~&gt; fail . The funcon rendezvous-first-match-drop(L, V) returns the list L omitting the first element with value V: . Auxiliary Funcon rendezvous-first-match-drop(_:lists(rendezvous-waits), _:values) : =&gt;lists(rendezvous-waits) . Rule rendezvous-first-match-drop([tuple(V&prime;, TI), P*], V:values) ~&gt; if-true-else(is-equal(V&prime;, V), [P*], cons(tuple(V&prime;, TI), rendezvous-first-match-drop([P*], V))) Rule rendezvous-first-match-drop([], V:values) ~&gt; fail . A series of rendezvous between the same two threads is called an extended rendezvous. After the completion of each rendezvous in the series, one of the threads may immediately request the next, allowing the other thread to execute some code before synchronising. A simple rendezvous is restricted to synchronisation, and does not involve ordinary computation steps. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/Notifications/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/Notifications/index.html"
  },"502": {
    "doc": "Synchronising",
    "title": "Thread synchronisation",
    "content": "[ #### Syncs Datatype syncs Funcon sync-create Funcon sync-feature Funcon is-sync-feature #### Sync features Datatype sync-features Funcon sync-waiting-list Funcon sync-held Funcon sync-holder Funcon sync-count Funcon sync-feature-create ] . Thread synchronisation can be supported in many different ways: semaphores, exclusive and shared locks, conditions, barriers, rendezvous, spin-locks, etc. They generally involve the execution of one or more threads being blocked while they wait for some synchronisation request to be granted by a synchroniser due to a step by some unblocked thread. Blocking may involve thread suspension or repeated requests. In general, the effect of granting a sync needs to be atomic, to preclude preemption. However, the execution of the thread that caused the request to be granted might continue without yielding, thereby delaying the resumed execution of the requesting thread. Synchronisation ensures that the executions of two or more threads are at particular points at the same time, but it does not require their next steps to be simultaneous. Syncs are mutable structures that map sync features to variables (some fields may be constant values). Inspecting and updating sync features should be atomic, in case threads are preemptible. Syncs . A sync is formed from its features: . Datatype syncs ::= sync(_:sync-feature-maps) . sync-create(M+) checks that the specified features are distinct. (It could also check required feature constraints.) . Funcon sync-create(M+:sync-feature-maps+) : =&gt;syncs ~&gt; sync checked map-unite M+ . sync-feature(SY, SF) selects the feature SF from SY: . Funcon sync-feature(_:syncs, _:sync-features) : =&gt;values Rule sync-feature(sync(SFM:sync-feature-maps), SF:sync-features) ~&gt; checked map-lookup(SFM, SF) . is-sync-feature(SY, SF) tests whether SY has the feature SF: . Funcon is-sync-feature(_:syncs, _:sync-features) : =&gt;values Rule is-sync-feature(sync(SFM:sync-feature-maps), SF:sync-features) ~&gt; is-in-set(SF, dom SFM) . Sync features . Combinations of the following features support various kinds of locks and notifications. Datatype sync-features ::= sync-waiting-list | // allows suspending requests sync-held | // allows exclusive locks sync-holder | // allows mutex ownership sync-count // allows reentrance, sharing, etc. Auxiliary Type sync-feature-maps ~&gt; maps(sync-features, values) . A field for each feature is created independently: . Funcon sync-feature-create(_:sync-features) : =&gt;sync-feature-maps . sync-waiting-list stores pending requests in the order of receipt, together with the requesting thread-ids: . Rule sync-feature-create sync-waiting-list ~&gt; { sync-waiting-list |-&gt; allocate-initialised-variable(lists(values), [ ]) } . sync-held stores whether a lock is currently held: . Rule sync-feature-create sync-held ~&gt; { sync-held |-&gt; allocate-initialised-variable(booleans, false) } . sync-holder stores the current holder of a lock, if any: . Rule sync-feature-create sync-holder ~&gt; { sync-holder |-&gt; allocate-variable(thread-ids) } . sync-count stores a counter. Different kinds of locks and notifications use the counter in different ways, e.g., shared locks use it for the number of threads currently holding the lock: . Rule sync-feature-create sync-count ~&gt; { sync-count |-&gt; allocate-initialised-variable(nats, 0) } . sync-waiting-list-add(SY, V) adds V to the waiting-list of SY: . Auxiliary Funcon sync-waiting-list-add(SY:syncs, V:values) : =&gt;null-type ~&gt; assign(sync-feature(SY, sync-waiting-list), list-append(assigned sync-feature(SY, sync-waiting-list), [V])) . sync-waiting-list-head-remove(SY) removes the first value from the waiting-list of SY: . Auxiliary Funcon sync-waiting-list-head-remove(SY:syncs) : =&gt;values ~&gt; give( checked list-head assigned sync-feature(SY, sync-waiting-list), sequential( assign(sync-feature(SY, sync-waiting-list), checked list-tail assigned sync-feature(SY, sync-waiting-list)), given)) . Various kinds of locks and notifications are represented by sync feature maps, together with funcons that (atomically) inspect and update them accordngly. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/index.html#thread-synchronisation",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/index.html#thread-synchronisation"
  },"503": {
    "doc": "Synchronising",
    "title": "Synchronising",
    "content": "Unstable-Funcons-beta : Synchronising.cbs | PRETTY | PDF . Outline . | Thread synchronisation . | Syncs | Sync features | . | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/Synchronising/index.html"
  },"504": {
    "doc": "Threads",
    "title": "Threads",
    "content": "[ ### Multithreading ### Synchronising #### Locks #### Notifications ] . The funcons for threads are tentative. They have not yet been rigorously unit-tested, nor used significantly in language definitions. The multithreading funcons involve multiple mutable entities, and are generally specified by inference rules with premises involving the values of those entities before and after a transition. The synchronising funcons only involve the store entity, and wrap compound funcon terms in thread-atomic(_) to inhibit preemption. Some of the unit tests are based on examples in an IBM threads guide. | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/index.html#threads",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/index.html#threads"
  },"505": {
    "doc": "Threads",
    "title": "Threads",
    "content": "Unstable-Funcons-beta : Threads.cbs | PRETTY | PDF . Outline . | Threads | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/Threads/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/Threads/index.html"
  },"506": {
    "doc": "Computations",
    "title": "Computations",
    "content": "New funcons are introduced here. Compared to the funcons in [Funcons-beta], the new specifications may be less well tested, and relatively unstable, so they are listed separately. See Unstable-Languages-beta for illustrative examples of language specifications using the unstable funcons. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/index.html"
  },"507": {
    "doc": "Computations",
    "title": "Threads",
    "content": "Multithreading funcons have effects on mutable entities that represent the collection of threads, the set of active threads, the thread being executed, the values computed by terminated threads, and scheduling information. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/index.html#threads",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/index.html#threads"
  },"508": {
    "doc": "Computations",
    "title": "Normal computation",
    "content": "These funcons are potentially of general use, but first defined for use in connection with languages that include threads. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/index.html#normal-computation"
  },"509": {
    "doc": "Computations",
    "title": "Abnormal computation",
    "content": "These funcons are potentially of general use, but first defined for use in connection with languages that include threads. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Computations/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Computations/index.html#abnormal-computation"
  },"510": {
    "doc": "Unstable-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#computations"
  },"511": {
    "doc": "Unstable-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#normal-computation"
  },"512": {
    "doc": "Unstable-Funcons-Index",
    "title": "Value indexing",
    "content": "[ Entity value-index Funcon initialise-index Funcon allocate-index Funcon lookup-index ] . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#value-indexing",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#value-indexing"
  },"513": {
    "doc": "Unstable-Funcons-Index",
    "title": "Memos",
    "content": "[ Entity memo-map Funcon initialise-memos Funcon memo-value Funcon initialise-memo-value Funcon memo-value-recall ] . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#memos",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#memos"
  },"514": {
    "doc": "Unstable-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#abnormal-computation"
  },"515": {
    "doc": "Unstable-Funcons-Index",
    "title": "Postponing",
    "content": "[ Entity postponing Funcon postpone Funcon postpone-after-effect Funcon after-effect ] . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#postponing",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#postponing"
  },"516": {
    "doc": "Unstable-Funcons-Index",
    "title": "Threads",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#threads",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#threads"
  },"517": {
    "doc": "Unstable-Funcons-Index",
    "title": "Multithreading",
    "content": "[ Datatype thread-ids Datatype threads Funcon thread-joinable Funcon thread-detached ] . Initialisation . [ Funcon initialise-multithreading ] . Activation . [ Funcon multithread Funcon thread-activate Funcon thread-detach ] . Execution . [ Funcon current-thread Funcon thread-atomic Funcon thread-yield Funcon thread-spin Funcon thread-suspend Funcon thread-resume ] . Termination . [ Funcon thread-terminate Funcon is-thread-terminated Funcon thread-value Funcon thread-join Funcon thread-exterminate ] . Scheduling . [ Funcon update-thread-stepping Funcon update-thread-schedule Funcon current-thread-schedule Funcon is-thread-preemptible Funcon thread-preemptible Funcon thread-cooperative ] . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#multithreading",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#multithreading"
  },"518": {
    "doc": "Unstable-Funcons-Index",
    "title": "Thread synchronisation",
    "content": "Syncs . [ Datatype syncs Funcon sync-create Funcon sync-feature Funcon is-sync-feature ] . Sync features . [ Datatype sync-features Funcon sync-waiting-list Funcon sync-held Funcon sync-holder Funcon sync-count Funcon sync-feature-create ] . Locks . [ Funcon is-exclusive-lock-holder ] . Spin locks . [ Funcon spin-lock-create Funcon spin-lock-sync Funcon spin-lock-release ] . Exclusive locks . [ Funcon exclusive-lock-create Funcon exclusive-lock-sync Funcon exclusive-lock-sync-else-wait Funcon exclusive-lock-release ] . Reentrant locks . [ Funcon reentrant-lock-create Funcon reentrant-lock-sync Funcon reentrant-lock-sync-else-wait Funcon reentrant-lock-release Funcon reentrant-lock-exit ] . Semaphores . [ Funcon semaphore-create Funcon semaphore-sync Funcon semaphore-sync-else-wait Funcon semaphore-release ] . Shared-exclusive locks . [ Funcon rw-lock-create Funcon rw-lock-sync-exclusive Funcon rw-lock-sync-shared Funcon rw-lock-sync-exclusive-else-wait Funcon rw-lock-sync-shared-else-wait Funcon rw-lock-release-exclusive Funcon rw-lock-release-shared ] . Notifications . Barriers . [ Funcon barrier-create Funcon barrier-sync Funcon barrier-sync-else-wait ] . Conditions . [ Funcon condition-create Funcon condition-wait Funcon condition-wait-with-lock Funcon condition-notify-all Funcon condition-notify-first ] . Rendezvous . [ Funcon rendezvous-create Funcon rendezvous-sync Funcon rendezvous-sync-else-wait ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#thread-synchronisation",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html#thread-synchronisation"
  },"519": {
    "doc": "Unstable-Funcons-Index",
    "title": "Unstable-Funcons-Index",
    "content": "Unstable-Funcons-beta : Unstable-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Value indexing | Memos | . | Abnormal computation . | Postponing | . | Threads . | Multithreading . | Initialisation | Activation | Execution | Termination | Scheduling | . | Thread synchronisation . | Syncs | Sync features | Locks . | Spin locks | Exclusive locks | Reentrant locks | Semaphores | Shared-exclusive locks | . | Notifications . | Barriers | Conditions | Rendezvous | . | . | . | . | . Unstable Funcons, for use only in Unstable Languages . ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/Unstable-Funcons-Index/index.html"
  },"520": {
    "doc": "Unstable-Funcons-beta",
    "title": "Unstable-Funcons-beta",
    "content": "New funcons are likely to be introduced in the beta-release period. Compared to the funcons in [Funcons-beta], the new specifications may be less well tested, and relatively unstable, so they are listed separately. See Unstable-Languages-beta for illustrative examples of language specifications using the unstable funcons. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/index.html",
    "relUrl": "/docs/Unstable-Funcons-beta/index.html"
  },"521": {
    "doc": "Unstable-Funcons-beta",
    "title": "Unstable-Funcons-Index",
    "content": "The Unstable-Funcons-Index page lists the names of all the unstable funcons. The list is grouped in the same way as the hierarchy of CBS files in which the funcons are defined. The names are hyperlinked to their definitions; familiarity with the hierarchy is not required for navigating CBS specifications. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/index.html#unstable-funcons-index",
    "relUrl": "/docs/Unstable-Funcons-beta/index.html#unstable-funcons-index"
  },"522": {
    "doc": "Unstable-Funcons-beta",
    "title": "Computations",
    "content": "The Computations page introduces the various kinds of computations defined in the library. ",
    "url": "/CBS-beta/docs/Unstable-Funcons-beta/index.html#computations",
    "relUrl": "/docs/Unstable-Funcons-beta/index.html#computations"
  },"523": {
    "doc": "IMPPP-1",
    "title": "1 Values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#SectionNumber_1",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#SectionNumber_1"
  },"524": {
    "doc": "IMPPP-1",
    "title": "Integers",
    "content": "Syntax N : int ::= '-'?_decimal Lexis D : decimal ::= ('0'-'9')+ . Semantics int-val[[ _:int ]] : =&gt;integers Rule int-val[[ D ]] = decimal-natural(\\\"D\\\") Rule int-val[[ '-' D ]] = integer-negate(int-val[[ D ]]) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#integers",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#integers"
  },"525": {
    "doc": "IMPPP-1",
    "title": "Strings",
    "content": "Syntax S : string ::= '\"'_string-chars_'\"' Lexis SCS : string-chars ::= (~'\"')* . Semantics string-val[[ _:string ]] : =&gt;strings Rule string-val[[ '\"' SCS '\"' ]] = \\\"SCS\\\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#strings",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#strings"
  },"526": {
    "doc": "IMPPP-1",
    "title": "Identifiers",
    "content": "Lexis I : id ::= ('A'-'Z'|'a'-'z'|'_') ('0'-'9'|'A'-'Z'|'a'-'z'|'_')* . Semantics id[[ _:id ]] : =&gt;ids Rule id[[ I ]] = \\\"I\\\" . Lexis keyword ::= 'else' | 'false' | 'if' | 'halt' | 'join' | 'print' | 'read' | 'spawn' | 'true' | 'while' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#identifiers",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html#identifiers"
  },"527": {
    "doc": "IMPPP-1",
    "title": "IMPPP-1",
    "content": "Unstable-Languages-beta : IMPPP-1.cbs | PRETTY | PDF . Outline . | 1 Values . | Integers | Strings | Identifiers | . | . Language \"IMPPP\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-1/index.html"
  },"528": {
    "doc": "IMPPP-2",
    "title": "2 Value expressions",
    "content": "Syntax AExp : aexp ::= int | string | id | aexp '+' aexp | aexp '/' aexp | '(' aexp ')' | id '=' aexp | '++' id | 'read' '(' ')' | 'spawn' block . Type aexp-values ~&gt; integers | strings . Funcon integer-add-or-string-append(_:aexp-values, _:aexp-values) : =&gt; aexp-values Rule integer-add-or-string-append(N1:integers, N2:integers) ~&gt; integer-add(N1, N2) Rule integer-add-or-string-append(S1:strings, S2:strings) ~&gt; string-append(S1, S2) . Semantics eval-arith[[ _:aexp ]] : =&gt;aexp-values Rule eval-arith[[ N ]] = int-val[[ N ]] Rule eval-arith[[ S ]] = string-val[[ S ]] Rule eval-arith[[ I ]] = assigned(bound(id[[ I ]])) Rule eval-arith[[ AExp1 '+' AExp2 ]] = integer-add-or-string-append(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-arith[[ AExp1 '/' AExp2 ]] = checked integer-divide(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-arith[[ '(' AExp ')' ]] = eval-arith[[ AExp ]] Rule eval-arith[[ I '=' AExp ]] = give(eval-arith[[ AExp ]], sequential(assign(bound(id[[ I ]]), given), given)) Rule eval-arith[[ '++' I ]] = give(integer-add(assigned(bound(id[[ I ]])), 1), sequential(assign(bound(id[[ I ]]), given), given)) Rule eval-arith[[ 'read' '(' ')' ]] = read Rule eval-arith[[ 'spawn' Block ]] = allocate-index( thread-activate thread-joinable thunk closure execute[[ Block ]]) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html#SectionNumber_2",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html#SectionNumber_2"
  },"529": {
    "doc": "IMPPP-2",
    "title": "Value expression sequences",
    "content": "Syntax AExps: aexps ::= aexp (',' aexps)? . Semantics eval-arith-seq[[ _:aexps ]] : (=&gt;aexp-values)+ Rule eval-arith-seq[[ AExp ]] = eval-arith[[ AExp ]] Rule eval-arith-seq[[ AExp ',' AExps ]] = eval-arith[[ AExp ]], eval-arith-seq[[ AExp ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html#value-expression-sequences",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html#value-expression-sequences"
  },"530": {
    "doc": "IMPPP-2",
    "title": "IMPPP-2",
    "content": "Unstable-Languages-beta : IMPPP-2.cbs | PRETTY | PDF . Language \"IMPPP\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-2/index.html"
  },"531": {
    "doc": "IMPPP-3",
    "title": "3 Boolean expressions",
    "content": "Syntax BExp : bexp ::= 'false' | 'true' | aexp '&lt;=' aexp | '!' bexp | bexp '&amp;&amp;' bexp | '(' bexp ')' . Semantics eval-bool[[ _:bexp ]] : =&gt;booleans Rule eval-bool[[ 'false' ]] = false Rule eval-bool[[ 'true' ]] = true Rule eval-bool[[ AExp1 '&lt;=' AExp2 ]] = is-less-or-equal left-to-right(eval-arith[[ AExp1 ]], eval-arith[[ AExp2 ]]) Rule eval-bool[[ '!' BExp ]] = not(eval-bool[[ BExp ]]) Rule eval-bool[[ BExp1 '&amp;&amp;' BExp2 ]] = if-true-else(eval-bool[[ BExp1 ]], eval-bool[[ BExp2 ]], false) Rule eval-bool[[ '(' BExp ')' ]] = eval-bool[[ BExp ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-3/index.html#SectionNumber_3",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-3/index.html#SectionNumber_3"
  },"532": {
    "doc": "IMPPP-3",
    "title": "IMPPP-3",
    "content": "Unstable-Languages-beta : IMPPP-3.cbs | PRETTY | PDF . Language \"IMPPP\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-3/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-3/index.html"
  },"533": {
    "doc": "IMPPP-4",
    "title": "4 Statements and blocks",
    "content": "Syntax Stmt : stmt ::= block | 'int' ids ';' | aexp ';' | 'if' '(' bexp ')' block 'else' block | 'while' '(' bexp ')' block | 'print' '(' aexps ')' ';' | 'halt' ';' | 'join' aexp ';' Block : block ::= '{' stmt* '}' . Semantics execute[[ _:stmt* ]] : =&gt;null-type Rule execute[[ ]] = null Rule execute[[ 'int' IL ';' Stmt* ]] = scope(collateral(declare-int-vars[[ IL ]]), execute[[ Stmt* ]]) Otherwise execute[[ Stmt Stmt+ ]] = sequential(execute[[ Stmt ]], execute[[ Stmt+ ]]) Rule execute[[ AExp ';' ]] = effect(eval-arith[[ AExp ]]) Rule execute[[ 'if' '(' BExp ')' Block1 'else' Block2 ]] = if-true-else(eval-bool[[ BExp ]], execute[[ Block1 ]], execute[[ Block2 ]]) Rule execute[[ 'while' '(' BExp ')' Block ]] = while-true(eval-bool[[ BExp ]], execute[[ Block ]]) Rule execute[[ 'print' '(' AExp ')' ';' ]] = print(eval-arith[[ AExp ]]) Rule [[ 'print' '(' AExp ',' AExps ')' ';' ]] : stmt+ = [[ 'print' '(' AExp ')' ';' 'print' '(' AExps ')' ';' ]] Rule execute[[ 'halt' ';' ]] = thread-terminate(current-thread) Rule execute[[ 'join' AExp ';' ]] = thread-join(lookup-index(eval-arith[[ AExp ]])) Rule execute[[ '{' Stmt* '}' ]] = execute[[ Stmt* ]] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html#SectionNumber_4",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html#SectionNumber_4"
  },"534": {
    "doc": "IMPPP-4",
    "title": "Variable declarations",
    "content": "Syntax IL : ids ::= id (',' ids)? . Semantics declare-int-vars[[ _: ids ]] : (=&gt;environments)+ Rule declare-int-vars[[ I ]] = bind(id[[ I ]], allocate-initialised-variable(integers, 0)) Rule declare-int-vars[[ I ',' IL ]] = declare-int-vars[[ I ]], declare-int-vars[[ IL ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html#variable-declarations",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html#variable-declarations"
  },"535": {
    "doc": "IMPPP-4",
    "title": "IMPPP-4",
    "content": "Unstable-Languages-beta : IMPPP-4.cbs | PRETTY | PDF . Language \"IMPPP\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-4/index.html"
  },"536": {
    "doc": "IMPPP-Disambiguation",
    "title": "A Disambiguation",
    "content": "Lexis SDF lexical syntax id = keyword {reject} lexical restrictions id -/- [A-Za-z0-9] Syntax SDF context-free syntax aexp ::= aexp '+' aexp {assoc} bexp ::= bexp '&amp;&amp;' bexp {assoc} context-free priorities aexp ::= aexp '/' aexp &gt; aexp ::= aexp '+' aexp &gt; aexp ::= id '=' aexp context-free priorities bexp ::= '!' bexp &gt; bexp ::= bexp '&amp;&amp;' bexp . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Disambiguation/index.html#SectionNumber_A"
  },"537": {
    "doc": "IMPPP-Disambiguation",
    "title": "IMPPP-Disambiguation",
    "content": "Unstable-Languages-beta : IMPPP-Disambiguation.cbs | PRETTY | PDF . Language \"IMPPP\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Disambiguation/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Disambiguation/index.html"
  },"538": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#computations"
  },"539": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#normal-computation"
  },"540": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon left-to-right Alias l-to-r Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while Funcon atomic ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#flowing"
  },"541": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Giving",
    "content": "[ Entity given-value Funcon give Funcon given Funcon no-given Funcon left-to-right-filter ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#giving"
  },"542": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon scope Funcon collateral ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#binding"
  },"543": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Generating",
    "content": "[ Type atoms Funcon fresh-atom ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#generating",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#generating"
  },"544": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Storing",
    "content": "[ Entity store Funcon initialise-storing Funcon allocate-variable Alias alloc Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned Funcon un-assign ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#storing"
  },"545": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Funcon read ] . Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#interacting"
  },"546": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#abnormal-computation"
  },"547": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Terminating abruptly",
    "content": "[ Entity abrupted Funcon handle-abrupt ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#terminating-abruptly",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#terminating-abruptly"
  },"548": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon fail Funcon else Funcon checked Funcon check-true ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#failing"
  },"549": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#values",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#values"
  },"550": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Funcon is-value Alias is-val Funcon when-true Alias when Type ground-values Alias ground-vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#value-types"
  },"551": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#primitive-values"
  },"552": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not Funcon and ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#booleans"
  },"553": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Type positive-integers Alias pos-ints Type natural-numbers Alias nats Funcon natural-successor Alias nat-succ Funcon natural-predecessor Alias nat-pred Funcon integer-add Alias int-add Funcon integer-divide Alias int-div Funcon integer-negate Alias int-neg Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#integers"
  },"554": {
    "doc": "IMPPP-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#the-null-value"
  },"555": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#composite-values"
  },"556": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon first Funcon second ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#sequences-of-values"
  },"557": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#tuples"
  },"558": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list-elements Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail Funcon list-append ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#lists",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#lists"
  },"559": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Strings",
    "content": "[ Type strings Funcon string-append ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#strings",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#strings"
  },"560": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Sets",
    "content": "[ Type sets Funcon is-in-set Funcon is-subset Funcon set-unite Funcon set-intersect Funcon set-difference Funcon some-element ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#sets",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#sets"
  },"561": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite Funcon map-delete ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#maps"
  },"562": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#abstraction-values"
  },"563": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Type abstractions Funcon abstraction Funcon closure ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#generic-abstractions"
  },"564": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Thunks",
    "content": "[ Datatype thunks Funcon thunk ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#thunks",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#thunks"
  },"565": {
    "doc": "IMPPP-Funcons-Index",
    "title": "Functions",
    "content": "[ Funcon apply Funcon supply ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html#functions"
  },"566": {
    "doc": "IMPPP-Funcons-Index",
    "title": "IMPPP-Funcons-Index",
    "content": "Unstable-Languages-beta : IMPPP-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Interacting . | Input | Output | . | . | Abnormal computation . | Terminating abruptly | Failing | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Sequences of values | Tuples | Lists | Strings | Sets | Maps | . | Abstraction values . | Generic abstractions | Thunks | Functions | . | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Funcons-Index/index.html"
  },"567": {
    "doc": "IMPPP-Start",
    "title": "IMPPP-Start",
    "content": "Unstable-Languages-beta : IMPPP-Start.cbs | PRETTY | PDF . Language \"IMPPP\" . [ # 1 Values # 2 Value expressions # 3 Boolean expressions # 4 Statements and blocks # A Disambiguation ] . See also Unstable-Funcons-beta . Syntax START: start ::= stmt* . Semantics start[[_:start]] : =&gt;null-type Rule start[[ Stmt* ]] = initialise-binding initialise-storing finalise-failing sequential(initialise-index, multithread execute[[ Stmt* ]]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Start/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Start/index.html"
  },"568": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#computations"
  },"569": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#normal-computation"
  },"570": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "Value indexing",
    "content": "[ Funcon initialise-index Funcon allocate-index Funcon lookup-index ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#value-indexing",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#value-indexing"
  },"571": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "Threads",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#threads",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#threads"
  },"572": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "Multithreading",
    "content": "[ Funcon thread-joinable ] . Activation . [ Funcon multithread Funcon thread-activate ] . Execution . [ Funcon current-thread ] . Termination . [ Funcon thread-terminate Funcon thread-join ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#multithreading",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html#multithreading"
  },"573": {
    "doc": "IMPPP-Unstable-Funcons-Index",
    "title": "IMPPP-Unstable-Funcons-Index",
    "content": "Unstable-Languages-beta : IMPPP-Unstable-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Value indexing | . | Threads . | Multithreading . | Activation | Execution | Termination | . | . | . | . Unstable Funcons, for use only in Unstable Languages . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/IMPPP-cbs/IMPPP/IMPPP-Unstable-Funcons-Index/index.html"
  },"574": {
    "doc": "IMPPP",
    "title": "IMP++",
    "content": "Unstable language specification, illustrating use of multithreading funcons . Grigore Rosu wrote (Rosu2017KSF): . IMP++ extends the IMP language with: . | Strings and concatenation of strings. […] | Variable increment. […] | Input and output. […] | Abrupt termination. […] | Dynamic threads. […] | Blocks and local variables. […] | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html#imp",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html#imp"
  },"575": {
    "doc": "IMPPP",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete | dynamic semantics: complete | static semantics: not relevant | disambiguation: complete | . Tests: . | 6 small multithreading programs | 9 small imperative tests | 3 small imperative programs | . Evolution: . | extends IMP | . Reuse of funcons: . | IMPPP-Funcons-Index | IMPPP-Unstable-Funcons-Index | . References: . | K semantic definition of the IMP++ language (IMP++ in K) | K – A Semantic Framework for Programming Languages and Formal Analysis Tools (Rosu2017KSF) | . Keywords: . | imperative, multithreading, illustrative, simple, disambiguation, K framework | . Main contributors: . | Peter Mosses, Neil Sculthorpe | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html#colophon",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html#colophon"
  },"576": {
    "doc": "IMPPP",
    "title": "IMPPP",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/IMP-Plus-Plus/index.html"
  },"577": {
    "doc": "LD-Disambiguation",
    "title": "A Disambiguation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A"
  },"578": {
    "doc": "LD-Disambiguation",
    "title": "A.1 Lexical constructs",
    "content": "Lexis SDF lexical syntax id = keyword {reject} lexical restrictions id -/- [a-z0-9] int -/- [0-9] Syntax SDF context-free syntax start ::= exp {prefer} . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.1",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.1"
  },"579": {
    "doc": "LD-Disambiguation",
    "title": "A.2 Call-by-value lambda-calculus",
    "content": "Syntax SDF context-free syntax exp ::= 'lambda' id '.' exp {longest-match} exp ::= exp exp {left} exp ::= 'let' id '=' exp 'in' exp {longest-match} context-free priorities exp ::= exp exp &gt; { exp ::= 'lambda' id '.' exp exp ::= 'let' id '=' exp 'in' exp } . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.2",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.2"
  },"580": {
    "doc": "LD-Disambiguation",
    "title": "A.3 Arithmetic and Boolean expressions",
    "content": "Syntax SDF context-free syntax exp ::= exp '+' exp {left} exp ::= exp '*' exp {left} exp ::= exp '/' exp {left} exp ::= exp '&lt;=' exp {non-assoc} exp ::= exp '&amp;&amp;' exp {right} exp ::= 'if' exp 'then' exp 'else' exp {longest-match} context-free priorities exp ::= exp exp &gt; {left: exp ::= exp '*' exp exp ::= exp '/' exp } &gt; exp ::= exp '+' exp &gt; exp ::= exp '&lt;=' exp &gt; exp ::= exp '&amp;&amp;' exp &gt; { exp ::= 'lambda' id '.' exp exp ::= 'let' id '=' exp 'in' exp } . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.3",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.3"
  },"581": {
    "doc": "LD-Disambiguation",
    "title": "A.4 References and imperatives",
    "content": "Syntax SDF context-free syntax exp ::= exp ':=' exp {non-assoc} exp ::= exp ';' exp {right} exp ::= 'while' exp 'do' exp {longest-match} context-free priorities { exp ::= 'ref' exp exp ::= '!' exp }&gt; exp ::= exp exp context-free priorities exp ::= exp '&amp;&amp;' exp &gt; exp ::= exp ':=' exp &gt; { exp ::= 'lambda' id '.' exp exp ::= 'while' exp 'do' exp } &gt; exp ::= exp ';' exp &gt; exp ::= 'let' id '=' exp 'in' exp . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.4",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.4"
  },"582": {
    "doc": "LD-Disambiguation",
    "title": "A.5 Multithreading",
    "content": "Syntax SDF context-free priorities { exp ::= 'spawn' exp exp ::= 'join' exp } &gt; exp ::= exp ';' exp . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.5",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html#SectionNumber_A.5"
  },"583": {
    "doc": "LD-Disambiguation",
    "title": "LD-Disambiguation",
    "content": "Unstable-Languages-beta : LD-Disambiguation.cbs | PRETTY | PDF . Language \"LD\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Disambiguation/index.html"
  },"584": {
    "doc": "LD-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#computations"
  },"585": {
    "doc": "LD-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#normal-computation"
  },"586": {
    "doc": "LD-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon left-to-right Alias l-to-r Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#flowing"
  },"587": {
    "doc": "LD-Funcons-Index",
    "title": "Giving",
    "content": "[ Funcon give Funcon given ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#giving"
  },"588": {
    "doc": "LD-Funcons-Index",
    "title": "Binding",
    "content": "[ Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon scope ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#binding"
  },"589": {
    "doc": "LD-Funcons-Index",
    "title": "Generating",
    "content": "[ Type atoms Funcon fresh-atom ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#generating",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#generating"
  },"590": {
    "doc": "LD-Funcons-Index",
    "title": "Storing",
    "content": "[ Funcon initialise-storing Datatype variables Alias vars Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#storing"
  },"591": {
    "doc": "LD-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#abnormal-computation"
  },"592": {
    "doc": "LD-Funcons-Index",
    "title": "Terminating abruptly",
    "content": "[ Funcon handle-abrupt ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#terminating-abruptly",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#terminating-abruptly"
  },"593": {
    "doc": "LD-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon fail Funcon checked ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#failing"
  },"594": {
    "doc": "LD-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#values",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#values"
  },"595": {
    "doc": "LD-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Funcon is-value Alias is-val Type ground-values Alias ground-vals ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#value-types"
  },"596": {
    "doc": "LD-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#primitive-values"
  },"597": {
    "doc": "LD-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#booleans"
  },"598": {
    "doc": "LD-Funcons-Index",
    "title": "Integers",
    "content": "[ Type integers Alias ints Type natural-numbers Alias nats Funcon integer-add Alias int-add Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#integers"
  },"599": {
    "doc": "LD-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#the-null-value"
  },"600": {
    "doc": "LD-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#composite-values"
  },"601": {
    "doc": "LD-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#sequences-of-values"
  },"602": {
    "doc": "LD-Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#lists",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#lists"
  },"603": {
    "doc": "LD-Funcons-Index",
    "title": "Sets",
    "content": "[ Type sets Funcon is-in-set Funcon is-subset Funcon set-unite Funcon set-intersect Funcon set-difference Funcon some-element ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#sets",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#sets"
  },"604": {
    "doc": "LD-Funcons-Index",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite Funcon map-delete ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#maps"
  },"605": {
    "doc": "LD-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#abstraction-values"
  },"606": {
    "doc": "LD-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Type abstractions Funcon abstraction Funcon closure ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#generic-abstractions"
  },"607": {
    "doc": "LD-Funcons-Index",
    "title": "Thunks",
    "content": "[ Datatype thunks Funcon thunk ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#thunks",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#thunks"
  },"608": {
    "doc": "LD-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply Funcon supply ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html#functions"
  },"609": {
    "doc": "LD-Funcons-Index",
    "title": "LD-Funcons-Index",
    "content": "Unstable-Languages-beta : LD-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Generating | Storing | . | Abnormal computation . | Terminating abruptly | Failing | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Sequences of values | Lists | Sets | Maps | . | Abstraction values . | Generic abstractions | Thunks | Functions | . | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Funcons-Index/index.html"
  },"610": {
    "doc": "LD-Start",
    "title": "1 Lexical constructs",
    "content": "Rule eval[[ N ]] = decimal \\\"N\\\" Rule eval[[ X ]] = bound \\\"X\\\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_1",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_1"
  },"611": {
    "doc": "LD-Start",
    "title": "2 Call-by-value lambda-calculus",
    "content": "Rule eval[[ 'lambda' X '.' E ]] = function closure scope( bind( \\\"X\\\", given ), eval[[ E ]] ) Rule eval[[ E1 E2 ]] = apply( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ 'let' X '=' E1 'in' E2 ]] = scope( bind( \\\"X\\\", eval[[ E1 ]] ), eval[[ E2 ]] ) . Desugaring (alternative to the above rule): . Rule [[ 'let' X '=' E1 'in' E2 ]] : exp = [[ '(' 'lambda' X '.' E2 ')' '(' E1 ')' ]] . Rule eval[[ '(' E ')' ]] = eval[[ E ]] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_2",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_2"
  },"612": {
    "doc": "LD-Start",
    "title": "3 Arithmetic and Boolean expressions",
    "content": "Rule eval[[ E1 '+' E2 ]] = int-add( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ E1 '*' E2 ]] = int-mul( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ E1 '/' E2 ]] = checked int-div ( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ E1 '&lt;=' E2 ]] = is-less-or-equal l-to-r( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ E1 '&amp;&amp;' E2 ]] = if-true-else( eval[[ E1 ]], eval[[ E2 ]], false ) Rule eval[[ 'if' E1 'then' E2 'else' E3 ]] = if-true-else( eval[[ E1 ]], eval[[ E2 ]], eval[[ E3 ]] ) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_3",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_3"
  },"613": {
    "doc": "LD-Start",
    "title": "4 References and imperatives",
    "content": "Rule eval[[ 'ref' E ]] = allocate-initialised-variable( ld-values, eval[[ E ]] ) Rule eval[[ E1 ':=' E2 ]] = assign( eval[[ E1 ]], eval[[ E2 ]] ) Rule eval[[ '!' E ]] = assigned( eval[[ E ]] ) Rule eval[[ E1 ';' E2 ]] = sequential( effect( eval[[ E1 ]] ), eval[[ E2 ]] ) Rule eval[[ '(' ')' ]] = null-value Rule eval[[ 'while' E1 'do' E2 ]] = while-true( eval[[ E1 ]], effect( eval[[ E2 ]] ) ) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_4",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_4"
  },"614": {
    "doc": "LD-Start",
    "title": "5 Multithreading",
    "content": "N.B. The funcons for multithreading have not yet been fully validated, so they are defined in Unstable-Funcons-beta instead of Funcons-beta. Rule eval[[ 'spawn' E ]] = thread-activate thread-joinable thunk closure eval[[ E ]] Rule eval[[ 'join' E ]] = thread-join( eval[[ E ]] ) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_5",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_5"
  },"615": {
    "doc": "LD-Start",
    "title": "6 Programs",
    "content": "Syntax START:start ::= exp . Semantics start[[ _:start ]] : =&gt;values Rule start[[ E ]] = initialise-binding initialise-storing finalise-failing multithread eval[[ E ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_6",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html#SectionNumber_6"
  },"616": {
    "doc": "LD-Start",
    "title": "LD-Start",
    "content": "Unstable-Languages-beta : LD-Start.cbs | PRETTY | PDF . Language \"LD\" . [ # 1 Lexical constructs # 2 Call-by-value lambda-calculus # 3 Arithmetic and Boolean expressions # 4 References and imperatives # 5 Multithreading # 6 Programs # A Disambiguation ] . Lexical syntax: . Lexis X:id ::= ('a'-'z') ('a'-'z'|'0'-'9')* N:int ::= ('0'-'9')+ keyword ::= 'do' | 'else' | 'fork' | 'if' | 'in' | 'join' | 'lambda' | 'let' | 'ref' | 'spawn' | 'then' | 'while' . Context-free syntax: . Syntax E:exp ::= int | id // Call-by-value lambda-calculus: | 'lambda' id '.' exp | exp exp | 'let' id '=' exp 'in' exp | '(' exp ')' // Arithmetic and Boolean expressions: | exp '+' exp | exp '*' exp | exp '/' exp | exp '&lt;=' exp | exp '&amp;&amp;' exp | 'if' exp 'then' exp 'else' exp // References and imperatives: | 'ref' exp | exp ':=' exp | '!' exp | exp ';' exp | '(' ')' | 'while' exp 'do' exp // Multithreading: | 'spawn' exp | 'join' exp . Expression evaluation: . Type ld-values ~&gt; functions(values, values) | integers | booleans | variables | null-type | thread-ids . Semantics eval[[ _:exp ]] : =&gt; ld-values . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Start/index.html"
  },"617": {
    "doc": "LD-Unstable-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#computations"
  },"618": {
    "doc": "LD-Unstable-Funcons-Index",
    "title": "Threads",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#threads",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#threads"
  },"619": {
    "doc": "LD-Unstable-Funcons-Index",
    "title": "Multithreading",
    "content": "[ Datatype thread-ids Funcon thread-joinable ] . Activation . [ Funcon multithread Funcon thread-activate ] . Termination . [ Funcon thread-join ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#multithreading",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html#multithreading"
  },"620": {
    "doc": "LD-Unstable-Funcons-Index",
    "title": "LD-Unstable-Funcons-Index",
    "content": "Unstable-Languages-beta : LD-Unstable-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Threads . | Multithreading . | Activation | Termination | . | . | . | . Unstable Funcons, for use only in Unstable Languages . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-cbs/LD/LD-Unstable-Funcons-Index/index.html"
  },"621": {
    "doc": "LD-demo",
    "title": "Demonstration of incremental language specification",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#demonstration-of-incremental-language-specification",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#demonstration-of-incremental-language-specification"
  },"622": {
    "doc": "LD-demo",
    "title": "Initial language",
    "content": ". | Comment-out syntax, disambiguation, values, and rules: . | References and imperatives §4, §A.4 | Multithreading §5, §A.5 | the use of initialise-storing and multithread §6 | the use of variables, null-type, thread-ids in ld-values | . | Eclipse: LD-cbs: Clean project | Spoofax: LD-Start.cbs: Generate language editor | Eclipse: LD-Editor: Refresh, clean project, build | Spoofax: Generate funcons for LD test programs: . | LD-Tests/2-Lambda/church.ld | LD-Tests/3-Arithmetic/if.ld | . | Terminal: Generate interpreter runfct-LD . | cd LD-Interpreter; cabal v1-clean; make gen-hss; make cabal | . | Spoofax: Run funcons of test programs . | runfct-LD --config LD-1.config LD-Tests/2-Lambda/church.fct | runfct-LD --config LD-1.config LD-Tests/3-Arithmetic/if.fct | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#initial-language",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#initial-language"
  },"623": {
    "doc": "LD-demo",
    "title": "Imperative language",
    "content": ". | Comment-in syntax, disambiguation, values, and rules: . | References and imperatives §4, §A.4 | the use of initialise-storing §6 | the use of variables, null-type in ld-values | . | Eclipse: LD-cbs: Clean project | Spoofax: LD-Start.cbs: Generate language editor | Eclipse: LD-Editor: Refresh, clean project, build | Spoofax: Generate funcons for LD test programs: . | LD-Tests/4-Imperative/sum.ld | . | Terminal: Update interpreter runfct-LD . | cd LD-Interpreter; cabal v1-clean; make gen-hss; make cabal | . | Spoofax: Run funcons of test programs . | runfct-LD --config LD-2.config LD-Tests/4-Imperative/sum.fct | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#imperative-language",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#imperative-language"
  },"624": {
    "doc": "LD-demo",
    "title": "Multithreading language",
    "content": ". | Comment-in syntax, disambiguation, values, and rules: . | Multithreading §5, §A.5 | the use of multithread §6 | the use of thread-ids in ld-values | . | Eclipse: LD-cbs: Clean project | Spoofax: LD-Start.cbs: Generate language editor | Eclipse: LD-Editor: Refresh, clean project, build | Spoofax: Generate funcons for LD test programs: . | LD-Tests/5-Threads/spawn-sync.ld | . | Terminal: Update interpreter runfct-LD . | cd LD-Interpreter; cabal v1-clean; make gen-hss; make cabal | . | Spoofax: Run funcons of test programs . | runfct-LD --config LD-3.config LD-Tests/5-Threads/spawn-sync.fct | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#multithreading-language",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html#multithreading-language"
  },"625": {
    "doc": "LD-demo",
    "title": "LD-demo",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/LD-demo.html"
  },"626": {
    "doc": "LD",
    "title": "LangDev-2019",
    "content": "Demonstration of co-evolution of a language specification in CBS (LangDev-2019) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/index.html#langdev-2019",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/index.html#langdev-2019"
  },"627": {
    "doc": "LD",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete | dynamic semantics: complete | static semantics: not specified | disambiguation: adequate | . Tests: . | 16 small programs | adequate coverage? | non-determinism only partially tested | . Evolution: . | first version | . Reuse of funcons: . | LangDev-2019-Funcons-Index | LangDev-2019-Unstable-Funcons-Index | . References: . | LangDev’19 presentation: Slides PDF | Executable component-based semantics: JLAMP, preprint | Software meta-language engineering and CBS: JVLC | . Keywords: . | functional, imperative, concurrent, illustrative, simple, disambiguation | . Main contributors: . | Peter Mosses | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/index.html#colophon",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/index.html#colophon"
  },"628": {
    "doc": "LD",
    "title": "LD",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/LangDev-2019/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/LangDev-2019/index.html"
  },"629": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "1 Lexical Syntax",
    "content": "Syntax V : value ::= bool | int | string bool ::= 'false' | 'true' Lexis Z : int ::= ('0'-'9')+ Syntax string ::= '\"'_string-chars_'\"' Lexis S : string-chars ::= (~'\"')* . Semantics val[[ _:value ]] : =&gt;values . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1"
  },"630": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "1.1 Booleans",
    "content": "Rule val[[ 'false' ]] = false Rule val[[ 'true' ]] = true . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.1",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.1"
  },"631": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "1.2 Integers",
    "content": "Rule val[[ Z ]] = decimal-natural(\\\"Z\\\") . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.2",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.2"
  },"632": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "1.3 Strings",
    "content": "Rule val[[ '\"' S '\"' ]] = \\\"S\\\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.3",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.3"
  },"633": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "1.4 Identifiers",
    "content": "Lexis Id : id ::= ('A'-'Z'|'a'-'z'|'_') ('0'-'9'|'A'-'Z'|'a'-'z'|'_')* . Semantics id[[ _:id ]] : =&gt;ids Rule id[[ Id ]] = \\\"Id\\\" . Lexis keyword ::= 'false' | 'true' | 'var' | 'function' | 'sizeOf' | 'read' | 'spawn' | 'if' | 'else' | 'while' | 'for' | 'print' | 'return' | 'try' | 'catch' | 'throw' | 'join' | 'acquire' | 'release' | 'rendezvous' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.4",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html#SectionNumber_1.4"
  },"634": {
    "doc": "SIMPLE-THR-1-Lexical",
    "title": "SIMPLE-THR-1-Lexical",
    "content": "Unstable-Languages-beta : SIMPLE-THR-1-Lexical.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-1-Lexical/index.html"
  },"635": {
    "doc": "SIMPLE-THR-2-Expressions",
    "title": "2 Expressions",
    "content": "Syntax Exp : exp ::= '(' exp ')' | value | lexp | lexp '=' exp | '++' lexp | '-' exp | exp '(' exps? ')' | 'sizeOf' '(' exp ')' | 'read' '(' ')' | exp '+' exp | exp '-' exp | exp '*' exp | exp '/' exp | exp '%' exp | exp '&lt;' exp | exp '&lt;=' exp | exp '&gt;' exp | exp '&gt;=' exp | exp '==' exp | exp '!=' exp | '!' exp | exp '&amp;&amp;' exp | exp '||' exp | 'spawn' block . Rule [[ '(' Exp ')' ]] : exp = [[ Exp ]] . Semantics rval[[ _:exp ]] : =&gt;values Rule rval[[ V ]] = val[[ V ]] Rule rval[[ LExp ]] = assigned(lval[[ LExp ]]) Rule rval[[ LExp '=' Exp ]] = give( rval[[ Exp ]], sequential( assign(lval[[ LExp ]], given), given)) Rule rval[[ '++' LExp ]] = give( lval[[ LExp ]], sequential( assign(given, integer-add(assigned(given), 1)), assigned(given))) Rule rval[[ '-' Exp ]] = integer-negate(rval[[ Exp ]]) Rule rval[[ Exp '(' Exps? ')' ]] = apply(rval[[ Exp ]], tuple(rvals[[ Exps? ]]) ) Rule rval[[ 'sizeOf' '(' Exp ')' ]] = length(vector-elements(rval[[ Exp ]])) Rule rval[[ 'read' '(' ')' ]] = read Rule rval[[ Exp1 '+' Exp2 ]] = integer-add(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '-' Exp2 ]] = integer-subtract(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '*' Exp2 ]] = integer-multiply(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '/' Exp2 ]] = checked integer-divide(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '%' Exp2 ]] = checked integer-modulo(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&lt;' Exp2 ]] = is-less(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&lt;=' Exp2 ]] = is-less-or-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&gt;' Exp2 ]] = is-greater(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '&gt;=' Exp2 ]] = is-greater-or-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '==' Exp2 ]] = is-equal(rval[[ Exp1 ]],rval[[ Exp2 ]]) Rule rval[[ Exp1 '!=' Exp2 ]] = not(is-equal(rval[[ Exp1 ]],rval[[ Exp2 ]])) Rule rval[[ '!' Exp ]] = not(rval[[ Exp ]]) Rule rval[[ Exp1 '&amp;&amp;' Exp2 ]] = if-else(rval[[ Exp1 ]],rval[[ Exp2 ]],false) Rule rval[[ Exp1 '||' Exp2 ]] = if-else(rval[[ Exp1 ]],true,rval[[ Exp2 ]]) . SIMPLE uses natural numbers to identify threads; the use of allocate-index(_) below associates a natural number with the thread-id given by thread-activate. The use of postpone-after-effect(_) supports automatic release of locks when threads terminate. Rule rval[[ 'spawn' Block ]] = allocate-index thread-activate thread-joinable thunk closure postpone-after-effect exec[[ Block ]] . Syntax Exps : exps ::= exp (',' exps)? . Semantics rvals[[ _:exps? ]] : (=&gt;values)* Rule rvals[[ ]] = ( ) Rule rvals[[ Exp ]] = rval[[ Exp ]] Rule rvals[[ Exp ',' Exps ]] = rval[[ Exp ]] , rvals[[ Exps ]] . Syntax LExp : lexp ::= id | lexp '[' exps ']' . Rule [[ LExp '[' Exp ',' Exps ']' ]] : lexp = [[ LExp '[' Exp ']' '[' Exps ']' ]] . Semantics lval[[ _:lexp ]] : =&gt;variables Rule lval[[ Id ]] = bound(id[[ Id ]]) Rule lval[[ LExp '[' Exp ']' ]] = checked index(integer-add(1,rval[[ Exp ]]),vector-elements(rval[[ LExp ]])) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-2-Expressions/index.html#SectionNumber_2",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-2-Expressions/index.html#SectionNumber_2"
  },"636": {
    "doc": "SIMPLE-THR-2-Expressions",
    "title": "SIMPLE-THR-2-Expressions",
    "content": "Unstable-Languages-beta : SIMPLE-THR-2-Expressions.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-2-Expressions/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-2-Expressions/index.html"
  },"637": {
    "doc": "SIMPLE-THR-3-Statements",
    "title": "3 Statements",
    "content": "Syntax Block : block ::= '{' stmts? '}' Stmts : stmts ::= stmt stmts? Stmt : stmt ::= imp-stmt | vars-decl ImpStmt : imp-stmt ::= block | exp ';' | 'if' '(' exp ')' block ('else' block)? | 'while' '(' exp ')' block | 'for' '(' stmt exp ';' exp ')' block | 'print' '(' exps ')' ';' | 'return' exp? ';' | 'try' block 'catch' '(' id ')' block | 'throw' exp ';' | 'join' exp ';' | 'acquire' exp ';' | 'release' exp ';' | 'rendezvous' exp ';' . Rule [[ 'if' '(' Exp ')' Block ]] : stmt = [[ 'if' '(' Exp ')' Block 'else' '{' '}' ]] Rule [[ 'for' '(' Stmt Exp1 ';' Exp2 ')' '{' Stmts '}' ]] : stmt = [[ '{' Stmt 'while' '(' Exp1 ')' '{' '{' Stmts '}' Exp2 ';' '}' '}' ]] . Semantics exec[[ _:stmts ]] : =&gt;null-type Rule exec[[ '{' '}' ]] = null Rule exec[[ '{' Stmts '}' ]] = exec[[ Stmts ]] Rule exec[[ ImpStmt Stmts ]] = sequential(exec[[ ImpStmt ]], exec[[ Stmts ]]) Rule exec[[ VarsDecl Stmts ]] = scope(declare[[ VarsDecl ]], exec[[ Stmts ]]) Rule exec[[ VarsDecl ]] = effect(declare[[ VarsDecl]]) Rule exec[[ Exp ';' ]] = effect(rval[[ Exp ]]) Rule exec[[ 'if' '(' Exp ')' Block1 'else' Block2 ]] = if-else(rval[[ Exp ]], exec[[ Block1 ]], exec[[ Block2 ]]) Rule exec[[ 'while' '(' Exp ')' Block ]] = while(rval[[ Exp ]], exec[[ Block ]]) Rule exec[[ 'print' '(' Exps ')' ';' ]] = print(rvals[[ Exps ]]) Rule exec[[ 'return' Exp ';' ]] = return(rval[[ Exp ]]) Rule exec[[ 'return' ';' ]] = return(null) Rule exec[[ 'try' Block1 'catch' '(' Id ')' Block2 ]] = handle-thrown( exec[[ Block1 ]], scope( bind(id[[ Id ]], allocate-initialised-variable(values,given)), exec[[ Block2 ]])) Rule exec[[ 'throw' Exp ';' ]] = throw(rval[[ Exp ]]) . SIMPLE uses natural numbers to identify threads; the use of lookup-index(_) below converts a natural number to the associated thread-id. Rule exec[[ 'join' Exp ';' ]] = thread-join lookup-index(rval[[ Exp ]]) . The use of memo-value(V, SY) below associates V with a lock. When a thread requests a lock already held by another thread, the requesting thread is suspended until the request is granted. The use of postpone(_) below automatically releases held locks when the current thread terminates. Rule exec[[ 'acquire' Exp ';' ]] = give( memo-value(rval[[ Exp ]], reentrant-lock-create), sequential( postpone if-true-else(is-exclusive-lock-holder given, reentrant-lock-release given, null-value), reentrant-lock-sync-else-wait given)) . The use of memo-value-recall(V) below gives the lock associated with V. Rule exec[[ 'release' Exp ';' ]] = reentrant-lock-exit memo-value-recall rval[[ Exp ]] . The use of memo-value(V, SY) below associates V with a rendezvous. When a thread requests a rendezvous on a particular value, and there is no previous uncompleted request for a rendezvous on the same value, the requesting thread is suspended until the request is granted. Rule exec[[ 'rendezvous' Exp ';' ]] = rendezvous-sync-else-wait( memo-value(\"rendezvous\", rendezvous-create(2)), rval[[ Exp ]]) . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-3-Statements/index.html#SectionNumber_3",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-3-Statements/index.html#SectionNumber_3"
  },"638": {
    "doc": "SIMPLE-THR-3-Statements",
    "title": "SIMPLE-THR-3-Statements",
    "content": "Unstable-Languages-beta : SIMPLE-THR-3-Statements.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-3-Statements/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-3-Statements/index.html"
  },"639": {
    "doc": "SIMPLE-THR-4-Declarations",
    "title": "4 Declarations",
    "content": "Syntax Decl : decl ::= vars-decl | func-decl . Semantics declare[[ _:decl ]] : =&gt;environments . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4"
  },"640": {
    "doc": "SIMPLE-THR-4-Declarations",
    "title": "4.1 Variable Declarations",
    "content": "Syntax VarsDecl : vars-decl ::= 'var' declarators ';' Declarators : declarators ::= declarator (',' declarators)? . Rule [[ 'var' Declarator ',' Declarators ';' Stmts? ]] : stmts = [[ 'var' Declarator ';' 'var' Declarators ';' Stmts? ]] Rule [[ 'var' Declarator ',' Declarators ';' Decls? ]] : decls = [[ 'var' Declarator ';' 'var' Declarators ';' Decls? ]] Rule declare[[ 'var' Declarator ';' ]] = var-declare[[ Declarator ]] . Syntax Declarator : declarator ::= id | id '=' exp | id ranks . Semantics var-declare[[ _:declarator ]] : =&gt;environments Rule var-declare[[ Id ]] = bind(id[[ Id ]], allocate-variable(values)) Rule var-declare[[ Id '=' Exp ]] = bind(id[[ Id ]], allocate-initialised-variable(values, rval[[ Exp ]])) Rule var-declare[[ Id Ranks ]] = bind(id[[ Id ]], allocate-nested-vectors(ranks[[ Ranks ]])) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.1",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.1"
  },"641": {
    "doc": "SIMPLE-THR-4-Declarations",
    "title": "4.2 Arrays",
    "content": "Syntax Ranks : ranks ::= '[' exps ']' ranks? . Rule [[ '[' Exp ',' Exps ']' Ranks? ]] : ranks = [[ '[' Exp ']' '[' Exps ']' Ranks? ]] . // Compare this with p28 of the K version. Semantics ranks[[ _:ranks ]] : (=&gt;nats)+ Rule ranks[[ '[' Exp ']' ]] = rval[[ Exp ]] Rule ranks[[ '[' Exp ']' Ranks ]] = rval[[ Exp ]] , ranks[[ Ranks ]] . Funcon allocate-nested-vectors(_:nats+) : =&gt;variables Rule allocate-nested-vectors(N:nats) ~&gt; allocate-initialised-variable(vectors(variables), vector(left-to-right-repeat(allocate-variable(values),1,N))) Rule allocate-nested-vectors(N:nats,N+:nats+) ~&gt; allocate-initialised-variable(vectors(variables), vector(left-to-right-repeat(allocate-nested-vectors(N+),1,N))) . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.2",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.2"
  },"642": {
    "doc": "SIMPLE-THR-4-Declarations",
    "title": "4.3 Function Declarations",
    "content": "Syntax FuncDecl : func-decl ::= 'function' id '(' ids? ')' block . Rule declare[[ 'function' Id '(' Ids? ')' Block ]] = bind(id[[ Id ]], allocate-variable(functions(tuples(values*),values))) . Semantics initialise[[ _:decl ]] : =&gt;null-type Rule initialise[[ 'var' Declarators ';' ]] = null Rule initialise[[ 'function' Id '(' Ids? ')' Block ]] = assign( bound(id[[ Id ]]), function closure( scope( match(given,tuple(patts[[ Ids? ]])), handle-return(exec[[ Block ]])))) . Syntax Ids : ids ::= id (',' ids)? . Semantics patts[[ _:ids? ]] : patterns* Rule patts[[ ]] = ( ) Rule patts[[ Id ]] = pattern closure(bind(id[[ Id ]], allocate-initialised-variable(values, given))) Rule patts[[ Id ',' Ids ]] = patts[[ Id ]] , patts[[ Ids ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.3",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html#SectionNumber_4.3"
  },"643": {
    "doc": "SIMPLE-THR-4-Declarations",
    "title": "SIMPLE-THR-4-Declarations",
    "content": "Unstable-Languages-beta : SIMPLE-THR-4-Declarations.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-4-Declarations/index.html"
  },"644": {
    "doc": "SIMPLE-THR-5-Programs",
    "title": "5 Programs",
    "content": "Syntax Pgm : pgm ::= decls . Semantics run[[ Decls:pgm ]] : =&gt;values = scope( collateral(declarations[[ Decls ]]), sequential( initialisations[[ Decls ]], apply(assigned(bound(\"main\")), tuple( )))) . Syntax Decls : decls ::= decl decls? . Semantics declarations[[ _:decls ]] : (=&gt;environments)+ Rule declarations[[ Decl ]] = declare[[ Decl ]] Rule declarations[[ Decl Decls ]] = declare[[ Decl ]], declarations[[ Decls ]] . Semantics initialisations[[ _:decls ]] : (=&gt;null-type)+ Rule initialisations[[ Decl ]] = initialise[[ Decl ]] Rule initialisations[[ Decl Decls ]] = initialise[[ Decl ]], initialisations[[ Decls ]] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-5-Programs/index.html#SectionNumber_5",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-5-Programs/index.html#SectionNumber_5"
  },"645": {
    "doc": "SIMPLE-THR-5-Programs",
    "title": "SIMPLE-THR-5-Programs",
    "content": "Unstable-Languages-beta : SIMPLE-THR-5-Programs.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-5-Programs/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-5-Programs/index.html"
  },"646": {
    "doc": "SIMPLE-THR-A-Disambiguation",
    "title": "A Disambiguation",
    "content": "Lexis SDF lexical syntax id = keyword {reject} lexical restrictions id -/- [A-Za-z0-9] Syntax SDF context-free syntax exp ::= exp '*' exp {left} exp ::= exp '/' exp {left} exp ::= exp '%' exp {left} exp ::= exp '+' exp {left} exp ::= exp '-' exp {left} exp ::= exp '&amp;&amp;' exp {left} exp ::= exp '||' exp {left} context-free priorities { exp ::= exp '(' exps? ')' } &gt; { exp ::= '-' exp exp ::= '++' lexp exp ::= '!' exp } &gt; {left: exp ::= exp '*' exp exp ::= exp '/' exp exp ::= exp '%' exp } &gt; {left: exp ::= exp '+' exp exp ::= exp '-' exp } &gt; {non-assoc: exp ::= exp '&lt;' exp exp ::= exp '&lt;=' exp exp ::= exp '&gt;' exp exp ::= exp '&gt;=' exp exp ::= exp '==' exp exp ::= exp '!=' exp } &gt; {assoc: exp ::= exp '&amp;&amp;' exp } &gt; {assoc: exp ::= exp '||' exp } &gt; { exp ::= lexp '=' exp } . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-A-Disambiguation/index.html#SectionNumber_A",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-A-Disambiguation/index.html#SectionNumber_A"
  },"647": {
    "doc": "SIMPLE-THR-A-Disambiguation",
    "title": "SIMPLE-THR-A-Disambiguation",
    "content": "Unstable-Languages-beta : SIMPLE-THR-A-Disambiguation.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-A-Disambiguation/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-A-Disambiguation/index.html"
  },"648": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#computations"
  },"649": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#normal-computation"
  },"650": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Flowing",
    "content": "[ Funcon sequential Alias seq Funcon effect Funcon if-true-else Alias if-else Funcon while-true Alias while Funcon atomic ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#flowing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#flowing"
  },"651": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Giving",
    "content": "[ Entity given-value Funcon initialise-giving Funcon give Funcon given Funcon no-given Funcon left-to-right-repeat Funcon left-to-right-filter ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#giving",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#giving"
  },"652": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Binding",
    "content": "[ Type environments Alias envs Datatype identifiers Alias ids Funcon initialise-binding Funcon bind-value Alias bind Funcon bound-value Alias bound Funcon scope Funcon collateral ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#binding",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#binding"
  },"653": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Generating",
    "content": "[ Type atoms Funcon fresh-atom ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#generating",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#generating"
  },"654": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Storing",
    "content": "[ Entity store Funcon initialise-storing Datatype variables Alias vars Funcon allocate-variable Alias alloc Funcon allocate-initialised-variable Alias alloc-init Funcon assign Funcon assigned Funcon un-assign ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#storing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#storing"
  },"655": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Interacting",
    "content": "Input . [ Funcon read ] . Output . [ Funcon print ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#interacting",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#interacting"
  },"656": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#abnormal-computation"
  },"657": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Terminating abruptly",
    "content": "[ Entity abrupted Funcon handle-abrupt ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#terminating-abruptly",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#terminating-abruptly"
  },"658": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Failing",
    "content": "[ Funcon finalise-failing Funcon fail Funcon else Funcon checked Funcon check-true ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#failing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#failing"
  },"659": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Throwing",
    "content": "[ Funcon finalise-throwing Funcon throw Funcon handle-thrown ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#throwing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#throwing"
  },"660": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Returning",
    "content": "[ Funcon return Funcon handle-return ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#returning",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#returning"
  },"661": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#values",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#values"
  },"662": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Value Types",
    "content": "[ Type values Alias vals Funcon is-value Alias is-val Funcon when-true Alias when Type ground-values Alias ground-vals Funcon is-equal Alias is-eq ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#value-types",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#value-types"
  },"663": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Primitive values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#primitive-values",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#primitive-values"
  },"664": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Booleans",
    "content": "[ Datatype booleans Alias bools Funcon true Funcon false Funcon not Funcon and ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#booleans",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#booleans"
  },"665": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Integers",
    "content": "[ Type positive-integers Alias pos-ints Type natural-numbers Alias nats Funcon natural-successor Alias nat-succ Funcon natural-predecessor Alias nat-pred Funcon integer-add Alias int-add Funcon integer-subtract Alias int-sub Funcon integer-multiply Alias int-mul Funcon integer-divide Alias int-div Funcon integer-modulo Alias int-mod Funcon integer-negate Alias int-neg Funcon integer-is-less Alias is-less Funcon integer-is-less-or-equal Alias is-less-or-equal Funcon integer-is-greater Alias is-greater Funcon integer-is-greater-or-equal Alias is-greater-or-equal Funcon decimal-natural Alias decimal ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#integers",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#integers"
  },"666": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "The null value",
    "content": "[ Datatype null-type Funcon null-value Alias null ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#the-null-value",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#the-null-value"
  },"667": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Composite values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#composite-values",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#composite-values"
  },"668": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Sequences of values",
    "content": "[ Funcon length Funcon index Funcon first Funcon second ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#sequences-of-values",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#sequences-of-values"
  },"669": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Tuples",
    "content": "[ Datatype tuples Funcon tuple-elements ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#tuples",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#tuples"
  },"670": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Lists",
    "content": "[ Datatype lists Funcon list-elements Funcon list-cons Alias cons Funcon list-head Alias head Funcon list-tail Alias tail Funcon list-append ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#lists",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#lists"
  },"671": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Vectors",
    "content": "[ Datatype vectors Funcon vector Funcon vector-elements ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#vectors",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#vectors"
  },"672": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Sets",
    "content": "[ Type sets Funcon is-in-set Funcon is-subset Funcon set-unite Funcon set-intersect Funcon set-difference Funcon some-element ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#sets",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#sets"
  },"673": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Maps",
    "content": "[ Type maps Funcon map Funcon map-lookup Alias lookup Funcon map-domain Alias dom Funcon map-override Funcon map-unite Funcon map-delete ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#maps",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#maps"
  },"674": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Abstraction values",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#abstraction-values",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#abstraction-values"
  },"675": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Generic abstractions",
    "content": "[ Type abstractions Funcon abstraction Funcon closure ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#generic-abstractions",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#generic-abstractions"
  },"676": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Thunks",
    "content": "[ Datatype thunks Funcon thunk ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#thunks",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#thunks"
  },"677": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Functions",
    "content": "[ Datatype functions Funcon function Funcon apply Funcon supply ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#functions",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#functions"
  },"678": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "Patterns",
    "content": "[ Datatype patterns Funcon pattern Funcon match ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#patterns",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html#patterns"
  },"679": {
    "doc": "SIMPLE-THR-Funcons-Index",
    "title": "SIMPLE-THR-Funcons-Index",
    "content": "Unstable-Languages-beta : SIMPLE-THR-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Flowing | Giving | Binding | Generating | Storing | Interacting . | Input | Output | . | . | Abnormal computation . | Terminating abruptly | Failing | Throwing | Returning | . | . | Values . | Value Types | Primitive values . | Booleans | Integers | The null value | . | Composite values . | Sequences of values | Tuples | Lists | Vectors | Sets | Maps | . | Abstraction values . | Generic abstractions | Thunks | Functions | Patterns | . | . | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Funcons-Index/index.html"
  },"680": {
    "doc": "SIMPLE-THR-Start",
    "title": "SIMPLE-THR-Start",
    "content": "Unstable-Languages-beta : SIMPLE-THR-Start.cbs | PRETTY | PDF . Language \"SIMPLE-THR\" . Syntax START : start ::= pgm . Semantics start[[_:start]] : =&gt;values Rule start[[ Pgm ]] = initialise-binding initialise-storing initialise-giving initialise-memos finalise-failing finalise-throwing multithread postpone-after-effect run[[ Pgm ]] . [ # 1 Lexical Syntax # 2 Expressions # 3 Statements # 4 Declarations # 5 Programs # A Disambiguation ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Start/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Start/index.html"
  },"681": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Computations",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#computations",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#computations"
  },"682": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Normal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#normal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#normal-computation"
  },"683": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Value indexing",
    "content": "[ Funcon allocate-index Funcon lookup-index ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#value-indexing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#value-indexing"
  },"684": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Memos",
    "content": "[ Funcon initialise-memos Funcon memo-value Funcon memo-value-recall ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#memos",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#memos"
  },"685": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Abnormal computation",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#abnormal-computation",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#abnormal-computation"
  },"686": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Postponing",
    "content": "[ Funcon postpone Funcon postpone-after-effect ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#postponing",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#postponing"
  },"687": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Threads",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#threads",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#threads"
  },"688": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Multithreading",
    "content": "[ Funcon thread-joinable ] . Activation . [ Funcon multithread Funcon thread-activate ] . Termination . [ Funcon thread-join ] . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#multithreading",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#multithreading"
  },"689": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "Thread synchronisation",
    "content": "Locks . [ Funcon is-exclusive-lock-holder ] . Reentrant locks . [ Funcon reentrant-lock-create Funcon reentrant-lock-sync-else-wait Funcon reentrant-lock-release Funcon reentrant-lock-exit ] . Notifications . Rendezvous . [ Funcon rendezvous-create Funcon rendezvous-sync-else-wait ] . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#thread-synchronisation",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html#thread-synchronisation"
  },"690": {
    "doc": "SIMPLE-THR-Unstable-Funcons-Index",
    "title": "SIMPLE-THR-Unstable-Funcons-Index",
    "content": "Unstable-Languages-beta : SIMPLE-THR-Unstable-Funcons-Index.cbs | PRETTY | PDF . Outline . | Computations . | Normal computation . | Value indexing | Memos | . | Abnormal computation . | Postponing | . | Threads . | Multithreading . | Activation | Termination | . | Thread synchronisation . | Locks . | Reentrant locks | . | Notifications . | Rendezvous | . | . | . | . | . Unstable Funcons, for use only in Unstable Languages . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/SIMPLE-THR-cbs/SIMPLE-THR/SIMPLE-THR-Unstable-Funcons-Index/index.html"
  },"691": {
    "doc": "SIMPLE-THR",
    "title": "SIMPLE-Threads",
    "content": "Grigore Rosu and Traian Florin Serbanuta gave a definition of SIMPLE in the K-framework in the following article: . K Overview and SIMPLE Case Study. Grigore Rosu and Traian Florin Serbanuta. K’11, ENTCS 304, pp 3-56, 2014. http://dx.doi.org/10.1016/j.entcs.2014.05.002 . They wrote: . SIMPLE is intended to be a pedagogical and research language that captures the essence of the imperative programming paradigm, extended with several features often encountered in imperative languages. Note that the CBS definition uses a more precise abstract syntax grammar than presented in the above publication. In particular, rather than allowing arbitrary expressions as variable declarators and l-expressions, we introduce specialised productions. We also make use of “?” (optional) to avoid the need for multiple productions for variations of the same syntactic construct. The original SIMPLE specification in CBS omitted its concurrency aspects. The present specification SIMPLE-Threads extends SIMPLE to the complete language. The CBS rules from SIMPLE have been copied unchanged, except for the insertion of the funcon multithread in the rule for entire programs. ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html#simple-threads",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html#simple-threads"
  },"692": {
    "doc": "SIMPLE-THR",
    "title": "Colophon",
    "content": "Status: . | abstract syntax: complete | dynamic semantics: complete, including concurrency constructs | static semantics: not specified | disambiguation: incomplete | . Tests: . | 63 small programs | high coverage (to be verified) | . Evolution: . | extension of SIMPLE | . Reuse of funcons: . | SIMPLE-Threads-Funcons-Index | SIMPLE-Threads-Unstable-Funcons-Index | . Keywords: . | imperative, concurrent, illustrative, simple, disambiguation, K framework | . Main contributors: . | Thomas van Binsbergen, Peter Mosses, Neil Sculthorpe | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html#colophon",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html#colophon"
  },"693": {
    "doc": "SIMPLE-THR",
    "title": "SIMPLE-THR",
    "content": " ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/SIMPLE-Threads/index.html"
  },"694": {
    "doc": "TEST-Start",
    "title": "ASCII characters",
    "content": "The apostrophe and the backslash have to be escaped in terminal symbols. Syntax test ::= '! \" # $ % &amp; \\' ( ) * + , - . / : ;' | '&lt; = &gt; ? @ [ \\\\ ] ^ _ ` { | } ~ A Z a z 0 9' . | From the PLanCompS Project | CBS-beta issues… | Suggest an improvement… | . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/Test/Test-cbs/TEST/TEST-Start/index.html#ascii-characters",
    "relUrl": "/docs/Unstable-Languages-beta/Test/Test-cbs/TEST/TEST-Start/index.html#ascii-characters"
  },"695": {
    "doc": "TEST-Start",
    "title": "TEST-Start",
    "content": "Languages-beta : TEST-Start.cbs | PRETTY | PDF . Language \"Test\" . ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/Test/Test-cbs/TEST/TEST-Start/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/Test/Test-cbs/TEST/TEST-Start/index.html"
  },"696": {
    "doc": "Unstable-Languages-beta",
    "title": "Unstable-Languages-beta",
    "content": "Languages-beta provides access to the beta-release of five examples of language specifications in CBS, based on the initial collection of funcons in Funcons-beta. Two of those languages (IMP and SIMPLE) have now been extended with concurrency constructs, using tentative new funcons for threads. A further language has been specified to demonstrate co-evolution of a language and its CBS. The funcons for threads have not yet been fully validated, so they are not included in Funcons-beta. They could be defined locally in a language specification, but reuse in a different language would then entail copying and pasting. To allow their direct reuse in multiple language specifications , they are temporarily provided in a separate library: Unstable-Funcons-beta. Language specifications using funcons from Unstable-Funcons-beta may need to be updated if changes are made to Unstable-Funcons-beta. No updates to language specifications are needed when funcon definitions are moved from Unstable-Funcons-beta to Funcons-beta. Language specifications can be moved from [Unstable-Languages-beta] to Languages-beta when all the funcons used in them have been validated and moved to Funcons-beta. ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/index.html",
    "relUrl": "/docs/Unstable-Languages-beta/index.html"
  },"697": {
    "doc": "Unstable-Languages-beta",
    "title": "IMP++",
    "content": "IMP++ extends IMP with multithreading and other features. See IMP++ for further details. ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/index.html#imp",
    "relUrl": "/docs/Unstable-Languages-beta/index.html#imp"
  },"698": {
    "doc": "Unstable-Languages-beta",
    "title": "SIMPLE-Threads",
    "content": "The original CBS for SIMPLE omits concurrency constructs, which are added here. See SIMPLE-Threads for further details. ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/index.html#simple-threads",
    "relUrl": "/docs/Unstable-Languages-beta/index.html#simple-threads"
  },"699": {
    "doc": "Unstable-Languages-beta",
    "title": "LangDev-2019",
    "content": "This is a language used for demonstrating extensibility of CBS specifications, presented at LangDev Meetup 2019. See LangDev-2019 for further details. ",
    "url": "/CBS-beta/docs/Unstable-Languages-beta/index.html#langdev-2019",
    "relUrl": "/docs/Unstable-Languages-beta/index.html#langdev-2019"
  }
}
